import { ChangeDetectionStrategy, Component, Input } from '@angular/core';
import { Subject } from 'rxjs';
import { debounceTime, distinctUntilChanged } from 'rxjs/operators';
import { Constants } from '../constants';
import * as i0 from "@angular/core";
import * as i1 from "@angular/material/snack-bar";
import * as i2 from "../dynamictable.service";
import * as i3 from "@angular/material/form-field";
import * as i4 from "@angular/material/icon";
import * as i5 from "@angular/material/autocomplete";
import * as i6 from "@angular/material/core";
import * as i7 from "@angular/material/list";
import * as i8 from "@angular/material/checkbox";
import * as i9 from "@angular/material/input";
import * as i10 from "@angular/forms";
import * as i11 from "@angular/common";
export class TableFilterPanelComponent {
    constructor(_snackBar, changeDetectorRefs, dynamictableFilterService) {
        this._snackBar = _snackBar;
        this.changeDetectorRefs = changeDetectorRefs;
        this.dynamictableFilterService = dynamictableFilterService;
        this.horizontalPosition = 'center';
        this.verticalPosition = 'top';
        this.addGroupUpdate = new Subject();
        this.addColumnUpdate = new Subject();
        this.groupedColumns = new Array();
        this.visibleColumns = new Array();
        // Debounce search for add rowGroup.
        this.addGroupUpdate
            .pipe(debounceTime(50), distinctUntilChanged())
            .subscribe((value) => {
            if (value === '') {
                let _filtered = this.configOptions.allColumns.filter((x) => x.groupable && x.visible);
                this.filteredGroupableColumns = _filtered;
                this.changeDetectorRefs.detectChanges();
            }
            else {
                let _filtered = this.configOptions.allColumns.filter((column) => {
                    let index = this.groupedColumns.findIndex((x) => x.id === column.id);
                    return (index < 0 &&
                        column.visible &&
                        column.groupable &&
                        column.displayName
                            ?.toLowerCase()
                            ?.indexOf(value?.toLocaleLowerCase()) > -1);
                });
                this.filteredGroupableColumns = _filtered;
                this.changeDetectorRefs.detectChanges();
            }
        });
        // Debounce search for add columns.
        this.addColumnUpdate
            .pipe(debounceTime(50), distinctUntilChanged())
            .subscribe((value) => {
            if (value === '') {
                this.filteredAllColumns = this.configOptions.allColumns;
                this.changeDetectorRefs.detectChanges();
            }
            else {
                let _filtered = this.configOptions.allColumns.filter((column) => column.displayName
                    .toLocaleLowerCase()
                    .indexOf(value?.toLocaleLowerCase()) > -1);
                this.filteredAllColumns = _filtered;
                this.changeDetectorRefs.detectChanges();
            }
        });
    }
    refreshFilterPanel() {
        this.configOptions = { ...this.configOptions };
        this.groupableColumns = this.configOptions.allColumns.filter((column) => column['visible'] && column['groupable']);
        this.visibleColumns = this.configOptions.allColumns.filter((column) => column['visible']);
        this.groupedColumns = [];
        this.configOptions.groupByColumns.forEach((column) => {
            let index = this.groupableColumns.findIndex((x) => x.id === column);
            if (index > -1) {
                this.groupedColumns.push(this.groupableColumns[index]);
                this.groupableColumns.splice(index, 1);
            }
        });
        this.filteredGroupableColumns = this.groupableColumns;
        // let _filtered = this.configOptions.allColumns;//.filter(column => !column.visible);
        this.filteredAllColumns = this.configOptions.allColumns;
        this.displayedColumns = this.configOptions.allColumns.filter((column) => column['visible']);
        this.changeDetectorRefs.detectChanges();
    }
    displayFn(reportColumn) {
        return '';
    }
    ngOnInit() {
        this.refreshFilterPanel();
        this.subscription = this.dynamictableFilterService
            .getEventEmitter()
            .subscribe((eventData) => {
            this.handleEvent(eventData);
        });
    }
    ngOnChanges(changes) {
        if (changes &&
            changes['configOptions'] &&
            !changes['configOptions'].firstChange) {
            this.refreshFilterPanel();
        }
    }
    handleEvent(event) {
        if (event.eventType === Constants.REFRESH_FILTER_PANEL) {
            this.refreshFilterPanel();
        }
    }
    addGroup(column) {
        this.dynamictableFilterService.emitEvent({
            eventType: Constants.ADD_GROUP,
            data: column
        });
        this.groupSearchKey = '';
    }
    removeGroup(event, column) {
        event.stopPropagation();
        this.dynamictableFilterService.emitEvent({
            eventType: Constants.REMOVE_GROUP,
            data: column
        });
    }
    openSnackBar(message) {
        this._snackBar.open(message, '', {
            horizontalPosition: this.horizontalPosition,
            verticalPosition: this.verticalPosition,
            duration: 5000 // 5 milliseconds
        });
    }
    optionClicked(item) {
        item.visible = !item.visible;
        this.toggleColumnVisibility(item.visible, item.id);
    }
    toggleColumnVisibility(isChecked, columnId) {
        this.visibleColumns = this.configOptions.allColumns.filter((column) => column['visible']);
        if (!isChecked && this.visibleColumns.length == 1) {
            this.filteredAllColumns.forEach((col) => {
                if (col.id === columnId) {
                    col.visible = true;
                }
            });
            this.displayedColumns.forEach((col) => {
                if (col.id === columnId) {
                    col.visible = true;
                }
            });
            this.openSnackBar('Please make sure to have aleast one column in the report!');
            return;
        }
        this.dynamictableFilterService.emitEvent({
            eventType: isChecked ? Constants.ADD_COLUMN : Constants.REMOVE_COLUMN,
            data: { isChecked: isChecked, columnId: columnId }
        });
        this.columnSearchKey = '';
    }
}
TableFilterPanelComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: TableFilterPanelComponent, deps: [{ token: i1.MatSnackBar }, { token: i0.ChangeDetectorRef }, { token: i2.DynamictableFilterService }], target: i0.ɵɵFactoryTarget.Component });
TableFilterPanelComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.1.3", type: TableFilterPanelComponent, selector: "cwp-table-filter-panel", inputs: { configOptions: "configOptions" }, usesOnChanges: true, ngImport: i0, template: "<div>\n  <div class=\"groupBySection\">\n    <label id=\"tableFilterPanelByField\"><b>Group by Fields</b></label\n    ><br />\n    <mat-form-field appearance=\"outline\" class=\"width-100 outline-fields\">\n      <mat-icon id=\"tableFilterPanelSearchIcon\" matPrefix>search</mat-icon>\n      <input\n        type=\"text\"\n        #inputTrigger\n        placeholder=\"Add Group\"\n        matInput\n        [matAutocomplete]=\"autoCompleteGroups\"\n        [(ngModel)]=\"groupSearchKey\"\n        (ngModelChange)=\"addGroupUpdate.next(inputTrigger.value)\"\n      />\n      <mat-autocomplete\n        #autoCompleteGroups=\"matAutocomplete\"\n        [displayWith]=\"displayFn\"\n        (optionSelected)=\"addGroup($event.option.value)\"\n      >\n        <mat-option\n          *ngFor=\"let item of filteredGroupableColumns\"\n          [disabled]=\"this.configOptions.groupByColumns.length >= 3\"\n          [value]=\"item\"\n        >\n          <div (click)=\"addGroup(item)\">\n            <span id=\"tableFilterPanelName\">{{ item.displayName }}</span>\n          </div>\n        </mat-option>\n      </mat-autocomplete>\n    </mat-form-field>\n    <mat-list role=\"list\" class=\"groupBySectionScroll\">\n      <mat-list-item\n        role=\"listitem\"\n        *ngFor=\"let column of groupedColumns\"\n        class=\"columnListItem\"\n      >\n        <div class=\"listItemContent\">\n          <span id=\"tableFilterPanelColName\" class=\"groupby-name\">\n            {{ column.displayName }}\n          </span>\n          <mat-icon\n            id=\"tableFilterPanelCloseIcon\"\n            class=\"smallIcon\"\n            (click)=\"removeGroup($event, column)\"\n          >\n            close\n          </mat-icon>\n        </div>\n      </mat-list-item>\n    </mat-list>\n    <p id=\"tableFilterPanelRows\" class=\"warning-group-message\">\n      Can add only upto 3 Rows\n    </p>\n  </div>\n  <div class=\"tableColumns\">\n    <label id=\"tableFilterPanelCol\"><b>Columns</b></label>\n    <br />\n    <mat-form-field appearance=\"outline\" class=\"width-100 outline-fields\">\n      <mat-icon id=\"tableFilterPanelSearch\" matPrefix>search</mat-icon>\n      <input\n        type=\"text\"\n        placeholder=\"Select Columns\"\n        matInput\n        #inputColumn\n        [matAutocomplete]=\"autoCompleteColumns\"\n        [(ngModel)]=\"columnSearchKey\"\n        (ngModelChange)=\"addColumnUpdate.next(inputColumn.value)\"\n      />\n      <mat-autocomplete\n        #autoCompleteColumns=\"matAutocomplete\"\n        [displayWith]=\"displayFn\"\n        (optionSelected)=\"optionClicked($event.option.value)\"\n      >\n        <mat-option *ngFor=\"let item of filteredAllColumns\" [value]=\"item\">\n          <div (click)=\"optionClicked(item)\">\n            <mat-checkbox\n              [checked]=\"item.visible\"\n              (change)=\"toggleColumnVisibility($event.checked, item.id)\"\n            >\n              {{ item.displayName }}\n            </mat-checkbox>\n          </div>\n        </mat-option>\n      </mat-autocomplete>\n    </mat-form-field>\n    <br />\n    <mat-list role=\"list\" class=\"tableColumnsScroll\">\n      <mat-list-item\n        role=\"listitem\"\n        *ngFor=\"let column of configOptions.allColumns\"\n        class=\"columnListItem\"\n      >\n        <div class=\"listItemContent\">\n          <mat-checkbox\n            disableRipple\n            (change)=\"toggleColumnVisibility($event.checked, column['id'])\"\n            [checked]=\"column['visible']\"\n          >\n            {{ column.displayName }}\n          </mat-checkbox>\n        </div>\n      </mat-list-item>\n    </mat-list>\n  </div>\n</div>\n", styles: [".groupBySection{padding:10px;border:1px solid #b0b0b0;border-radius:5px;margin:5px 0}.groupBySectionScroll{max-height:180px;overflow-y:scroll;overflow-x:hidden;padding:0}.columnListItem{background:#f0f2ff;border:1px solid #f2f2f2;padding:5px!important;width:94%!important;font-size:10pt;height:25px!important;margin:1px}.listItemContent{display:flex;flex-wrap:wrap;justify-content:space-between;align-content:center;width:100%}.groupby-name{position:relative;top:5px}.smallIcon{transform:scale(.75);cursor:pointer}.tableColumns{padding:10px;border:1px solid #b0b0b0;border-radius:5px;margin:5px 0}.tableColumnsScroll{height:180px;overflow-y:scroll;overflow-x:hidden;padding:0}.width-100{width:100%}.warning-group-message{margin:10px 0 0 5px;color:#757575;font-size:80%}\n"], components: [{ type: i3.MatFormField, selector: "mat-form-field", inputs: ["color", "appearance", "hideRequiredMarker", "hintLabel", "floatLabel"], exportAs: ["matFormField"] }, { type: i4.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { type: i5.MatAutocomplete, selector: "mat-autocomplete", inputs: ["disableRipple"], exportAs: ["matAutocomplete"] }, { type: i6.MatOption, selector: "mat-option", exportAs: ["matOption"] }, { type: i7.MatList, selector: "mat-list, mat-action-list", inputs: ["disableRipple", "disabled"], exportAs: ["matList"] }, { type: i7.MatListItem, selector: "mat-list-item, a[mat-list-item], button[mat-list-item]", inputs: ["disableRipple", "disabled"], exportAs: ["matListItem"] }, { type: i8.MatCheckbox, selector: "mat-checkbox", inputs: ["disableRipple", "color", "tabIndex", "aria-label", "aria-labelledby", "aria-describedby", "id", "required", "labelPosition", "name", "value", "checked", "disabled", "indeterminate"], outputs: ["change", "indeterminateChange"], exportAs: ["matCheckbox"] }], directives: [{ type: i3.MatPrefix, selector: "[matPrefix]" }, { type: i9.MatInput, selector: "input[matInput], textarea[matInput], select[matNativeControl],      input[matNativeControl], textarea[matNativeControl]", inputs: ["disabled", "id", "placeholder", "name", "required", "type", "errorStateMatcher", "aria-describedby", "value", "readonly"], exportAs: ["matInput"] }, { type: i5.MatAutocompleteTrigger, selector: "input[matAutocomplete], textarea[matAutocomplete]", exportAs: ["matAutocompleteTrigger"] }, { type: i10.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i10.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i10.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i11.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.1.3", ngImport: i0, type: TableFilterPanelComponent, decorators: [{
            type: Component,
            args: [{ selector: 'cwp-table-filter-panel', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div>\n  <div class=\"groupBySection\">\n    <label id=\"tableFilterPanelByField\"><b>Group by Fields</b></label\n    ><br />\n    <mat-form-field appearance=\"outline\" class=\"width-100 outline-fields\">\n      <mat-icon id=\"tableFilterPanelSearchIcon\" matPrefix>search</mat-icon>\n      <input\n        type=\"text\"\n        #inputTrigger\n        placeholder=\"Add Group\"\n        matInput\n        [matAutocomplete]=\"autoCompleteGroups\"\n        [(ngModel)]=\"groupSearchKey\"\n        (ngModelChange)=\"addGroupUpdate.next(inputTrigger.value)\"\n      />\n      <mat-autocomplete\n        #autoCompleteGroups=\"matAutocomplete\"\n        [displayWith]=\"displayFn\"\n        (optionSelected)=\"addGroup($event.option.value)\"\n      >\n        <mat-option\n          *ngFor=\"let item of filteredGroupableColumns\"\n          [disabled]=\"this.configOptions.groupByColumns.length >= 3\"\n          [value]=\"item\"\n        >\n          <div (click)=\"addGroup(item)\">\n            <span id=\"tableFilterPanelName\">{{ item.displayName }}</span>\n          </div>\n        </mat-option>\n      </mat-autocomplete>\n    </mat-form-field>\n    <mat-list role=\"list\" class=\"groupBySectionScroll\">\n      <mat-list-item\n        role=\"listitem\"\n        *ngFor=\"let column of groupedColumns\"\n        class=\"columnListItem\"\n      >\n        <div class=\"listItemContent\">\n          <span id=\"tableFilterPanelColName\" class=\"groupby-name\">\n            {{ column.displayName }}\n          </span>\n          <mat-icon\n            id=\"tableFilterPanelCloseIcon\"\n            class=\"smallIcon\"\n            (click)=\"removeGroup($event, column)\"\n          >\n            close\n          </mat-icon>\n        </div>\n      </mat-list-item>\n    </mat-list>\n    <p id=\"tableFilterPanelRows\" class=\"warning-group-message\">\n      Can add only upto 3 Rows\n    </p>\n  </div>\n  <div class=\"tableColumns\">\n    <label id=\"tableFilterPanelCol\"><b>Columns</b></label>\n    <br />\n    <mat-form-field appearance=\"outline\" class=\"width-100 outline-fields\">\n      <mat-icon id=\"tableFilterPanelSearch\" matPrefix>search</mat-icon>\n      <input\n        type=\"text\"\n        placeholder=\"Select Columns\"\n        matInput\n        #inputColumn\n        [matAutocomplete]=\"autoCompleteColumns\"\n        [(ngModel)]=\"columnSearchKey\"\n        (ngModelChange)=\"addColumnUpdate.next(inputColumn.value)\"\n      />\n      <mat-autocomplete\n        #autoCompleteColumns=\"matAutocomplete\"\n        [displayWith]=\"displayFn\"\n        (optionSelected)=\"optionClicked($event.option.value)\"\n      >\n        <mat-option *ngFor=\"let item of filteredAllColumns\" [value]=\"item\">\n          <div (click)=\"optionClicked(item)\">\n            <mat-checkbox\n              [checked]=\"item.visible\"\n              (change)=\"toggleColumnVisibility($event.checked, item.id)\"\n            >\n              {{ item.displayName }}\n            </mat-checkbox>\n          </div>\n        </mat-option>\n      </mat-autocomplete>\n    </mat-form-field>\n    <br />\n    <mat-list role=\"list\" class=\"tableColumnsScroll\">\n      <mat-list-item\n        role=\"listitem\"\n        *ngFor=\"let column of configOptions.allColumns\"\n        class=\"columnListItem\"\n      >\n        <div class=\"listItemContent\">\n          <mat-checkbox\n            disableRipple\n            (change)=\"toggleColumnVisibility($event.checked, column['id'])\"\n            [checked]=\"column['visible']\"\n          >\n            {{ column.displayName }}\n          </mat-checkbox>\n        </div>\n      </mat-list-item>\n    </mat-list>\n  </div>\n</div>\n", styles: [".groupBySection{padding:10px;border:1px solid #b0b0b0;border-radius:5px;margin:5px 0}.groupBySectionScroll{max-height:180px;overflow-y:scroll;overflow-x:hidden;padding:0}.columnListItem{background:#f0f2ff;border:1px solid #f2f2f2;padding:5px!important;width:94%!important;font-size:10pt;height:25px!important;margin:1px}.listItemContent{display:flex;flex-wrap:wrap;justify-content:space-between;align-content:center;width:100%}.groupby-name{position:relative;top:5px}.smallIcon{transform:scale(.75);cursor:pointer}.tableColumns{padding:10px;border:1px solid #b0b0b0;border-radius:5px;margin:5px 0}.tableColumnsScroll{height:180px;overflow-y:scroll;overflow-x:hidden;padding:0}.width-100{width:100%}.warning-group-message{margin:10px 0 0 5px;color:#757575;font-size:80%}\n"] }]
        }], ctorParameters: function () { return [{ type: i1.MatSnackBar }, { type: i0.ChangeDetectorRef }, { type: i2.DynamictableFilterService }]; }, propDecorators: { configOptions: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUtZmlsdGVyLXBhbmVsLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2R5bmFtaWN0YWJsZS9zcmMvbGliL3RhYmxlLWZpbHRlci1wYW5lbC90YWJsZS1maWx0ZXItcGFuZWwuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvZHluYW1pY3RhYmxlL3NyYy9saWIvdGFibGUtZmlsdGVyLXBhbmVsL3RhYmxlLWZpbHRlci1wYW5lbC5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsdUJBQXVCLEVBRXZCLFNBQVMsRUFDVCxLQUFLLEVBR04sTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUUvQixPQUFPLEVBQUUsWUFBWSxFQUFFLG9CQUFvQixFQUFPLE1BQU0sZ0JBQWdCLENBQUM7QUFDekUsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGNBQWMsQ0FBQzs7Ozs7Ozs7Ozs7OztBQWF6QyxNQUFNLE9BQU8seUJBQXlCO0lBcUJwQyxZQUNVLFNBQXNCLEVBQ3RCLGtCQUFxQyxFQUNyQyx5QkFBb0Q7UUFGcEQsY0FBUyxHQUFULFNBQVMsQ0FBYTtRQUN0Qix1QkFBa0IsR0FBbEIsa0JBQWtCLENBQW1CO1FBQ3JDLDhCQUF5QixHQUF6Qix5QkFBeUIsQ0FBMkI7UUF2QjlELHVCQUFrQixHQUFrQyxRQUFRLENBQUM7UUFDN0QscUJBQWdCLEdBQWdDLEtBQUssQ0FBQztRQUl0RCxtQkFBYyxHQUFHLElBQUksT0FBTyxFQUFVLENBQUM7UUFJdkMsb0JBQWUsR0FBRyxJQUFJLE9BQU8sRUFBVSxDQUFDO1FBSXhDLG1CQUFjLEdBQVUsSUFBSSxLQUFLLEVBQU8sQ0FBQztRQUl6QyxtQkFBYyxHQUFVLElBQUksS0FBSyxFQUFPLENBQUM7UUFRdkMsb0NBQW9DO1FBQ3BDLElB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YUFBYTtZQUNyRSxJQUFJLEVBQUUsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUU7U0FDbkQsQ0FBQyxDQUFDO1FBRUgsSUFBSSxDQUFDLGVBQWUsR0FBRyxFQUFFLENBQUM7SUFDNUIsQ0FBQzs7c0hBN0xVLHlCQUF5QjswR0FBekIseUJBQXlCLCtIQ3hCdEMsc21IQTBHQTsyRkRsRmEseUJBQXlCO2tCQU5yQyxTQUFTOytCQUNFLHdCQUF3QixtQkFDakIsdUJBQXVCLENBQUMsTUFBTTswS0FRdEMsYUFBYTtzQkFBckIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBJbnB1dCxcbiAgT25Jbml0LFxuICBTaW1wbGVDaGFuZ2VzXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQ29sdW1uLCBDb25maWdPcHRpb25zIH0gZnJvbSAnLi4vaW50ZXJmYWNlcyc7XG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUsIGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBDb25zdGFudHMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgRHluYW1pY3RhYmxlRmlsdGVyU2VydmljZSB9IGZyb20gJy4uL2R5bmFtaWN0YWJsZS5zZXJ2aWNlJztcbmltcG9ydCB7XG4gIE1hdFNuYWNrQmFyLFxuICBNYXRTbmFja0Jhckhvcml6b250YWxQb3NpdGlvbixcbiAgTWF0U25hY2tCYXJWZXJ0aWNhbFBvc2l0aW9uXG59IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL3NuYWNrLWJhcic7XG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdjd3AtdGFibGUtZmlsdGVyLXBhbmVsJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIHRlbXBsYXRlVXJsOiAnLi90YWJsZS1maWx0ZXItcGFuZWwuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi90YWJsZS1maWx0ZXItcGFuZWwuY29tcG9uZW50LmNzcyddXG59KVxuZXhwb3J0IGNsYXNzIFRhYmxlRmlsdGVyUGFuZWxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICBob3Jpem9udGFsUG9zaXRpb246IE1hdFNuYWNrQmFySG9yaXpvbnRhbFBvc2l0aW9uID0gJ2NlbnRlcic7XG4gIHZlcnRpY2FsUG9zaXRpb246IE1hdFNuYWNrQmFyVmVydGljYWxQb3NpdGlvbiA9ICd0b3AnO1xuXG4gIEBJbnB1dCgpIGNvbmZpZ09wdGlvbnM6IENvbmZpZ09wdGlvbnM7XG5cbiAgYWRkR3JvdXBVcGRhdGUgPSBuZXcgU3ViamVjdDxzdHJpbmc+KCk7XG4gIGdyb3VwU2VhcmNoS2V5OiBzdHJpbmc7XG4gIGZpbHRlcmVkR3JvdXBhYmxlQ29sdW1uczogYW55W107XG5cbiAgYWRkQ29sdW1uVXBkYXRlID0gbmV3IFN1YmplY3Q8c3RyaW5nPigpO1xuICBjb2x1bW5TZWFyY2hLZXk6IHN0cmluZztcbiAgZmlsdGVyZWRBbGxDb2x1bW5zOiBDb2x1bW5bXTtcblxuICBncm91cGVkQ29sdW1uczogYW55W10gPSBuZXcgQXJyYXk8YW55PigpO1xuICBncm91cGFibGVDb2x1bW5zOiBhbnlbXTtcblxuICBkaXNwbGF5ZWRDb2x1bW5zOiBDb2x1bW5bXTtcbiAgdmlzaWJsZUNvbHVtbnM6IGFueVtdID0gbmV3IEFycmF5PGFueT4oKTtcbiAgc3Vic2NyaXB0aW9uOiBhbnk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfc25hY2tCYXI6IE1hdFNuYWNrQmFyLFxuICAgIHByaXZhdGUgY2hhbmdlRGV0ZWN0b3JSZWZzOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBwcml2YXRlIGR5bmFtaWN0YWJsZUZpbHRlclNlcnZpY2U6IER5bmFtaWN0YWJsZUZpbHRlclNlcnZpY2VcbiAgKSB7XG4gICAgLy8gRGVib3VuY2Ugc2VhcmNoIGZvciBhZGQgcm93R3JvdXAuXG4gICAgdGhpcy5hZGRHcm91cFVwZGF0ZVxuICAgICAgLnBpcGUoZGVib3VuY2VUaW1lKDUwKSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSlcbiAgICAgIC5zdWJzY3JpYmUoKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgIGxldCBfZmlsdGVyZWQgPSB0aGlzLmNvbmZpZ09wdGlvbnMuYWxsQ29sdW1ucy5maWx0ZXIoXG4gICAgICAgICAgICAoeDogYW55KSA9PiB4Lmdyb3VwYWJsZSAmJiB4LnZpc2libGVcbiAgICAgICAgICApO1xuICAgICAgICAgIHRoaXMuZmlsdGVyZWRHcm91cGFibGVDb2x1bW5zID0gX2ZpbHRlcmVkO1xuICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWZzLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgX2ZpbHRlcmVkID0gdGhpcy5jb25maWdPcHRpb25zLmFsbENvbHVtbnMuZmlsdGVyKFxuICAgICAgICAgICAgKGNvbHVtbjogYW55KSA9PiB7XG4gICAgICAgICAgICAgIGxldCBpbmRleCA9IHRoaXMuZ3JvdXBlZENvbHVtbnMuZmluZEluZGV4KFxuICAgICAgICAgICAgICAgICh4KSA9PiB4LmlkID09PSBjb2x1bW4uaWRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICBpbmRleCA8IDAgJiZcbiAgICAgICAgICAgICAgICBjb2x1bW4udmlzaWJsZSAmJlxuICAgICAgICAgICAgICAgIGNvbHVtbi5ncm91cGFibGUgJiZcbiAgICAgICAgICAgICAgICBjb2x1bW4uZGlzcGxheU5hbWVcbiAgICAgICAgICAgICAgICAgID8udG9Mb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgPy5pbmRleE9mKHZhbHVlPy50b0xvY2FsZUxvd2VyQ2FzZSgpKSA+IC0xXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLmZpbHRlcmVkR3JvdXBhYmxlQ29sdW1ucyA9IF9maWx0ZXJlZDtcbiAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmcy5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgLy8gRGVib3VuY2Ugc2VhcmNoIGZvciBhZGQgY29sdW1ucy5cbiAgICB0aGlzLmFkZENvbHVtblVwZGF0ZVxuICAgICAgLnBpcGUoZGVib3VuY2VUaW1lKDUwKSwgZGlzdGluY3RVbnRpbENoYW5nZWQoKSlcbiAgICAgIC5zdWJzY3JpYmUoKHZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgIHRoaXMuZmlsdGVyZWRBbGxDb2x1bW5zID0gdGhpcy5jb25maWdPcHRpb25zLmFsbENvbHVtbnM7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZnMuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBfZmlsdGVyZWQgPSB0aGlzLmNvbmZpZ09wdGlvbnMuYWxsQ29sdW1ucy5maWx0ZXIoXG4gICAgICAgICAgICAoY29sdW1uKSA9PlxuICAgICAgICAgICAgICBjb2x1bW4uZGlzcGxheU5hbWVcbiAgICAgICAgICAgICAgICAudG9Mb2NhbGVMb3dlckNhc2UoKVxuICAgICAgICAgICAgICAgIC5pbmRleE9mKHZhbHVlPy50b0xvY2FsZUxvd2VyQ2FzZSgpKSA+IC0xXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLmZpbHRlcmVkQWxsQ29sdW1ucyA9IF9maWx0ZXJlZDtcbiAgICAgICAgICB0aGlzLmNoYW5nZURldGVjdG9yUmVmcy5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgcmVmcmVzaEZpbHRlclBhbmVsKCkge1xuICAgIHRoaXMuY29uZmlnT3B0aW9ucyA9IHsgLi4udGhpcy5jb25maWdPcHRpb25zIH07XG4gICAgdGhpcy5ncm91cGFibGVDb2x1bW5zID0gdGhpcy5jb25maWdPcHRpb25zLmFsbENvbHVtbnMuZmlsdGVyKFxuICAgICAgKGNvbHVtbikgPT4gY29sdW1uWyd2aXNpYmxlJ10gJiYgY29sdW1uWydncm91cGFibGUnXVxuICAgICk7XG4gICAgdGhpcy52aXNpYmxlQ29sdW1ucyA9IHRoaXMuY29uZmlnT3B0aW9ucy5hbGxDb2x1bW5zLmZpbHRlcihcbiAgICAgIChjb2x1bW4pID0+IGNvbHVtblsndmlzaWJsZSddXG4gICAgKTtcblxuICAgIHRoaXMuZ3JvdXBlZENvbHVtbnMgPSBbXTtcbiAgICB0aGlzLmNvbmZpZ09wdGlvbnMuZ3JvdXBCeUNvbHVtbnMuZm9yRWFjaCgoY29sdW1uOiBzdHJpbmcpID0+IHtcbiAgICAgIGxldCBpbmRleCA9IHRoaXMuZ3JvdXBhYmxlQ29sdW1ucy5maW5kSW5kZXgoKHgpID0+IHguaWQgPT09IGNvbHVtbik7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLmdyb3VwZWRDb2x1bW5zLnB1c2godGhpcy5ncm91cGFibGVDb2x1bW5zW2luZGV4XSk7XG4gICAgICAgIHRoaXMuZ3JvdXBhYmxlQ29sdW1ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZmlsdGVyZWRHcm91cGFibGVDb2x1bW5zID0gdGhpcy5ncm91cGFibGVDb2x1bW5zO1xuICAgIC8vIGxldCBfZmlsdGVyZWQgPSB0aGlzLmNvbmZpZ09wdGlvbnMuYWxsQ29sdW1uczsvLy5maWx0ZXIoY29sdW1uID0+ICFjb2x1bW4udmlzaWJsZSk7XG4gICAgdGhpcy5maWx0ZXJlZEFsbENvbHVtbnMgPSB0aGlzLmNvbmZpZ09wdGlvbnMuYWxsQ29sdW1ucztcbiAgICB0aGlzLmRpc3BsYXllZENvbHVtbnMgPSB0aGlzLmNvbmZpZ09wdGlvbnMuYWxsQ29sdW1ucy5maWx0ZXIoXG4gICAgICAoY29sdW1uKSA9PiBjb2x1bW5bJ3Zpc2libGUnXVxuICAgICk7XG4gICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZnMuZGV0ZWN0Q2hhbmdlcygpO1xuICB9XG5cbiAgZGlzcGxheUZuKHJlcG9ydENvbHVtbjogYW55KTogc3RyaW5nIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnJlZnJlc2hGaWx0ZXJQYW5lbCgpO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gdGhpcy5keW5hbWljdGFibGVGaWx0ZXJTZXJ2aWNlXG4gICAgICAuZ2V0RXZlbnRFbWl0dGVyKClcbiAgICAgIC5zdWJzY3JpYmUoKGV2ZW50RGF0YSkgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZUV2ZW50KGV2ZW50RGF0YSk7XG4gICAgICB9KTtcbiAgfVxuXG4gIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICBpZiAoXG4gICAgICBjaGFuZ2VzICYmXG4gICAgICBjaGFuZ2VzWydjb25maWdPcHRpb25zJ10gJiZcbiAgICAgICFjaGFuZ2VzWydjb25maWdPcHRpb25zJ10uZmlyc3RDaGFuZ2VcbiAgICApIHtcbiAgICAgIHRoaXMucmVmcmVzaEZpbHRlclBhbmVsKCk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRXZlbnQoZXZlbnQ6IGFueSkge1xuICAgIGlmIChldmVudC5ldmVudFR5cGUgPT09IENvbnN0YW50cy5SRUZSRVNIX0ZJTFRFUl9QQU5FTCkge1xuICAgICAgdGhpcy5yZWZyZXNoRmlsdGVyUGFuZWwoKTtcbiAgICB9XG4gIH1cblxuICBhZGRHcm91cChjb2x1bW46IGFueSkge1xuICAgIHRoaXMuZHluYW1pY3RhYmxlRmlsdGVyU2VydmljZS5lbWl0RXZlbnQoe1xuICAgICAgZXZlbnRUeXBlOiBDb25zdGFudHMuQUREX0dST1VQLFxuICAgICAgZGF0YTogY29sdW1uXG4gICAgfSk7XG5cbiAgICB0aGlzLmdyb3VwU2VhcmNoS2V5ID0gJyc7XG4gIH1cblxuICByZW1vdmVHcm91cChldmVudDogYW55LCBjb2x1bW46IGFueSkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHRoaXMuZHluYW1pY3RhYmxlRmlsdGVyU2VydmljZS5lbWl0RXZlbnQoe1xuICAgICAgZXZlbnRUeXBlOiBDb25zdGFudHMuUkVNT1ZFX0dST1VQLFxuICAgICAgZGF0YTogY29sdW1uXG4gICAgfSk7XG4gIH1cblxuICBvcGVuU25hY2tCYXIobWVzc2FnZTogc3RyaW5nKSB7XG4gICAgdGhpcy5fc25hY2tCYXIub3BlbihtZXNzYWdlLCAnJywge1xuICAgICAgaG9yaXpvbnRhbFBvc2l0aW9uOiB0aGlzLmhvcml6b250YWxQb3NpdGlvbixcbiAgICAgIHZlcnRpY2FsUG9zaXRpb246IHRoaXMudmVydGljYWxQb3NpdGlvbixcbiAgICAgIGR1cmF0aW9uOiA1MDAwIC8vIDUgbWlsbGlzZWNvbmRzXG4gICAgfSk7XG4gIH1cblxuICBvcHRpb25DbGlja2VkKGl0ZW06IGFueSkge1xuICAgIGl0ZW0udmlzaWJsZSA9ICFpdGVtLnZpc2libGU7XG4gICAgdGhpcy50b2dnbGVDb2x1bW5WaXNpYmlsaXR5KGl0ZW0udmlzaWJsZSwgaXRlbS5pZCk7XG4gIH1cblxuICB0b2dnbGVDb2x1bW5WaXNpYmlsaXR5KGlzQ2hlY2tlZDogYm9vbGVhbiwgY29sdW1uSWQ6IHN0cmluZykge1xuICAgIHRoaXMudmlzaWJsZUNvbHVtbnMgPSB0aGlzLmNvbmZpZ09wdGlvbnMuYWxsQ29sdW1ucy5maWx0ZXIoXG4gICAgICAoY29sdW1uKSA9PiBjb2x1bW5bJ3Zpc2libGUnXVxuICAgICk7XG4gICAgaWYgKCFpc0NoZWNrZWQgJiYgdGhpcy52aXNpYmxlQ29sdW1ucy5sZW5ndGggPT0gMSkge1xuICAgICAgdGhpcy5maWx0ZXJlZEFsbENvbHVtbnMuZm9yRWFjaCgoY29sKSA9PiB7XG4gICAgICAgIGlmIChjb2wuaWQgPT09IGNvbHVtbklkKSB7XG4gICAgICAgICAgY29sLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZGlzcGxheWVkQ29sdW1ucy5mb3JFYWNoKChjb2wpID0+IHtcbiAgICAgICAgaWYgKGNvbC5pZCA9PT0gY29sdW1uSWQpIHtcbiAgICAgICAgICBjb2wudmlzaWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5vcGVuU25hY2tCYXIoXG4gICAgICAgICdQbGVhc2UgbWFrZSBzdXJlIHRvIGhhdmUgYWxlYXN0IG9uZSBjb2x1bW4gaW4gdGhlIHJlcG9ydCEnXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZHluYW1pY3RhYmxlRmlsdGVyU2VydmljZS5lbWl0RXZlbnQoe1xuICAgICAgZXZlbnRUeXBlOiBpc0NoZWNrZWQgPyBDb25zdGFudHMuQUREX0NPTFVNTiA6IENvbnN0YW50cy5SRU1PVkVfQ09MVU1OLFxuICAgICAgZGF0YTogeyBpc0NoZWNrZWQ6IGlzQ2hlY2tlZCwgY29sdW1uSWQ6IGNvbHVtbklkIH1cbiAgICB9KTtcblxuICAgIHRoaXMuY29sdW1uU2VhcmNoS2V5ID0gJyc7XG4gIH1cbn1cbiIsIjxkaXY+XG4gIDxkaXYgY2xhc3M9XCJncm91cEJ5U2VjdGlvblwiPlxuICAgIDxsYWJlbCBpZD1cInRhYmxlRmlsdGVyUGFuZWxCeUZpZWxkXCI+PGI+R3JvdXAgYnkgRmllbGRzPC9iPjwvbGFiZWxcbiAgICA+PGJyIC8+XG4gICAgPG1hdC1mb3JtLWZpZWxkIGFwcGVhcmFuY2U9XCJvdXRsaW5lXCIgY2xhc3M9XCJ3aWR0aC0xMDAgb3V0bGluZS1maWVsZHNcIj5cbiAgICAgIDxtYXQtaWNvbiBpZD1cInRhYmxlRmlsdGVyUGFuZWxTZWFyY2hJY29uXCIgbWF0UHJlZml4PnNlYXJjaDwvbWF0LWljb24+XG4gICAgICA8aW5wdXRcbiAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAjaW5wdXRUcmlnZ2VyXG4gICAgICAgIHBsYWNlaG9sZGVyPVwiQWRkIEdyb3VwXCJcbiAgICAgICAgbWF0SW5wdXRcbiAgICAgICAgW21hdEF1dG9jb21wbGV0ZV09XCJhdXRvQ29tcGxldGVHcm91cHNcIlxuICAgICAgICBbKG5nTW9kZWwpXT1cImdyb3VwU2VhcmNoS2V5XCJcbiAgICAgICAgKG5nTW9kZWxDaGFuZ2UpPVwiYWRkR3JvdXBVcGRhdGUubmV4dChpbnB1dFRyaWdnZXIudmFsdWUpXCJcbiAgICAgIC8+XG4gICAgICA8bWF0LWF1dG9jb21wbGV0ZVxuICAgICAgICAjYXV0b0NvbXBsZXRlR3JvdXBzPVwibWF0QXV0b2NvbXBsZXRlXCJcbiAgICAgICAgW2Rpc3BsYXlXaXRoXT1cImRpc3BsYXlGblwiXG4gICAgICAgIChvcHRpb25TZWxlY3RlZCk9XCJhZGRHcm91cCgkZXZlbnQub3B0aW9uLnZhbHVlKVwiXG4gICAgICA+XG4gICAgICAgIDxtYXQtb3B0aW9uXG4gICAgICAgICAgKm5nRm9yPVwibGV0IGl0ZW0gb2YgZmlsdGVyZWRHcm91cGFibGVDb2x1bW5zXCJcbiAgICAgICAgICBbZGlzYWJsZWRdPVwidGhpcy5jb25maWdPcHRpb25zLmdyb3VwQnlDb2x1bW5zLmxlbmd0aCA+PSAzXCJcbiAgICAgICAgICBbdmFsdWVdPVwiaXRlbVwiXG4gICAgICAgID5cbiAgICAgICAgICA8ZGl2IChjbGljayk9XCJhZGRHcm91cChpdGVtKVwiPlxuICAgICAgICAgICAgPHNwYW4gaWQ9XCJ0YWJsZUZpbHRlclBhbmVsTmFtZVwiPnt7IGl0ZW0uZGlzcGxheU5hbWUgfX08L3NwYW4+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvbWF0LW9wdGlvbj5cbiAgICAgIDwvbWF0LWF1dG9jb21wbGV0ZT5cbiAgICA8L21hdC1mb3JtLWZpZWxkPlxuICAgIDxtYXQtbGlzdCByb2xlPVwibGlzdFwiIGNsYXNzPVwiZ3JvdXBCeVNlY3Rpb25TY3JvbGxcIj5cbiAgICAgIDxtYXQtbGlzdC1pdGVtXG4gICAgICAgIHJvbGU9XCJsaXN0aXRlbVwiXG4gICAgICAgICpuZ0Zvcj1cImxldCBjb2x1bW4gb2YgZ3JvdXBlZENvbHVtbnNcIlxuICAgICAgICBjbGFzcz1cImNvbHVtbkxpc3RJdGVtXCJcbiAgICAgID5cbiAgICAgICAgPGRpdiBjbGFzcz1cImxpc3RJdGVtQ29udGVudFwiPlxuICAgICAgICAgIDxzcGFuIGlkPVwidGFibGVGaWx0ZXJQYW5lbENvbE5hbWVcIiBjbGFzcz1cImdyb3VwYnktbmFtZVwiPlxuICAgICAgICAgICAge3sgY29sdW1uLmRpc3BsYXlOYW1lIH19XG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgIDxtYXQtaWNvblxuICAgICAgICAgICAgaWQ9XCJ0YWJsZUZpbHRlclBhbmVsQ2xvc2VJY29uXCJcbiAgICAgICAgICAgIGNsYXNzPVwic21hbGxJY29uXCJcbiAgICAgICAgICAgIChjbGljayk9XCJyZW1vdmVHcm91cCgkZXZlbnQsIGNvbHVtbilcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIGNsb3NlXG4gICAgICAgICAgPC9tYXQtaWNvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L21hdC1saXN0LWl0ZW0+XG4gICAgPC9tYXQtbGlzdD5cbiAgICA8cCBpZD1cInRhYmxlRmlsdGVyUGFuZWxSb3dzXCIgY2xhc3M9XCJ3YXJuaW5nLWdyb3VwLW1lc3NhZ2VcIj5cbiAgICAgIENhbiBhZGQgb25seSB1cHRvIDMgUm93c1xuICAgIDwvcD5cbiAgPC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJ0YWJsZUNvbHVtbnNcIj5cbiAgICA8bGFiZWwgaWQ9XCJ0YWJsZUZpbHRlclBhbmVsQ29sXCI+PGI+Q29sdW1uczwvYj48L2xhYmVsPlxuICAgIDxiciAvPlxuICAgIDxtYXQtZm9ybS1maWVsZCBhcHBlYXJhbmNlPVwib3V0bGluZVwiIGNsYXNzPVwid2lkdGgtMTAwIG91dGxpbmUtZmllbGRzXCI+XG4gICAgICA8bWF0LWljb24gaWQ9XCJ0YWJsZUZpbHRlclBhbmVsU2VhcmNoXCIgbWF0UHJlZml4PnNlYXJjaDwvbWF0LWljb24+XG4gICAgICA8aW5wdXRcbiAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICBwbGFjZWhvbGRlcj1cIlNlbGVjdCBDb2x1bW5zXCJcbiAgICAgICAgbWF0SW5wdXRcbiAgICAgICAgI2lucHV0Q29sdW1uXG4gICAgICAgIFttYXRBdXRvY29tcGxldGVdPVwiYXV0b0NvbXBsZXRlQ29sdW1uc1wiXG4gICAgICAgIFsobmdNb2RlbCldPVwiY29sdW1uU2VhcmNoS2V5XCJcbiAgICAgICAgKG5nTW9kZWxDaGFuZ2UpPVwiYWRkQ29sdW1uVXBkYXRlLm5leHQoaW5wdXRDb2x1bW4udmFsdWUpXCJcbiAgICAgIC8+XG4gICAgICA8bWF0LWF1dG9jb21wbGV0ZVxuICAgICAgICAjYXV0b0NvbXBsZXRlQ29sdW1ucz1cIm1hdEF1dG9jb21wbGV0ZVwiXG4gICAgICAgIFtkaXNwbGF5V2l0aF09XCJkaXNwbGF5Rm5cIlxuICAgICAgICAob3B0aW9uU2VsZWN0ZWQpPVwib3B0aW9uQ2xpY2tlZCgkZXZlbnQub3B0aW9uLnZhbHVlKVwiXG4gICAgICA+XG4gICAgICAgIDxtYXQtb3B0aW9uICpuZ0Zvcj1cImxldCBpdGVtIG9mIGZpbHRlcmVkQWxsQ29sdW1uc1wiIFt2YWx1ZV09XCJpdGVtXCI+XG4gICAgICAgICAgPGRpdiAoY2xpY2spPVwib3B0aW9uQ2xpY2tlZChpdGVtKVwiPlxuICAgICAgICAgICAgPG1hdC1jaGVja2JveFxuICAgICAgICAgICAgICBbY2hlY2tlZF09XCJpdGVtLnZpc2libGVcIlxuICAgICAgICAgICAgICAoY2hhbmdlKT1cInRvZ2dsZUNvbHVtblZpc2liaWxpdHkoJGV2ZW50LmNoZWNrZWQsIGl0ZW0uaWQpXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge3sgaXRlbS5kaXNwbGF5TmFtZSB9fVxuICAgICAgICAgICAgPC9tYXQtY2hlY2tib3g+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvbWF0LW9wdGlvbj5cbiAgICAgIDwvbWF0LWF1dG9jb21wbGV0ZT5cbiAgICA8L21hdC1mb3JtLWZpZWxkPlxuICAgIDxiciAvPlxuICAgIDxtYXQtbGlzdCByb2xlPVwibGlzdFwiIGNsYXNzPVwidGFibGVDb2x1bW5zU2Nyb2xsXCI+XG4gICAgICA8bWF0LWxpc3QtaXRlbVxuICAgICAgICByb2xlPVwibGlzdGl0ZW1cIlxuICAgICAgICAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIGNvbmZpZ09wdGlvbnMuYWxsQ29sdW1uc1wiXG4gICAgICAgIGNsYXNzPVwiY29sdW1uTGlzdEl0ZW1cIlxuICAgICAgPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibGlzdEl0ZW1Db250ZW50XCI+XG4gICAgICAgICAgPG1hdC1jaGVja2JveFxuICAgICAgICAgICAgZGlzYWJsZVJpcHBsZVxuICAgICAgICAgICAgKGNoYW5nZSk9XCJ0b2dnbGVDb2x1bW5WaXNpYmlsaXR5KCRldmVudC5jaGVja2VkLCBjb2x1bW5bJ2lkJ10pXCJcbiAgICAgICAgICAgIFtjaGVja2VkXT1cImNvbHVtblsndmlzaWJsZSddXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICB7eyBjb2x1bW4uZGlzcGxheU5hbWUgfX1cbiAgICAgICAgICA8L21hdC1jaGVja2JveD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L21hdC1saXN0LWl0ZW0+XG4gICAgPC9tYXQtbGlzdD5cbiAgPC9kaXY+XG48L2Rpdj5cbiJdfQ==