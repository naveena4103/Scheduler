import {
  MatSelect,
  MatSelectModule
} from "./chunk-Z5VQAJAA.js";
import {
  MatSidenavModule
} from "./chunk-PHSKTZLM.js";
import {
  CdkTableModule,
  MatCell,
  MatCellDef,
  MatColumnDef,
  MatHeaderCell,
  MatHeaderCellDef,
  MatHeaderRow,
  MatHeaderRowDef,
  MatRow,
  MatRowDef,
  MatTable,
  MatTableModule
} from "./chunk-YG42KT45.js";
import {
  MatToolbarModule
} from "./chunk-PWAYWC73.js";
import {
  MatDatepickerModule
} from "./chunk-SPI3FKHG.js";
import {
  MatInput,
  MatInputModule
} from "./chunk-YRCAJ3OH.js";
import {
  MatMenu,
  MatMenuContent,
  MatMenuItem,
  MatMenuModule,
  MatMenuTrigger
} from "./chunk-LD6Z2CEK.js";
import {
  MatProgressBarModule
} from "./chunk-LGT7QRTT.js";
import {
  MatList,
  MatListItem,
  MatListModule
} from "./chunk-GCX63PQS.js";
import {
  MatProgressSpinnerModule
} from "./chunk-IVVUZCC5.js";
import {
  MatRadioModule
} from "./chunk-SWGPY6G7.js";
import {
  MatButton,
  MatButtonModule
} from "./chunk-D35QQZZS.js";
import {
  MatButtonToggle,
  MatButtonToggleGroup,
  MatButtonToggleModule
} from "./chunk-SXOME3CY.js";
import {
  MatCardModule
} from "./chunk-PBUYHO2W.js";
import {
  MatCheckbox,
  MatCheckboxModule
} from "./chunk-KEO5JGRS.js";
import {
  MatDialogModule
} from "./chunk-OBQT5Q7H.js";
import {
  MatDividerModule
} from "./chunk-2P356S4R.js";
import {
  MatIcon,
  MatIconModule
} from "./chunk-MIEHK7G2.js";
import {
  CdkDrag,
  CdkDropList,
  DragDropModule,
  moveItemInArray
} from "./chunk-WJMAIOQQ.js";
import {
  MatAutocomplete,
  MatAutocompleteModule,
  MatAutocompleteTrigger
} from "./chunk-LC7AU4ZK.js";
import {
  MatFormField,
  MatFormFieldControl,
  MatPrefix
} from "./chunk-7UHDX6PQ.js";
import {
  CheckboxRequiredValidator,
  DefaultValueAccessor,
  FormGroupDirective,
  FormsModule,
  NG_VALIDATORS,
  NG_VALUE_ACCESSOR,
  NgControl,
  NgControlStatus,
  NgForm,
  NgModel,
  Validators
} from "./chunk-6JOWPH3J.js";
import {
  Overlay,
  OverlayConfig,
  OverlayModule
} from "./chunk-A6XYXPCV.js";
import {
  BasePortalOutlet,
  CdkPortal,
  CdkPortalOutlet,
  ComponentPortal,
  PortalModule,
  TemplatePortal
} from "./chunk-VEHDF5JB.js";
import {
  CdkScrollableModule,
  ScrollDispatcher,
  ScrollingModule,
  ViewportRuler
} from "./chunk-MDLWY3M7.js";
import {
  SelectionModel,
  UniqueSelectionDispatcher,
  isDataSource
} from "./chunk-2F4FYE72.js";
import {
  MatBadgeModule
} from "./chunk-4QN33QZE.js";
import {
  AnimationCurves,
  AnimationDurations,
  ErrorStateMatcher,
  MAT_RIPPLE_GLOBAL_OPTIONS,
  MatCommonModule,
  MatLine,
  MatLineModule,
  MatNativeDateModule,
  MatOption,
  MatRipple,
  MatRippleModule,
  RippleRenderer,
  mixinColor,
  mixinDisableRipple,
  mixinDisabled,
  mixinErrorState,
  mixinInitialized,
  mixinTabIndex,
  setLines
} from "./chunk-W44CVE2C.js";
import "./chunk-MOG4W3H2.js";
import {
  DomSanitizer
} from "./chunk-EN6UKMBD.js";
import {
  animate,
  animateChild,
  group,
  keyframes,
  query,
  state,
  style,
  transition,
  trigger
} from "./chunk-JJ4ENG2O.js";
import {
  A11yModule,
  AriaDescriber,
  CdkMonitorFocus,
  CdkObserveContent,
  FocusKeyManager,
  FocusMonitor,
  FocusTrapFactory,
  InteractivityChecker,
  LiveAnnouncer,
  ObserversModule
} from "./chunk-3TJ5ECJH.js";
import {
  BACKSPACE,
  BidiModule,
  DELETE,
  DOWN_ARROW,
  Directionality,
  END,
  ENTER,
  ESCAPE,
  HOME,
  LEFT_ARROW,
  PAGE_DOWN,
  PAGE_UP,
  Platform,
  RIGHT_ARROW,
  SPACE,
  TAB,
  UP_ARROW,
  _getFocusedElementPierceShadowDom,
  coerceArray,
  coerceBooleanProperty,
  coerceNumberProperty,
  hasModifierKey,
  normalizePassiveListenerOptions
} from "./chunk-IQOLSN34.js";
import "./chunk-CX66FAB7.js";
import {
  AsyncPipe,
  CommonModule,
  DOCUMENT,
  DatePipe,
  NgClass,
  NgForOf,
  NgIf,
  NgStyle,
  NgSwitch,
  NgSwitchCase,
  NgSwitchDefault,
  NgTemplateOutlet
} from "./chunk-SJMBSDCY.js";
import {
  ANIMATION_MODULE_TYPE,
  Attribute,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ComponentFactoryResolver$1,
  ContentChild,
  ContentChildren,
  Directive,
  ElementRef,
  EventEmitter,
  Host,
  Inject,
  InjectFlags,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  IterableDiffers,
  NgModule,
  NgZone,
  Optional,
  Output,
  Pipe,
  QueryList,
  Self,
  SkipSelf,
  TemplateRef,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  ViewEncapsulation$1,
  forwardRef,
  setClassMetadata,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassMapInterpolate1,
  ɵɵclassProp,
  ɵɵcontentQuery,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵhostProperty,
  ɵɵinject,
  ɵɵinjectAttribute,
  ɵɵinvalidFactory,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnamespaceHTML,
  ɵɵnamespaceSVG,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpropertyInterpolate,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵqueryRefresh,
  ɵɵreference,
  ɵɵresetView,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵsanitizeUrl,
  ɵɵstyleProp,
  ɵɵsyntheticHostListener,
  ɵɵsyntheticHostProperty,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery
} from "./chunk-GMUXDIJ2.js";
import {
  fromEvent,
  isObservable,
  merge
} from "./chunk-TQO6VFQJ.js";
import "./chunk-EE23643A.js";
import {
  BehaviorSubject,
  EMPTY,
  Observable,
  Subject,
  Subscription,
  combineLatest,
  concat,
  debounceTime,
  distinctUntilChanged,
  filter,
  map,
  of,
  skip,
  startWith,
  switchMap,
  take,
  takeUntil,
  timer
} from "./chunk-ODTHBFDQ.js";
import "./chunk-YTN62GH5.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-3OV72XIM.js";

// node_modules/@angular/cdk/fesm2020/layout.mjs
var LayoutModule = class {
};
LayoutModule.ɵfac = function LayoutModule_Factory(ɵt) {
  return new (ɵt || LayoutModule)();
};
LayoutModule.ɵmod = ɵɵdefineNgModule({
  type: LayoutModule
});
LayoutModule.ɵinj = ɵɵdefineInjector({});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LayoutModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();
var mediaQueriesForWebkitCompatibility = /* @__PURE__ */ new Set();
var mediaQueryStyleNode;
var MediaMatcher = class {
  constructor(_platform) {
    this._platform = _platform;
    this._matchMedia = this._platform.isBrowser && window.matchMedia ? (
      // matchMedia is bound to the window scope intentionally as it is an illegal invocation to
      // call it from a different scope.
      window.matchMedia.bind(window)
    ) : noopMatchMedia;
  }
  /**
   * Evaluates the given media query and returns the native MediaQueryList from which results
   * can be retrieved.
   * Confirms the layout engine will trigger for the selector query provided and returns the
   * MediaQueryList for the query provided.
   */
  matchMedia(query2) {
    if (this._platform.WEBKIT || this._platform.BLINK) {
      createEmptyStyleRule(query2);
    }
    return this._matchMedia(query2);
  }
};
MediaMatcher.ɵfac = function MediaMatcher_Factory(ɵt) {
  return new (ɵt || MediaMatcher)(ɵɵinject(Platform));
};
MediaMatcher.ɵprov = ɵɵdefineInjectable({
  token: MediaMatcher,
  factory: MediaMatcher.ɵfac,
  providedIn: "root"
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MediaMatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: Platform
    }];
  }, null);
})();
function createEmptyStyleRule(query2) {
  if (mediaQueriesForWebkitCompatibility.has(query2)) {
    return;
  }
  try {
    if (!mediaQueryStyleNode) {
      mediaQueryStyleNode = document.createElement("style");
      mediaQueryStyleNode.setAttribute("type", "text/css");
      document.head.appendChild(mediaQueryStyleNode);
    }
    if (mediaQueryStyleNode.sheet) {
      mediaQueryStyleNode.sheet.insertRule(`@media ${query2} {body{ }}`, 0);
      mediaQueriesForWebkitCompatibility.add(query2);
    }
  } catch (e) {
    console.error(e);
  }
}
function noopMatchMedia(query2) {
  return {
    matches: query2 === "all" || query2 === "",
    media: query2,
    addListener: () => {
    },
    removeListener: () => {
    }
  };
}
var BreakpointObserver = class {
  constructor(_mediaMatcher, _zone) {
    this._mediaMatcher = _mediaMatcher;
    this._zone = _zone;
    this._queries = /* @__PURE__ */ new Map();
    this._destroySubject = new Subject();
  }
  /** Completes the active subject, signalling to all other observables to complete. */
  ngOnDestroy() {
    this._destroySubject.next();
    this._destroySubject.complete();
  }
  /**
   * Whether one or more media queries match the current viewport size.
   * @param value One or more media queries to check.
   * @returns Whether any of the media queries match.
   */
  isMatched(value) {
    const queries = splitQueries(coerceArray(value));
    return queries.some((mediaQuery) => this._registerQuery(mediaQuery).mql.matches);
  }
  /**
   * Gets an observable of results for the given queries that will emit new results for any changes
   * in matching of the given queries.
   * @param value One or more media queries to check.
   * @returns A stream of matches for the given queries.
   */
  observe(value) {
    const queries = splitQueries(coerceArray(value));
    const observables = queries.map((query2) => this._registerQuery(query2).observable);
    let stateObservable = combineLatest(observables);
    stateObservable = concat(stateObservable.pipe(take(1)), stateObservable.pipe(skip(1), debounceTime(0)));
    return stateObservable.pipe(map((breakpointStates) => {
      const response = {
        matches: false,
        breakpoints: {}
      };
      breakpointStates.forEach(({
        matches,
        query: query2
      }) => {
        response.matches = response.matches || matches;
        response.breakpoints[query2] = matches;
      });
      return response;
    }));
  }
  /** Registers a specific query to be listened for. */
  _registerQuery(query2) {
    if (this._queries.has(query2)) {
      return this._queries.get(query2);
    }
    const mql = this._mediaMatcher.matchMedia(query2);
    const queryObservable = new Observable((observer) => {
      const handler = (e) => this._zone.run(() => observer.next(e));
      mql.addListener(handler);
      return () => {
        mql.removeListener(handler);
      };
    }).pipe(startWith(mql), map(({
      matches
    }) => ({
      query: query2,
      matches
    })), takeUntil(this._destroySubject));
    const output = {
      observable: queryObservable,
      mql
    };
    this._queries.set(query2, output);
    return output;
  }
};
BreakpointObserver.ɵfac = function BreakpointObserver_Factory(ɵt) {
  return new (ɵt || BreakpointObserver)(ɵɵinject(MediaMatcher), ɵɵinject(NgZone));
};
BreakpointObserver.ɵprov = ɵɵdefineInjectable({
  token: BreakpointObserver,
  factory: BreakpointObserver.ɵfac,
  providedIn: "root"
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BreakpointObserver, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: MediaMatcher
    }, {
      type: NgZone
    }];
  }, null);
})();
function splitQueries(queries) {
  return queries.map((query2) => query2.split(",")).reduce((a1, a2) => a1.concat(a2)).map((query2) => query2.trim());
}
var Breakpoints = {
  XSmall: "(max-width: 599.98px)",
  Small: "(min-width: 600px) and (max-width: 959.98px)",
  Medium: "(min-width: 960px) and (max-width: 1279.98px)",
  Large: "(min-width: 1280px) and (max-width: 1919.98px)",
  XLarge: "(min-width: 1920px)",
  Handset: "(max-width: 599.98px) and (orientation: portrait), (max-width: 959.98px) and (orientation: landscape)",
  Tablet: "(min-width: 600px) and (max-width: 839.98px) and (orientation: portrait), (min-width: 960px) and (max-width: 1279.98px) and (orientation: landscape)",
  Web: "(min-width: 840px) and (orientation: portrait), (min-width: 1280px) and (orientation: landscape)",
  HandsetPortrait: "(max-width: 599.98px) and (orientation: portrait)",
  TabletPortrait: "(min-width: 600px) and (max-width: 839.98px) and (orientation: portrait)",
  WebPortrait: "(min-width: 840px) and (orientation: portrait)",
  HandsetLandscape: "(max-width: 959.98px) and (orientation: landscape)",
  TabletLandscape: "(min-width: 960px) and (max-width: 1279.98px) and (orientation: landscape)",
  WebLandscape: "(min-width: 1280px) and (orientation: landscape)"
};

// node_modules/@angular/material/fesm2020/tooltip.mjs
var _c0 = ["tooltip"];
var SCROLL_THROTTLE_MS = 20;
var PANEL_CLASS = "tooltip-panel";
var passiveListenerOptions = normalizePassiveListenerOptions({
  passive: true
});
var LONGPRESS_DELAY = 500;
function getMatTooltipInvalidPositionError(position) {
  return Error(`Tooltip position "${position}" is invalid.`);
}
var MAT_TOOLTIP_SCROLL_STRATEGY = new InjectionToken("mat-tooltip-scroll-strategy");
function MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY(overlay) {
  return () => overlay.scrollStrategies.reposition({
    scrollThrottle: SCROLL_THROTTLE_MS
  });
}
var MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER = {
  provide: MAT_TOOLTIP_SCROLL_STRATEGY,
  deps: [Overlay],
  useFactory: MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY
};
var MAT_TOOLTIP_DEFAULT_OPTIONS = new InjectionToken("mat-tooltip-default-options", {
  providedIn: "root",
  factory: MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY
});
function MAT_TOOLTIP_DEFAULT_OPTIONS_FACTORY() {
  return {
    showDelay: 0,
    hideDelay: 0,
    touchendHideDelay: 1500
  };
}
var _MatTooltipBase = class {
  constructor(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, _platform, _ariaDescriber, _focusMonitor, scrollStrategy, _dir, _defaultOptions, _document) {
    this._overlay = _overlay;
    this._elementRef = _elementRef;
    this._scrollDispatcher = _scrollDispatcher;
    this._viewContainerRef = _viewContainerRef;
    this._ngZone = _ngZone;
    this._platform = _platform;
    this._ariaDescriber = _ariaDescriber;
    this._focusMonitor = _focusMonitor;
    this._dir = _dir;
    this._defaultOptions = _defaultOptions;
    this._position = "below";
    this._disabled = false;
    this._viewInitialized = false;
    this._pointerExitEventsInitialized = false;
    this._viewportMargin = 8;
    this._cssClassPrefix = "mat";
    this._showDelay = this._defaultOptions.showDelay;
    this._hideDelay = this._defaultOptions.hideDelay;
    this.touchGestures = "auto";
    this._message = "";
    this._passiveListeners = [];
    this._destroyed = new Subject();
    this._scrollStrategy = scrollStrategy;
    this._document = _document;
    if (_defaultOptions) {
      if (_defaultOptions.position) {
        this.position = _defaultOptions.position;
      }
      if (_defaultOptions.touchGestures) {
        this.touchGestures = _defaultOptions.touchGestures;
      }
    }
    _dir.change.pipe(takeUntil(this._destroyed)).subscribe(() => {
      if (this._overlayRef) {
        this._updatePosition(this._overlayRef);
      }
    });
  }
  /** Allows the user to define the position of the tooltip relative to the parent element */
  get position() {
    return this._position;
  }
  set position(value) {
    if (value !== this._position) {
      this._position = value;
      if (this._overlayRef) {
        this._updatePosition(this._overlayRef);
        this._tooltipInstance?.show(0);
        this._overlayRef.updatePosition();
      }
    }
  }
  /** Disables the display of the tooltip. */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = coerceBooleanProperty(value);
    if (this._disabled) {
      this.hide(0);
    } else {
      this._setupPointerEnterEventsIfNeeded();
    }
  }
  /** The default delay in ms before showing the tooltip after show is called */
  get showDelay() {
    return this._showDelay;
  }
  set showDelay(value) {
    this._showDelay = coerceNumberProperty(value);
  }
  /** The default delay in ms before hiding the tooltip after hide is called */
  get hideDelay() {
    return this._hideDelay;
  }
  set hideDelay(value) {
    this._hideDelay = coerceNumberProperty(value);
    if (this._tooltipInstance) {
      this._tooltipInstance._mouseLeaveHideDelay = this._hideDelay;
    }
  }
  /** The message to be displayed in the tooltip */
  get message() {
    return this._message;
  }
  set message(value) {
    this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this._message, "tooltip");
    this._message = value != null ? String(value).trim() : "";
    if (!this._message && this._isTooltipVisible()) {
      this.hide(0);
    } else {
      this._setupPointerEnterEventsIfNeeded();
      this._updateTooltipMessage();
      this._ngZone.runOutsideAngular(() => {
        Promise.resolve().then(() => {
          this._ariaDescriber.describe(this._elementRef.nativeElement, this.message, "tooltip");
        });
      });
    }
  }
  /** Classes to be passed to the tooltip. Supports the same syntax as `ngClass`. */
  get tooltipClass() {
    return this._tooltipClass;
  }
  set tooltipClass(value) {
    this._tooltipClass = value;
    if (this._tooltipInstance) {
      this._setTooltipClass(this._tooltipClass);
    }
  }
  ngAfterViewInit() {
    this._viewInitialized = true;
    this._setupPointerEnterEventsIfNeeded();
    this._focusMonitor.monitor(this._elementRef).pipe(takeUntil(this._destroyed)).subscribe((origin) => {
      if (!origin) {
        this._ngZone.run(() => this.hide(0));
      } else if (origin === "keyboard") {
        this._ngZone.run(() => this.show());
      }
    });
  }
  /**
   * Dispose the tooltip when destroyed.
   */
  ngOnDestroy() {
    const nativeElement = this._elementRef.nativeElement;
    clearTimeout(this._touchstartTimeout);
    if (this._overlayRef) {
      this._overlayRef.dispose();
      this._tooltipInstance = null;
    }
    this._passiveListeners.forEach(([event, listener]) => {
      nativeElement.removeEventListener(event, listener, passiveListenerOptions);
    });
    this._passiveListeners.length = 0;
    this._destroyed.next();
    this._destroyed.complete();
    this._ariaDescriber.removeDescription(nativeElement, this.message, "tooltip");
    this._focusMonitor.stopMonitoring(nativeElement);
  }
  /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input */
  show(delay = this.showDelay) {
    if (this.disabled || !this.message || this._isTooltipVisible() && !this._tooltipInstance._showTimeoutId && !this._tooltipInstance._hideTimeoutId) {
      return;
    }
    const overlayRef = this._createOverlay();
    this._detach();
    this._portal = this._portal || new ComponentPortal(this._tooltipComponent, this._viewContainerRef);
    const instance = this._tooltipInstance = overlayRef.attach(this._portal).instance;
    instance._triggerElement = this._elementRef.nativeElement;
    instance._mouseLeaveHideDelay = this._hideDelay;
    instance.afterHidden().pipe(takeUntil(this._destroyed)).subscribe(() => this._detach());
    this._setTooltipClass(this._tooltipClass);
    this._updateTooltipMessage();
    instance.show(delay);
  }
  /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input */
  hide(delay = this.hideDelay) {
    if (this._tooltipInstance) {
      this._tooltipInstance.hide(delay);
    }
  }
  /** Shows/hides the tooltip */
  toggle() {
    this._isTooltipVisible() ? this.hide() : this.show();
  }
  /** Returns true if the tooltip is currently visible to the user */
  _isTooltipVisible() {
    return !!this._tooltipInstance && this._tooltipInstance.isVisible();
  }
  /** Create the overlay config and position strategy */
  _createOverlay() {
    if (this._overlayRef) {
      return this._overlayRef;
    }
    const scrollableAncestors = this._scrollDispatcher.getAncestorScrollContainers(this._elementRef);
    const strategy = this._overlay.position().flexibleConnectedTo(this._elementRef).withTransformOriginOn(`.${this._cssClassPrefix}-tooltip`).withFlexibleDimensions(false).withViewportMargin(this._viewportMargin).withScrollableContainers(scrollableAncestors);
    strategy.positionChanges.pipe(takeUntil(this._destroyed)).subscribe((change) => {
      this._updateCurrentPositionClass(change.connectionPair);
      if (this._tooltipInstance) {
        if (change.scrollableViewProperties.isOverlayClipped && this._tooltipInstance.isVisible()) {
          this._ngZone.run(() => this.hide(0));
        }
      }
    });
    this._overlayRef = this._overlay.create({
      direction: this._dir,
      positionStrategy: strategy,
      panelClass: `${this._cssClassPrefix}-${PANEL_CLASS}`,
      scrollStrategy: this._scrollStrategy()
    });
    this._updatePosition(this._overlayRef);
    this._overlayRef.detachments().pipe(takeUntil(this._destroyed)).subscribe(() => this._detach());
    this._overlayRef.outsidePointerEvents().pipe(takeUntil(this._destroyed)).subscribe(() => this._tooltipInstance?._handleBodyInteraction());
    this._overlayRef.keydownEvents().pipe(takeUntil(this._destroyed)).subscribe((event) => {
      if (this._isTooltipVisible() && event.keyCode === ESCAPE && !hasModifierKey(event)) {
        event.preventDefault();
        event.stopPropagation();
        this._ngZone.run(() => this.hide(0));
      }
    });
    if (this._defaultOptions?.disableTooltipInteractivity) {
      this._overlayRef.addPanelClass(`${this._cssClassPrefix}-tooltip-panel-non-interactive`);
    }
    return this._overlayRef;
  }
  /** Detaches the currently-attached tooltip. */
  _detach() {
    if (this._overlayRef && this._overlayRef.hasAttached()) {
      this._overlayRef.detach();
    }
    this._tooltipInstance = null;
  }
  /** Updates the position of the current tooltip. */
  _updatePosition(overlayRef) {
    const position = overlayRef.getConfig().positionStrategy;
    const origin = this._getOrigin();
    const overlay = this._getOverlayPosition();
    position.withPositions([this._addOffset(__spreadValues(__spreadValues({}, origin.main), overlay.main)), this._addOffset(__spreadValues(__spreadValues({}, origin.fallback), overlay.fallback))]);
  }
  /** Adds the configured offset to a position. Used as a hook for child classes. */
  _addOffset(position) {
    return position;
  }
  /**
   * Returns the origin position and a fallback position based on the user's position preference.
   * The fallback position is the inverse of the origin (e.g. `'below' -> 'above'`).
   */
  _getOrigin() {
    const isLtr = !this._dir || this._dir.value == "ltr";
    const position = this.position;
    let originPosition;
    if (position == "above" || position == "below") {
      originPosition = {
        originX: "center",
        originY: position == "above" ? "top" : "bottom"
      };
    } else if (position == "before" || position == "left" && isLtr || position == "right" && !isLtr) {
      originPosition = {
        originX: "start",
        originY: "center"
      };
    } else if (position == "after" || position == "right" && isLtr || position == "left" && !isLtr) {
      originPosition = {
        originX: "end",
        originY: "center"
      };
    } else if (typeof ngDevMode === "undefined" || ngDevMode) {
      throw getMatTooltipInvalidPositionError(position);
    }
    const {
      x,
      y
    } = this._invertPosition(originPosition.originX, originPosition.originY);
    return {
      main: originPosition,
      fallback: {
        originX: x,
        originY: y
      }
    };
  }
  /** Returns the overlay position and a fallback position based on the user's preference */
  _getOverlayPosition() {
    const isLtr = !this._dir || this._dir.value == "ltr";
    const position = this.position;
    let overlayPosition;
    if (position == "above") {
      overlayPosition = {
        overlayX: "center",
        overlayY: "bottom"
      };
    } else if (position == "below") {
      overlayPosition = {
        overlayX: "center",
        overlayY: "top"
      };
    } else if (position == "before" || position == "left" && isLtr || position == "right" && !isLtr) {
      overlayPosition = {
        overlayX: "end",
        overlayY: "center"
      };
    } else if (position == "after" || position == "right" && isLtr || position == "left" && !isLtr) {
      overlayPosition = {
        overlayX: "start",
        overlayY: "center"
      };
    } else if (typeof ngDevMode === "undefined" || ngDevMode) {
      throw getMatTooltipInvalidPositionError(position);
    }
    const {
      x,
      y
    } = this._invertPosition(overlayPosition.overlayX, overlayPosition.overlayY);
    return {
      main: overlayPosition,
      fallback: {
        overlayX: x,
        overlayY: y
      }
    };
  }
  /** Updates the tooltip message and repositions the overlay according to the new message length */
  _updateTooltipMessage() {
    if (this._tooltipInstance) {
      this._tooltipInstance.message = this.message;
      this._tooltipInstance._markForCheck();
      this._ngZone.onMicrotaskEmpty.pipe(take(1), takeUntil(this._destroyed)).subscribe(() => {
        if (this._tooltipInstance) {
          this._overlayRef.updatePosition();
        }
      });
    }
  }
  /** Updates the tooltip class */
  _setTooltipClass(tooltipClass) {
    if (this._tooltipInstance) {
      this._tooltipInstance.tooltipClass = tooltipClass;
      this._tooltipInstance._markForCheck();
    }
  }
  /** Inverts an overlay position. */
  _invertPosition(x, y) {
    if (this.position === "above" || this.position === "below") {
      if (y === "top") {
        y = "bottom";
      } else if (y === "bottom") {
        y = "top";
      }
    } else {
      if (x === "end") {
        x = "start";
      } else if (x === "start") {
        x = "end";
      }
    }
    return {
      x,
      y
    };
  }
  /** Updates the class on the overlay panel based on the current position of the tooltip. */
  _updateCurrentPositionClass(connectionPair) {
    const {
      overlayY,
      originX,
      originY
    } = connectionPair;
    let newPosition;
    if (overlayY === "center") {
      if (this._dir && this._dir.value === "rtl") {
        newPosition = originX === "end" ? "left" : "right";
      } else {
        newPosition = originX === "start" ? "left" : "right";
      }
    } else {
      newPosition = overlayY === "bottom" && originY === "top" ? "above" : "below";
    }
    if (newPosition !== this._currentPosition) {
      const overlayRef = this._overlayRef;
      if (overlayRef) {
        const classPrefix = `${this._cssClassPrefix}-${PANEL_CLASS}-`;
        overlayRef.removePanelClass(classPrefix + this._currentPosition);
        overlayRef.addPanelClass(classPrefix + newPosition);
      }
      this._currentPosition = newPosition;
    }
  }
  /** Binds the pointer events to the tooltip trigger. */
  _setupPointerEnterEventsIfNeeded() {
    if (this._disabled || !this.message || !this._viewInitialized || this._passiveListeners.length) {
      return;
    }
    if (this._platformSupportsMouseEvents()) {
      this._passiveListeners.push(["mouseenter", () => {
        this._setupPointerExitEventsIfNeeded();
        this.show();
      }]);
    } else if (this.touchGestures !== "off") {
      this._disableNativeGesturesIfNecessary();
      this._passiveListeners.push(["touchstart", () => {
        this._setupPointerExitEventsIfNeeded();
        clearTimeout(this._touchstartTimeout);
        this._touchstartTimeout = setTimeout(() => this.show(), LONGPRESS_DELAY);
      }]);
    }
    this._addListeners(this._passiveListeners);
  }
  _setupPointerExitEventsIfNeeded() {
    if (this._pointerExitEventsInitialized) {
      return;
    }
    this._pointerExitEventsInitialized = true;
    const exitListeners = [];
    if (this._platformSupportsMouseEvents()) {
      exitListeners.push(["mouseleave", (event) => {
        const newTarget = event.relatedTarget;
        if (!newTarget || !this._overlayRef?.overlayElement.contains(newTarget)) {
          this.hide();
        }
      }], ["wheel", (event) => this._wheelListener(event)]);
    } else if (this.touchGestures !== "off") {
      this._disableNativeGesturesIfNecessary();
      const touchendListener = () => {
        clearTimeout(this._touchstartTimeout);
        this.hide(this._defaultOptions.touchendHideDelay);
      };
      exitListeners.push(["touchend", touchendListener], ["touchcancel", touchendListener]);
    }
    this._addListeners(exitListeners);
    this._passiveListeners.push(...exitListeners);
  }
  _addListeners(listeners) {
    listeners.forEach(([event, listener]) => {
      this._elementRef.nativeElement.addEventListener(event, listener, passiveListenerOptions);
    });
  }
  _platformSupportsMouseEvents() {
    return !this._platform.IOS && !this._platform.ANDROID;
  }
  /** Listener for the `wheel` event on the element. */
  _wheelListener(event) {
    if (this._isTooltipVisible()) {
      const elementUnderPointer = this._document.elementFromPoint(event.clientX, event.clientY);
      const element = this._elementRef.nativeElement;
      if (elementUnderPointer !== element && !element.contains(elementUnderPointer)) {
        this.hide();
      }
    }
  }
  /** Disables the native browser gestures, based on how the tooltip has been configured. */
  _disableNativeGesturesIfNecessary() {
    const gestures = this.touchGestures;
    if (gestures !== "off") {
      const element = this._elementRef.nativeElement;
      const style2 = element.style;
      if (gestures === "on" || element.nodeName !== "INPUT" && element.nodeName !== "TEXTAREA") {
        style2.userSelect = style2.msUserSelect = style2.webkitUserSelect = style2.MozUserSelect = "none";
      }
      if (gestures === "on" || !element.draggable) {
        style2.webkitUserDrag = "none";
      }
      style2.touchAction = "none";
      style2.webkitTapHighlightColor = "transparent";
    }
  }
};
_MatTooltipBase.ɵfac = function _MatTooltipBase_Factory(ɵt) {
  ɵɵinvalidFactory();
};
_MatTooltipBase.ɵdir = ɵɵdefineDirective({
  type: _MatTooltipBase,
  inputs: {
    position: [0, "matTooltipPosition", "position"],
    disabled: [0, "matTooltipDisabled", "disabled"],
    showDelay: [0, "matTooltipShowDelay", "showDelay"],
    hideDelay: [0, "matTooltipHideDelay", "hideDelay"],
    touchGestures: [0, "matTooltipTouchGestures", "touchGestures"],
    message: [0, "matTooltip", "message"],
    tooltipClass: [0, "matTooltipClass", "tooltipClass"]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_MatTooltipBase, [{
    type: Directive
  }], function() {
    return [{
      type: Overlay
    }, {
      type: ElementRef
    }, {
      type: ScrollDispatcher
    }, {
      type: ViewContainerRef
    }, {
      type: NgZone
    }, {
      type: Platform
    }, {
      type: AriaDescriber
    }, {
      type: FocusMonitor
    }, {
      type: void 0
    }, {
      type: Directionality
    }, {
      type: void 0
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, {
    position: [{
      type: Input,
      args: ["matTooltipPosition"]
    }],
    disabled: [{
      type: Input,
      args: ["matTooltipDisabled"]
    }],
    showDelay: [{
      type: Input,
      args: ["matTooltipShowDelay"]
    }],
    hideDelay: [{
      type: Input,
      args: ["matTooltipHideDelay"]
    }],
    touchGestures: [{
      type: Input,
      args: ["matTooltipTouchGestures"]
    }],
    message: [{
      type: Input,
      args: ["matTooltip"]
    }],
    tooltipClass: [{
      type: Input,
      args: ["matTooltipClass"]
    }]
  });
})();
var MatTooltip = class extends _MatTooltipBase {
  constructor(overlay, elementRef, scrollDispatcher, viewContainerRef, ngZone, platform, ariaDescriber, focusMonitor, scrollStrategy, dir, defaultOptions, _document) {
    super(overlay, elementRef, scrollDispatcher, viewContainerRef, ngZone, platform, ariaDescriber, focusMonitor, scrollStrategy, dir, defaultOptions, _document);
    this._tooltipComponent = TooltipComponent;
  }
};
MatTooltip.ɵfac = function MatTooltip_Factory(ɵt) {
  return new (ɵt || MatTooltip)(ɵɵdirectiveInject(Overlay), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ScrollDispatcher), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Platform), ɵɵdirectiveInject(AriaDescriber), ɵɵdirectiveInject(FocusMonitor), ɵɵdirectiveInject(MAT_TOOLTIP_SCROLL_STRATEGY), ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(MAT_TOOLTIP_DEFAULT_OPTIONS, 8), ɵɵdirectiveInject(DOCUMENT));
};
MatTooltip.ɵdir = ɵɵdefineDirective({
  type: MatTooltip,
  selectors: [["", "matTooltip", ""]],
  hostAttrs: [1, "mat-tooltip-trigger"],
  exportAs: ["matTooltip"],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTooltip, [{
    type: Directive,
    args: [{
      selector: "[matTooltip]",
      exportAs: "matTooltip",
      host: {
        "class": "mat-tooltip-trigger"
      }
    }]
  }], function() {
    return [{
      type: Overlay
    }, {
      type: ElementRef
    }, {
      type: ScrollDispatcher
    }, {
      type: ViewContainerRef
    }, {
      type: NgZone
    }, {
      type: Platform
    }, {
      type: AriaDescriber
    }, {
      type: FocusMonitor
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [MAT_TOOLTIP_SCROLL_STRATEGY]
      }]
    }, {
      type: Directionality,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [MAT_TOOLTIP_DEFAULT_OPTIONS]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, null);
})();
var _TooltipComponentBase = class {
  constructor(_changeDetectorRef, animationMode) {
    this._changeDetectorRef = _changeDetectorRef;
    this._visibility = "initial";
    this._closeOnInteraction = false;
    this._isVisible = false;
    this._onHide = new Subject();
    this._animationsDisabled = animationMode === "NoopAnimations";
  }
  /**
   * Shows the tooltip with an animation originating from the provided origin
   * @param delay Amount of milliseconds to the delay showing the tooltip.
   */
  show(delay) {
    clearTimeout(this._hideTimeoutId);
    this._showTimeoutId = setTimeout(() => {
      this._toggleVisibility(true);
      this._showTimeoutId = void 0;
    }, delay);
  }
  /**
   * Begins the animation to hide the tooltip after the provided delay in ms.
   * @param delay Amount of milliseconds to delay showing the tooltip.
   */
  hide(delay) {
    clearTimeout(this._showTimeoutId);
    this._hideTimeoutId = setTimeout(() => {
      this._toggleVisibility(false);
      this._hideTimeoutId = void 0;
    }, delay);
  }
  /** Returns an observable that notifies when the tooltip has been hidden from view. */
  afterHidden() {
    return this._onHide;
  }
  /** Whether the tooltip is being displayed. */
  isVisible() {
    return this._isVisible;
  }
  ngOnDestroy() {
    clearTimeout(this._showTimeoutId);
    clearTimeout(this._hideTimeoutId);
    this._onHide.complete();
    this._triggerElement = null;
  }
  /**
   * Interactions on the HTML body should close the tooltip immediately as defined in the
   * material design spec.
   * https://material.io/design/components/tooltips.html#behavior
   */
  _handleBodyInteraction() {
    if (this._closeOnInteraction) {
      this.hide(0);
    }
  }
  /**
   * Marks that the tooltip needs to be checked in the next change detection run.
   * Mainly used for rendering the initial text before positioning a tooltip, which
   * can be problematic in components with OnPush change detection.
   */
  _markForCheck() {
    this._changeDetectorRef.markForCheck();
  }
  _handleMouseLeave({
    relatedTarget
  }) {
    if (!relatedTarget || !this._triggerElement.contains(relatedTarget)) {
      this.hide(this._mouseLeaveHideDelay);
    }
  }
  /**
   * Callback for when the timeout in this.show() gets completed.
   * This method is only needed by the mdc-tooltip, and so it is only implemented
   * in the mdc-tooltip, not here.
   */
  _onShow() {
  }
  /** Event listener dispatched when an animation on the tooltip finishes. */
  _handleAnimationEnd({
    animationName
  }) {
    if (animationName === this._showAnimation || animationName === this._hideAnimation) {
      this._finalizeAnimation(animationName === this._showAnimation);
    }
  }
  /** Handles the cleanup after an animation has finished. */
  _finalizeAnimation(toVisible) {
    if (toVisible) {
      this._closeOnInteraction = true;
    } else if (!this.isVisible()) {
      this._onHide.next();
    }
  }
  /** Toggles the visibility of the tooltip element. */
  _toggleVisibility(isVisible) {
    const tooltip = this._tooltip.nativeElement;
    const showClass = this._showAnimation;
    const hideClass = this._hideAnimation;
    tooltip.classList.remove(isVisible ? hideClass : showClass);
    tooltip.classList.add(isVisible ? showClass : hideClass);
    this._isVisible = isVisible;
    if (isVisible && !this._animationsDisabled && typeof getComputedStyle === "function") {
      const styles = getComputedStyle(tooltip);
      if (styles.getPropertyValue("animation-duration") === "0s" || styles.getPropertyValue("animation-name") === "none") {
        this._animationsDisabled = true;
      }
    }
    if (isVisible) {
      this._onShow();
    }
    if (this._animationsDisabled) {
      tooltip.classList.add("_mat-animation-noopable");
      this._finalizeAnimation(isVisible);
    }
  }
};
_TooltipComponentBase.ɵfac = function _TooltipComponentBase_Factory(ɵt) {
  return new (ɵt || _TooltipComponentBase)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8));
};
_TooltipComponentBase.ɵdir = ɵɵdefineDirective({
  type: _TooltipComponentBase
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_TooltipComponentBase, [{
    type: Directive
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [ANIMATION_MODULE_TYPE]
      }]
    }];
  }, null);
})();
var TooltipComponent = class extends _TooltipComponentBase {
  constructor(changeDetectorRef, _breakpointObserver, animationMode) {
    super(changeDetectorRef, animationMode);
    this._breakpointObserver = _breakpointObserver;
    this._isHandset = this._breakpointObserver.observe(Breakpoints.Handset);
    this._showAnimation = "mat-tooltip-show";
    this._hideAnimation = "mat-tooltip-hide";
  }
};
TooltipComponent.ɵfac = function TooltipComponent_Factory(ɵt) {
  return new (ɵt || TooltipComponent)(ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(BreakpointObserver), ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8));
};
TooltipComponent.ɵcmp = ɵɵdefineComponent({
  type: TooltipComponent,
  selectors: [["mat-tooltip-component"]],
  viewQuery: function TooltipComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c0, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._tooltip = _t.first);
    }
  },
  hostAttrs: ["aria-hidden", "true"],
  hostVars: 2,
  hostBindings: function TooltipComponent_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("mouseleave", function TooltipComponent_mouseleave_HostBindingHandler($event) {
        return ctx._handleMouseLeave($event);
      });
    }
    if (rf & 2) {
      ɵɵstyleProp("zoom", ctx.isVisible() ? 1 : null);
    }
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 4,
  vars: 6,
  consts: [["tooltip", ""], [1, "mat-tooltip", 3, "animationend", "ngClass"]],
  template: function TooltipComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "div", 1, 0);
      ɵɵpipe(2, "async");
      ɵɵlistener("animationend", function TooltipComponent_Template_div_animationend_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._handleAnimationEnd($event));
      });
      ɵɵtext(3);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      let tmp_1_0;
      ɵɵclassProp("mat-tooltip-handset", (tmp_1_0 = ɵɵpipeBind1(2, 4, ctx._isHandset)) == null ? null : tmp_1_0.matches);
      ɵɵproperty("ngClass", ctx.tooltipClass);
      ɵɵadvance(3);
      ɵɵtextInterpolate(ctx.message);
    }
  },
  dependencies: [NgClass, AsyncPipe],
  styles: [".mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis;transform:scale(0)}.mat-tooltip._mat-animation-noopable{animation:none;transform:scale(1)}.cdk-high-contrast-active .mat-tooltip{outline:solid 1px}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}.mat-tooltip-panel-non-interactive{pointer-events:none}@keyframes mat-tooltip-show{0%{opacity:0;transform:scale(0)}50%{opacity:.5;transform:scale(0.99)}100%{opacity:1;transform:scale(1)}}@keyframes mat-tooltip-hide{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(1)}}.mat-tooltip-show{animation:mat-tooltip-show 200ms cubic-bezier(0, 0, 0.2, 1) forwards}.mat-tooltip-hide{animation:mat-tooltip-hide 100ms cubic-bezier(0, 0, 0.2, 1) forwards}\n"],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TooltipComponent, [{
    type: Component,
    args: [{
      selector: "mat-tooltip-component",
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        // Forces the element to have a layout in IE and Edge. This fixes issues where the element
        // won't be rendered if the animations are disabled or there is no web animations polyfill.
        "[style.zoom]": "isVisible() ? 1 : null",
        "(mouseleave)": "_handleMouseLeave($event)",
        "aria-hidden": "true"
      },
      template: '<div #tooltip\n     class="mat-tooltip"\n     (animationend)="_handleAnimationEnd($event)"\n     [ngClass]="tooltipClass"\n     [class.mat-tooltip-handset]="(_isHandset | async)?.matches">{{message}}</div>\n',
      styles: [".mat-tooltip{color:#fff;border-radius:4px;margin:14px;max-width:250px;padding-left:8px;padding-right:8px;overflow:hidden;text-overflow:ellipsis;transform:scale(0)}.mat-tooltip._mat-animation-noopable{animation:none;transform:scale(1)}.cdk-high-contrast-active .mat-tooltip{outline:solid 1px}.mat-tooltip-handset{margin:24px;padding-left:16px;padding-right:16px}.mat-tooltip-panel-non-interactive{pointer-events:none}@keyframes mat-tooltip-show{0%{opacity:0;transform:scale(0)}50%{opacity:.5;transform:scale(0.99)}100%{opacity:1;transform:scale(1)}}@keyframes mat-tooltip-hide{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(1)}}.mat-tooltip-show{animation:mat-tooltip-show 200ms cubic-bezier(0, 0, 0.2, 1) forwards}.mat-tooltip-hide{animation:mat-tooltip-hide 100ms cubic-bezier(0, 0, 0.2, 1) forwards}\n"]
    }]
  }], function() {
    return [{
      type: ChangeDetectorRef
    }, {
      type: BreakpointObserver
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [ANIMATION_MODULE_TYPE]
      }]
    }];
  }, {
    _tooltip: [{
      type: ViewChild,
      args: ["tooltip", {
        // Use a static query here since we interact directly with
        // the DOM which can happen before `ngAfterViewInit`.
        static: true
      }]
    }]
  });
})();
var MatTooltipModule = class {
};
MatTooltipModule.ɵfac = function MatTooltipModule_Factory(ɵt) {
  return new (ɵt || MatTooltipModule)();
};
MatTooltipModule.ɵmod = ɵɵdefineNgModule({
  type: MatTooltipModule,
  declarations: [MatTooltip, TooltipComponent],
  imports: [A11yModule, CommonModule, OverlayModule, MatCommonModule],
  exports: [MatTooltip, TooltipComponent, MatCommonModule, CdkScrollableModule]
});
MatTooltipModule.ɵinj = ɵɵdefineInjector({
  providers: [MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER],
  imports: [[A11yModule, CommonModule, OverlayModule, MatCommonModule], MatCommonModule, CdkScrollableModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTooltipModule, [{
    type: NgModule,
    args: [{
      imports: [A11yModule, CommonModule, OverlayModule, MatCommonModule],
      exports: [MatTooltip, TooltipComponent, MatCommonModule, CdkScrollableModule],
      declarations: [MatTooltip, TooltipComponent],
      providers: [MAT_TOOLTIP_SCROLL_STRATEGY_FACTORY_PROVIDER]
    }]
  }], null, null);
})();
var matTooltipAnimations = {
  /** Animation that transitions a tooltip in and out. */
  tooltipState: trigger("state", [state("initial, void, hidden", style({
    opacity: 0,
    transform: "scale(0)"
  })), state("visible", style({
    transform: "scale(1)"
  })), transition("* => visible", animate("200ms cubic-bezier(0, 0, 0.2, 1)", keyframes([style({
    opacity: 0,
    transform: "scale(0)",
    offset: 0
  }), style({
    opacity: 0.5,
    transform: "scale(0.99)",
    offset: 0.5
  }), style({
    opacity: 1,
    transform: "scale(1)",
    offset: 1
  })]))), transition("* => hidden", animate("100ms cubic-bezier(0, 0, 0.2, 1)", style({
    opacity: 0
  })))])
};

// node_modules/@angular/material/fesm2020/paginator.mjs
function MatPaginator_div_2_mat_form_field_3_mat_option_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-option", 19);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const pageSizeOption_r3 = ctx.$implicit;
    ɵɵproperty("value", pageSizeOption_r3);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", pageSizeOption_r3, " ");
  }
}
function MatPaginator_div_2_mat_form_field_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-form-field", 16)(1, "mat-select", 17);
    ɵɵlistener("selectionChange", function MatPaginator_div_2_mat_form_field_3_Template_mat_select_selectionChange_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1._changePageSize($event.value));
    });
    ɵɵtemplate(2, MatPaginator_div_2_mat_form_field_3_mat_option_2_Template, 2, 2, "mat-option", 18);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵproperty("appearance", ctx_r1._formFieldAppearance)("color", ctx_r1.color);
    ɵɵadvance();
    ɵɵproperty("value", ctx_r1.pageSize)("disabled", ctx_r1.disabled)("aria-label", ctx_r1._intl.itemsPerPageLabel);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1._displayedPageSizeOptions);
  }
}
function MatPaginator_div_2_div_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 20);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r1.pageSize);
  }
}
function MatPaginator_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 12)(1, "div", 13);
    ɵɵtext(2);
    ɵɵelementEnd();
    ɵɵtemplate(3, MatPaginator_div_2_mat_form_field_3_Template, 3, 6, "mat-form-field", 14)(4, MatPaginator_div_2_div_4_Template, 2, 1, "div", 15);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ctx_r1._intl.itemsPerPageLabel, " ");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1._displayedPageSizeOptions.length > 1);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1._displayedPageSizeOptions.length <= 1);
  }
}
function MatPaginator_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 21);
    ɵɵlistener("click", function MatPaginator_button_6_Template_button_click_0_listener() {
      ɵɵrestoreView(_r4);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.firstPage());
    });
    ɵɵnamespaceSVG();
    ɵɵelementStart(1, "svg", 7);
    ɵɵelement(2, "path", 22);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("matTooltip", ctx_r1._intl.firstPageLabel)("matTooltipDisabled", ctx_r1._previousButtonsDisabled())("matTooltipPosition", "above")("disabled", ctx_r1._previousButtonsDisabled());
    ɵɵattribute("aria-label", ctx_r1._intl.firstPageLabel);
  }
}
function MatPaginator_button_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 23);
    ɵɵlistener("click", function MatPaginator_button_13_Template_button_click_0_listener() {
      ɵɵrestoreView(_r5);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.lastPage());
    });
    ɵɵnamespaceSVG();
    ɵɵelementStart(1, "svg", 7);
    ɵɵelement(2, "path", 24);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("matTooltip", ctx_r1._intl.lastPageLabel)("matTooltipDisabled", ctx_r1._nextButtonsDisabled())("matTooltipPosition", "above")("disabled", ctx_r1._nextButtonsDisabled());
    ɵɵattribute("aria-label", ctx_r1._intl.lastPageLabel);
  }
}
var MatPaginatorIntl = class {
  constructor() {
    this.changes = new Subject();
    this.itemsPerPageLabel = "Items per page:";
    this.nextPageLabel = "Next page";
    this.previousPageLabel = "Previous page";
    this.firstPageLabel = "First page";
    this.lastPageLabel = "Last page";
    this.getRangeLabel = (page, pageSize, length) => {
      if (length == 0 || pageSize == 0) {
        return `0 of ${length}`;
      }
      length = Math.max(length, 0);
      const startIndex = page * pageSize;
      const endIndex = startIndex < length ? Math.min(startIndex + pageSize, length) : startIndex + pageSize;
      return `${startIndex + 1} – ${endIndex} of ${length}`;
    };
  }
};
MatPaginatorIntl.ɵfac = function MatPaginatorIntl_Factory(ɵt) {
  return new (ɵt || MatPaginatorIntl)();
};
MatPaginatorIntl.ɵprov = ɵɵdefineInjectable({
  token: MatPaginatorIntl,
  factory: MatPaginatorIntl.ɵfac,
  providedIn: "root"
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatPaginatorIntl, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function MAT_PAGINATOR_INTL_PROVIDER_FACTORY(parentIntl) {
  return parentIntl || new MatPaginatorIntl();
}
var MAT_PAGINATOR_INTL_PROVIDER = {
  // If there is already an MatPaginatorIntl available, use that. Otherwise, provide a new one.
  provide: MatPaginatorIntl,
  deps: [[new Optional(), new SkipSelf(), MatPaginatorIntl]],
  useFactory: MAT_PAGINATOR_INTL_PROVIDER_FACTORY
};
var DEFAULT_PAGE_SIZE = 50;
var MAT_PAGINATOR_DEFAULT_OPTIONS = new InjectionToken("MAT_PAGINATOR_DEFAULT_OPTIONS");
var _MatPaginatorMixinBase = mixinDisabled(mixinInitialized(class {
}));
var _MatPaginatorBase = class extends _MatPaginatorMixinBase {
  constructor(_intl, _changeDetectorRef, defaults) {
    super();
    this._intl = _intl;
    this._changeDetectorRef = _changeDetectorRef;
    this._pageIndex = 0;
    this._length = 0;
    this._pageSizeOptions = [];
    this._hidePageSize = false;
    this._showFirstLastButtons = false;
    this.page = new EventEmitter();
    this._intlChanges = _intl.changes.subscribe(() => this._changeDetectorRef.markForCheck());
    if (defaults) {
      const {
        pageSize,
        pageSizeOptions,
        hidePageSize,
        showFirstLastButtons
      } = defaults;
      if (pageSize != null) {
        this._pageSize = pageSize;
      }
      if (pageSizeOptions != null) {
        this._pageSizeOptions = pageSizeOptions;
      }
      if (hidePageSize != null) {
        this._hidePageSize = hidePageSize;
      }
      if (showFirstLastButtons != null) {
        this._showFirstLastButtons = showFirstLastButtons;
      }
    }
  }
  /** The zero-based page index of the displayed list of items. Defaulted to 0. */
  get pageIndex() {
    return this._pageIndex;
  }
  set pageIndex(value) {
    this._pageIndex = Math.max(coerceNumberProperty(value), 0);
    this._changeDetectorRef.markForCheck();
  }
  /** The length of the total number of items that are being paginated. Defaulted to 0. */
  get length() {
    return this._length;
  }
  set length(value) {
    this._length = coerceNumberProperty(value);
    this._changeDetectorRef.markForCheck();
  }
  /** Number of items to display on a page. By default set to 50. */
  get pageSize() {
    return this._pageSize;
  }
  set pageSize(value) {
    this._pageSize = Math.max(coerceNumberProperty(value), 0);
    this._updateDisplayedPageSizeOptions();
  }
  /** The set of provided page size options to display to the user. */
  get pageSizeOptions() {
    return this._pageSizeOptions;
  }
  set pageSizeOptions(value) {
    this._pageSizeOptions = (value || []).map((p) => coerceNumberProperty(p));
    this._updateDisplayedPageSizeOptions();
  }
  /** Whether to hide the page size selection UI from the user. */
  get hidePageSize() {
    return this._hidePageSize;
  }
  set hidePageSize(value) {
    this._hidePageSize = coerceBooleanProperty(value);
  }
  /** Whether to show the first/last buttons UI to the user. */
  get showFirstLastButtons() {
    return this._showFirstLastButtons;
  }
  set showFirstLastButtons(value) {
    this._showFirstLastButtons = coerceBooleanProperty(value);
  }
  ngOnInit() {
    this._initialized = true;
    this._updateDisplayedPageSizeOptions();
    this._markInitialized();
  }
  ngOnDestroy() {
    this._intlChanges.unsubscribe();
  }
  /** Advances to the next page if it exists. */
  nextPage() {
    if (!this.hasNextPage()) {
      return;
    }
    const previousPageIndex = this.pageIndex;
    this.pageIndex = this.pageIndex + 1;
    this._emitPageEvent(previousPageIndex);
  }
  /** Move back to the previous page if it exists. */
  previousPage() {
    if (!this.hasPreviousPage()) {
      return;
    }
    const previousPageIndex = this.pageIndex;
    this.pageIndex = this.pageIndex - 1;
    this._emitPageEvent(previousPageIndex);
  }
  /** Move to the first page if not already there. */
  firstPage() {
    if (!this.hasPreviousPage()) {
      return;
    }
    const previousPageIndex = this.pageIndex;
    this.pageIndex = 0;
    this._emitPageEvent(previousPageIndex);
  }
  /** Move to the last page if not already there. */
  lastPage() {
    if (!this.hasNextPage()) {
      return;
    }
    const previousPageIndex = this.pageIndex;
    this.pageIndex = this.getNumberOfPages() - 1;
    this._emitPageEvent(previousPageIndex);
  }
  /** Whether there is a previous page. */
  hasPreviousPage() {
    return this.pageIndex >= 1 && this.pageSize != 0;
  }
  /** Whether there is a next page. */
  hasNextPage() {
    const maxPageIndex = this.getNumberOfPages() - 1;
    return this.pageIndex < maxPageIndex && this.pageSize != 0;
  }
  /** Calculate the number of pages */
  getNumberOfPages() {
    if (!this.pageSize) {
      return 0;
    }
    return Math.ceil(this.length / this.pageSize);
  }
  /**
   * Changes the page size so that the first item displayed on the page will still be
   * displayed using the new page size.
   *
   * For example, if the page size is 10 and on the second page (items indexed 10-19) then
   * switching so that the page size is 5 will set the third page as the current page so
   * that the 10th item will still be displayed.
   */
  _changePageSize(pageSize) {
    const startIndex = this.pageIndex * this.pageSize;
    const previousPageIndex = this.pageIndex;
    this.pageIndex = Math.floor(startIndex / pageSize) || 0;
    this.pageSize = pageSize;
    this._emitPageEvent(previousPageIndex);
  }
  /** Checks whether the buttons for going forwards should be disabled. */
  _nextButtonsDisabled() {
    return this.disabled || !this.hasNextPage();
  }
  /** Checks whether the buttons for going backwards should be disabled. */
  _previousButtonsDisabled() {
    return this.disabled || !this.hasPreviousPage();
  }
  /**
   * Updates the list of page size options to display to the user. Includes making sure that
   * the page size is an option and that the list is sorted.
   */
  _updateDisplayedPageSizeOptions() {
    if (!this._initialized) {
      return;
    }
    if (!this.pageSize) {
      this._pageSize = this.pageSizeOptions.length != 0 ? this.pageSizeOptions[0] : DEFAULT_PAGE_SIZE;
    }
    this._displayedPageSizeOptions = this.pageSizeOptions.slice();
    if (this._displayedPageSizeOptions.indexOf(this.pageSize) === -1) {
      this._displayedPageSizeOptions.push(this.pageSize);
    }
    this._displayedPageSizeOptions.sort((a, b) => a - b);
    this._changeDetectorRef.markForCheck();
  }
  /** Emits an event notifying that a change of the paginator's properties has been triggered. */
  _emitPageEvent(previousPageIndex) {
    this.page.emit({
      previousPageIndex,
      pageIndex: this.pageIndex,
      pageSize: this.pageSize,
      length: this.length
    });
  }
};
_MatPaginatorBase.ɵfac = function _MatPaginatorBase_Factory(ɵt) {
  ɵɵinvalidFactory();
};
_MatPaginatorBase.ɵdir = ɵɵdefineDirective({
  type: _MatPaginatorBase,
  inputs: {
    color: "color",
    pageIndex: "pageIndex",
    length: "length",
    pageSize: "pageSize",
    pageSizeOptions: "pageSizeOptions",
    hidePageSize: "hidePageSize",
    showFirstLastButtons: "showFirstLastButtons"
  },
  outputs: {
    page: "page"
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_MatPaginatorBase, [{
    type: Directive
  }], function() {
    return [{
      type: MatPaginatorIntl
    }, {
      type: ChangeDetectorRef
    }, {
      type: void 0
    }];
  }, {
    color: [{
      type: Input
    }],
    pageIndex: [{
      type: Input
    }],
    length: [{
      type: Input
    }],
    pageSize: [{
      type: Input
    }],
    pageSizeOptions: [{
      type: Input
    }],
    hidePageSize: [{
      type: Input
    }],
    showFirstLastButtons: [{
      type: Input
    }],
    page: [{
      type: Output
    }]
  });
})();
var MatPaginator = class extends _MatPaginatorBase {
  constructor(intl, changeDetectorRef, defaults) {
    super(intl, changeDetectorRef, defaults);
    if (defaults && defaults.formFieldAppearance != null) {
      this._formFieldAppearance = defaults.formFieldAppearance;
    }
  }
};
MatPaginator.ɵfac = function MatPaginator_Factory(ɵt) {
  return new (ɵt || MatPaginator)(ɵɵdirectiveInject(MatPaginatorIntl), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(MAT_PAGINATOR_DEFAULT_OPTIONS, 8));
};
MatPaginator.ɵcmp = ɵɵdefineComponent({
  type: MatPaginator,
  selectors: [["mat-paginator"]],
  hostAttrs: ["role", "group", 1, "mat-paginator"],
  inputs: {
    disabled: "disabled"
  },
  exportAs: ["matPaginator"],
  features: [ɵɵInheritDefinitionFeature],
  decls: 14,
  vars: 14,
  consts: [[1, "mat-paginator-outer-container"], [1, "mat-paginator-container"], ["class", "mat-paginator-page-size", 4, "ngIf"], [1, "mat-paginator-range-actions"], [1, "mat-paginator-range-label"], ["mat-icon-button", "", "type", "button", "class", "mat-paginator-navigation-first", 3, "matTooltip", "matTooltipDisabled", "matTooltipPosition", "disabled", "click", 4, "ngIf"], ["mat-icon-button", "", "type", "button", 1, "mat-paginator-navigation-previous", 3, "click", "matTooltip", "matTooltipDisabled", "matTooltipPosition", "disabled"], ["viewBox", "0 0 24 24", "focusable", "false", 1, "mat-paginator-icon"], ["d", "M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"], ["mat-icon-button", "", "type", "button", 1, "mat-paginator-navigation-next", 3, "click", "matTooltip", "matTooltipDisabled", "matTooltipPosition", "disabled"], ["d", "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"], ["mat-icon-button", "", "type", "button", "class", "mat-paginator-navigation-last", 3, "matTooltip", "matTooltipDisabled", "matTooltipPosition", "disabled", "click", 4, "ngIf"], [1, "mat-paginator-page-size"], [1, "mat-paginator-page-size-label"], ["class", "mat-paginator-page-size-select", 3, "appearance", "color", 4, "ngIf"], ["class", "mat-paginator-page-size-value", 4, "ngIf"], [1, "mat-paginator-page-size-select", 3, "appearance", "color"], [3, "selectionChange", "value", "disabled", "aria-label"], [3, "value", 4, "ngFor", "ngForOf"], [3, "value"], [1, "mat-paginator-page-size-value"], ["mat-icon-button", "", "type", "button", 1, "mat-paginator-navigation-first", 3, "click", "matTooltip", "matTooltipDisabled", "matTooltipPosition", "disabled"], ["d", "M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"], ["mat-icon-button", "", "type", "button", 1, "mat-paginator-navigation-last", 3, "click", "matTooltip", "matTooltipDisabled", "matTooltipPosition", "disabled"], ["d", "M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"]],
  template: function MatPaginator_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0)(1, "div", 1);
      ɵɵtemplate(2, MatPaginator_div_2_Template, 5, 3, "div", 2);
      ɵɵelementStart(3, "div", 3)(4, "div", 4);
      ɵɵtext(5);
      ɵɵelementEnd();
      ɵɵtemplate(6, MatPaginator_button_6_Template, 3, 5, "button", 5);
      ɵɵelementStart(7, "button", 6);
      ɵɵlistener("click", function MatPaginator_Template_button_click_7_listener() {
        return ctx.previousPage();
      });
      ɵɵnamespaceSVG();
      ɵɵelementStart(8, "svg", 7);
      ɵɵelement(9, "path", 8);
      ɵɵelementEnd()();
      ɵɵnamespaceHTML();
      ɵɵelementStart(10, "button", 9);
      ɵɵlistener("click", function MatPaginator_Template_button_click_10_listener() {
        return ctx.nextPage();
      });
      ɵɵnamespaceSVG();
      ɵɵelementStart(11, "svg", 7);
      ɵɵelement(12, "path", 10);
      ɵɵelementEnd()();
      ɵɵtemplate(13, MatPaginator_button_13_Template, 3, 5, "button", 11);
      ɵɵelementEnd()()();
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵproperty("ngIf", !ctx.hidePageSize);
      ɵɵadvance(3);
      ɵɵtextInterpolate1(" ", ctx._intl.getRangeLabel(ctx.pageIndex, ctx.pageSize, ctx.length), " ");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.showFirstLastButtons);
      ɵɵadvance();
      ɵɵproperty("matTooltip", ctx._intl.previousPageLabel)("matTooltipDisabled", ctx._previousButtonsDisabled())("matTooltipPosition", "above")("disabled", ctx._previousButtonsDisabled());
      ɵɵattribute("aria-label", ctx._intl.previousPageLabel);
      ɵɵadvance(3);
      ɵɵproperty("matTooltip", ctx._intl.nextPageLabel)("matTooltipDisabled", ctx._nextButtonsDisabled())("matTooltipPosition", "above")("disabled", ctx._nextButtonsDisabled());
      ɵɵattribute("aria-label", ctx._intl.nextPageLabel);
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx.showFirstLastButtons);
    }
  },
  dependencies: [MatFormField, MatSelect, MatOption, MatButton, NgIf, NgForOf, MatTooltip],
  styles: [".mat-paginator{display:block}.mat-paginator-outer-container{display:flex}.mat-paginator-container{display:flex;align-items:center;justify-content:flex-end;padding:0 8px;flex-wrap:wrap-reverse;width:100%}.mat-paginator-page-size{display:flex;align-items:baseline;margin-right:8px}[dir=rtl] .mat-paginator-page-size{margin-right:0;margin-left:8px}.mat-paginator-page-size-label{margin:0 4px}.mat-paginator-page-size-select{margin:6px 4px 0 4px;width:56px}.mat-paginator-page-size-select.mat-form-field-appearance-outline{width:64px}.mat-paginator-page-size-select.mat-form-field-appearance-fill{width:64px}.mat-paginator-range-label{margin:0 32px 0 24px}.mat-paginator-range-actions{display:flex;align-items:center}.mat-paginator-icon{width:28px;fill:currentColor}[dir=rtl] .mat-paginator-icon{transform:rotate(180deg)}.cdk-high-contrast-active .mat-paginator-icon{fill:CanvasText}\n"],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatPaginator, [{
    type: Component,
    args: [{
      selector: "mat-paginator",
      exportAs: "matPaginator",
      inputs: ["disabled"],
      host: {
        "class": "mat-paginator",
        "role": "group"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: `<div class="mat-paginator-outer-container">
  <div class="mat-paginator-container">
    <div class="mat-paginator-page-size" *ngIf="!hidePageSize">
      <div class="mat-paginator-page-size-label">
        {{_intl.itemsPerPageLabel}}
      </div>

      <mat-form-field
        *ngIf="_displayedPageSizeOptions.length > 1"
        [appearance]="_formFieldAppearance!"
        [color]="color"
        class="mat-paginator-page-size-select">
        <mat-select
          [value]="pageSize"
          [disabled]="disabled"
          [aria-label]="_intl.itemsPerPageLabel"
          (selectionChange)="_changePageSize($event.value)">
          <mat-option *ngFor="let pageSizeOption of _displayedPageSizeOptions" [value]="pageSizeOption">
            {{pageSizeOption}}
          </mat-option>
        </mat-select>
      </mat-form-field>

      <div
        class="mat-paginator-page-size-value"
        *ngIf="_displayedPageSizeOptions.length <= 1">{{pageSize}}</div>
    </div>

    <div class="mat-paginator-range-actions">
      <div class="mat-paginator-range-label">
        {{_intl.getRangeLabel(pageIndex, pageSize, length)}}
      </div>

      <button mat-icon-button type="button"
              class="mat-paginator-navigation-first"
              (click)="firstPage()"
              [attr.aria-label]="_intl.firstPageLabel"
              [matTooltip]="_intl.firstPageLabel"
              [matTooltipDisabled]="_previousButtonsDisabled()"
              [matTooltipPosition]="'above'"
              [disabled]="_previousButtonsDisabled()"
              *ngIf="showFirstLastButtons">
        <svg class="mat-paginator-icon" viewBox="0 0 24 24" focusable="false">
          <path d="M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"/>
        </svg>
      </button>
      <button mat-icon-button type="button"
              class="mat-paginator-navigation-previous"
              (click)="previousPage()"
              [attr.aria-label]="_intl.previousPageLabel"
              [matTooltip]="_intl.previousPageLabel"
              [matTooltipDisabled]="_previousButtonsDisabled()"
              [matTooltipPosition]="'above'"
              [disabled]="_previousButtonsDisabled()">
        <svg class="mat-paginator-icon" viewBox="0 0 24 24" focusable="false">
          <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
        </svg>
      </button>
      <button mat-icon-button type="button"
              class="mat-paginator-navigation-next"
              (click)="nextPage()"
              [attr.aria-label]="_intl.nextPageLabel"
              [matTooltip]="_intl.nextPageLabel"
              [matTooltipDisabled]="_nextButtonsDisabled()"
              [matTooltipPosition]="'above'"
              [disabled]="_nextButtonsDisabled()">
        <svg class="mat-paginator-icon" viewBox="0 0 24 24" focusable="false">
          <path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/>
        </svg>
      </button>
      <button mat-icon-button type="button"
              class="mat-paginator-navigation-last"
              (click)="lastPage()"
              [attr.aria-label]="_intl.lastPageLabel"
              [matTooltip]="_intl.lastPageLabel"
              [matTooltipDisabled]="_nextButtonsDisabled()"
              [matTooltipPosition]="'above'"
              [disabled]="_nextButtonsDisabled()"
              *ngIf="showFirstLastButtons">
        <svg class="mat-paginator-icon" viewBox="0 0 24 24" focusable="false">
          <path d="M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"/>
        </svg>
      </button>
    </div>
  </div>
</div>
`,
      styles: [".mat-paginator{display:block}.mat-paginator-outer-container{display:flex}.mat-paginator-container{display:flex;align-items:center;justify-content:flex-end;padding:0 8px;flex-wrap:wrap-reverse;width:100%}.mat-paginator-page-size{display:flex;align-items:baseline;margin-right:8px}[dir=rtl] .mat-paginator-page-size{margin-right:0;margin-left:8px}.mat-paginator-page-size-label{margin:0 4px}.mat-paginator-page-size-select{margin:6px 4px 0 4px;width:56px}.mat-paginator-page-size-select.mat-form-field-appearance-outline{width:64px}.mat-paginator-page-size-select.mat-form-field-appearance-fill{width:64px}.mat-paginator-range-label{margin:0 32px 0 24px}.mat-paginator-range-actions{display:flex;align-items:center}.mat-paginator-icon{width:28px;fill:currentColor}[dir=rtl] .mat-paginator-icon{transform:rotate(180deg)}.cdk-high-contrast-active .mat-paginator-icon{fill:CanvasText}\n"]
    }]
  }], function() {
    return [{
      type: MatPaginatorIntl
    }, {
      type: ChangeDetectorRef
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [MAT_PAGINATOR_DEFAULT_OPTIONS]
      }]
    }];
  }, null);
})();
var MatPaginatorModule = class {
};
MatPaginatorModule.ɵfac = function MatPaginatorModule_Factory(ɵt) {
  return new (ɵt || MatPaginatorModule)();
};
MatPaginatorModule.ɵmod = ɵɵdefineNgModule({
  type: MatPaginatorModule,
  declarations: [MatPaginator],
  imports: [CommonModule, MatButtonModule, MatSelectModule, MatTooltipModule, MatCommonModule],
  exports: [MatPaginator]
});
MatPaginatorModule.ɵinj = ɵɵdefineInjector({
  providers: [MAT_PAGINATOR_INTL_PROVIDER],
  imports: [[CommonModule, MatButtonModule, MatSelectModule, MatTooltipModule, MatCommonModule]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatPaginatorModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, MatButtonModule, MatSelectModule, MatTooltipModule, MatCommonModule],
      exports: [MatPaginator],
      declarations: [MatPaginator],
      providers: [MAT_PAGINATOR_INTL_PROVIDER]
    }]
  }], null, null);
})();

// node_modules/@angular/material/fesm2020/sort.mjs
var _c02 = ["mat-sort-header", ""];
var _c1 = ["*"];
function MatSortHeader_div_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 3);
    ɵɵlistener("@arrowPosition.start", function MatSortHeader_div_3_Template_div_animation_arrowPosition_start_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._disableViewStateAnimation = true);
    })("@arrowPosition.done", function MatSortHeader_div_3_Template_div_animation_arrowPosition_done_0_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1._disableViewStateAnimation = false);
    });
    ɵɵelement(1, "div", 4);
    ɵɵelementStart(2, "div", 5);
    ɵɵelement(3, "div", 6)(4, "div", 7)(5, "div", 8);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("@arrowOpacity", ctx_r1._getArrowViewState())("@arrowPosition", ctx_r1._getArrowViewState())("@allowChildren", ctx_r1._getArrowDirectionState());
    ɵɵadvance(2);
    ɵɵproperty("@indicator", ctx_r1._getArrowDirectionState());
    ɵɵadvance();
    ɵɵproperty("@leftPointer", ctx_r1._getArrowDirectionState());
    ɵɵadvance();
    ɵɵproperty("@rightPointer", ctx_r1._getArrowDirectionState());
  }
}
function getSortDuplicateSortableIdError(id) {
  return Error(`Cannot have two MatSortables with the same id (${id}).`);
}
function getSortHeaderNotContainedWithinSortError() {
  return Error(`MatSortHeader must be placed within a parent element with the MatSort directive.`);
}
function getSortHeaderMissingIdError() {
  return Error(`MatSortHeader must be provided with a unique id.`);
}
function getSortInvalidDirectionError(direction) {
  return Error(`${direction} is not a valid sort direction ('asc' or 'desc').`);
}
var MAT_SORT_DEFAULT_OPTIONS = new InjectionToken("MAT_SORT_DEFAULT_OPTIONS");
var _MatSortBase = mixinInitialized(mixinDisabled(class {
}));
var MatSort = class extends _MatSortBase {
  constructor(_defaultOptions) {
    super();
    this._defaultOptions = _defaultOptions;
    this.sortables = /* @__PURE__ */ new Map();
    this._stateChanges = new Subject();
    this.start = "asc";
    this._direction = "";
    this.sortChange = new EventEmitter();
  }
  /** The sort direction of the currently active MatSortable. */
  get direction() {
    return this._direction;
  }
  set direction(direction) {
    if (direction && direction !== "asc" && direction !== "desc" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getSortInvalidDirectionError(direction);
    }
    this._direction = direction;
  }
  /**
   * Whether to disable the user from clearing the sort by finishing the sort direction cycle.
   * May be overriden by the MatSortable's disable clear input.
   */
  get disableClear() {
    return this._disableClear;
  }
  set disableClear(v) {
    this._disableClear = coerceBooleanProperty(v);
  }
  /**
   * Register function to be used by the contained MatSortables. Adds the MatSortable to the
   * collection of MatSortables.
   */
  register(sortable) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!sortable.id) {
        throw getSortHeaderMissingIdError();
      }
      if (this.sortables.has(sortable.id)) {
        throw getSortDuplicateSortableIdError(sortable.id);
      }
    }
    this.sortables.set(sortable.id, sortable);
  }
  /**
   * Unregister function to be used by the contained MatSortables. Removes the MatSortable from the
   * collection of contained MatSortables.
   */
  deregister(sortable) {
    this.sortables.delete(sortable.id);
  }
  /** Sets the active sort id and determines the new sort direction. */
  sort(sortable) {
    if (this.active != sortable.id) {
      this.active = sortable.id;
      this.direction = sortable.start ? sortable.start : this.start;
    } else {
      this.direction = this.getNextSortDirection(sortable);
    }
    this.sortChange.emit({
      active: this.active,
      direction: this.direction
    });
  }
  /** Returns the next sort direction of the active sortable, checking for potential overrides. */
  getNextSortDirection(sortable) {
    if (!sortable) {
      return "";
    }
    const disableClear = sortable?.disableClear ?? this.disableClear ?? !!this._defaultOptions?.disableClear;
    let sortDirectionCycle = getSortDirectionCycle(sortable.start || this.start, disableClear);
    let nextDirectionIndex = sortDirectionCycle.indexOf(this.direction) + 1;
    if (nextDirectionIndex >= sortDirectionCycle.length) {
      nextDirectionIndex = 0;
    }
    return sortDirectionCycle[nextDirectionIndex];
  }
  ngOnInit() {
    this._markInitialized();
  }
  ngOnChanges() {
    this._stateChanges.next();
  }
  ngOnDestroy() {
    this._stateChanges.complete();
  }
};
MatSort.ɵfac = function MatSort_Factory(ɵt) {
  return new (ɵt || MatSort)(ɵɵdirectiveInject(MAT_SORT_DEFAULT_OPTIONS, 8));
};
MatSort.ɵdir = ɵɵdefineDirective({
  type: MatSort,
  selectors: [["", "matSort", ""]],
  hostAttrs: [1, "mat-sort"],
  inputs: {
    disabled: [0, "matSortDisabled", "disabled"],
    active: [0, "matSortActive", "active"],
    start: [0, "matSortStart", "start"],
    direction: [0, "matSortDirection", "direction"],
    disableClear: [0, "matSortDisableClear", "disableClear"]
  },
  outputs: {
    sortChange: "matSortChange"
  },
  exportAs: ["matSort"],
  features: [ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSort, [{
    type: Directive,
    args: [{
      selector: "[matSort]",
      exportAs: "matSort",
      host: {
        "class": "mat-sort"
      },
      inputs: ["disabled: matSortDisabled"]
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [MAT_SORT_DEFAULT_OPTIONS]
      }]
    }];
  }, {
    active: [{
      type: Input,
      args: ["matSortActive"]
    }],
    start: [{
      type: Input,
      args: ["matSortStart"]
    }],
    direction: [{
      type: Input,
      args: ["matSortDirection"]
    }],
    disableClear: [{
      type: Input,
      args: ["matSortDisableClear"]
    }],
    sortChange: [{
      type: Output,
      args: ["matSortChange"]
    }]
  });
})();
function getSortDirectionCycle(start, disableClear) {
  let sortOrder = ["asc", "desc"];
  if (start == "desc") {
    sortOrder.reverse();
  }
  if (!disableClear) {
    sortOrder.push("");
  }
  return sortOrder;
}
var SORT_ANIMATION_TRANSITION = AnimationDurations.ENTERING + " " + AnimationCurves.STANDARD_CURVE;
var matSortAnimations = {
  /** Animation that moves the sort indicator. */
  indicator: trigger("indicator", [
    state("active-asc, asc", style({
      transform: "translateY(0px)"
    })),
    // 10px is the height of the sort indicator, minus the width of the pointers
    state("active-desc, desc", style({
      transform: "translateY(10px)"
    })),
    transition("active-asc <=> active-desc", animate(SORT_ANIMATION_TRANSITION))
  ]),
  /** Animation that rotates the left pointer of the indicator based on the sorting direction. */
  leftPointer: trigger("leftPointer", [state("active-asc, asc", style({
    transform: "rotate(-45deg)"
  })), state("active-desc, desc", style({
    transform: "rotate(45deg)"
  })), transition("active-asc <=> active-desc", animate(SORT_ANIMATION_TRANSITION))]),
  /** Animation that rotates the right pointer of the indicator based on the sorting direction. */
  rightPointer: trigger("rightPointer", [state("active-asc, asc", style({
    transform: "rotate(45deg)"
  })), state("active-desc, desc", style({
    transform: "rotate(-45deg)"
  })), transition("active-asc <=> active-desc", animate(SORT_ANIMATION_TRANSITION))]),
  /** Animation that controls the arrow opacity. */
  arrowOpacity: trigger("arrowOpacity", [
    state("desc-to-active, asc-to-active, active", style({
      opacity: 1
    })),
    state("desc-to-hint, asc-to-hint, hint", style({
      opacity: 0.54
    })),
    state("hint-to-desc, active-to-desc, desc, hint-to-asc, active-to-asc, asc, void", style({
      opacity: 0
    })),
    // Transition between all states except for immediate transitions
    transition("* => asc, * => desc, * => active, * => hint, * => void", animate("0ms")),
    transition("* <=> *", animate(SORT_ANIMATION_TRANSITION))
  ]),
  /**
   * Animation for the translation of the arrow as a whole. States are separated into two
   * groups: ones with animations and others that are immediate. Immediate states are asc, desc,
   * peek, and active. The other states define a specific animation (source-to-destination)
   * and are determined as a function of their prev user-perceived state and what the next state
   * should be.
   */
  arrowPosition: trigger("arrowPosition", [
    // Hidden Above => Hint Center
    transition("* => desc-to-hint, * => desc-to-active", animate(SORT_ANIMATION_TRANSITION, keyframes([style({
      transform: "translateY(-25%)"
    }), style({
      transform: "translateY(0)"
    })]))),
    // Hint Center => Hidden Below
    transition("* => hint-to-desc, * => active-to-desc", animate(SORT_ANIMATION_TRANSITION, keyframes([style({
      transform: "translateY(0)"
    }), style({
      transform: "translateY(25%)"
    })]))),
    // Hidden Below => Hint Center
    transition("* => asc-to-hint, * => asc-to-active", animate(SORT_ANIMATION_TRANSITION, keyframes([style({
      transform: "translateY(25%)"
    }), style({
      transform: "translateY(0)"
    })]))),
    // Hint Center => Hidden Above
    transition("* => hint-to-asc, * => active-to-asc", animate(SORT_ANIMATION_TRANSITION, keyframes([style({
      transform: "translateY(0)"
    }), style({
      transform: "translateY(-25%)"
    })]))),
    state("desc-to-hint, asc-to-hint, hint, desc-to-active, asc-to-active, active", style({
      transform: "translateY(0)"
    })),
    state("hint-to-desc, active-to-desc, desc", style({
      transform: "translateY(-25%)"
    })),
    state("hint-to-asc, active-to-asc, asc", style({
      transform: "translateY(25%)"
    }))
  ]),
  /** Necessary trigger that calls animate on children animations. */
  allowChildren: trigger("allowChildren", [transition("* <=> *", [query("@*", animateChild(), {
    optional: true
  })])])
};
var MatSortHeaderIntl = class {
  constructor() {
    this.changes = new Subject();
  }
};
MatSortHeaderIntl.ɵfac = function MatSortHeaderIntl_Factory(ɵt) {
  return new (ɵt || MatSortHeaderIntl)();
};
MatSortHeaderIntl.ɵprov = ɵɵdefineInjectable({
  token: MatSortHeaderIntl,
  factory: MatSortHeaderIntl.ɵfac,
  providedIn: "root"
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSortHeaderIntl, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function MAT_SORT_HEADER_INTL_PROVIDER_FACTORY(parentIntl) {
  return parentIntl || new MatSortHeaderIntl();
}
var MAT_SORT_HEADER_INTL_PROVIDER = {
  // If there is already an MatSortHeaderIntl available, use that. Otherwise, provide a new one.
  provide: MatSortHeaderIntl,
  deps: [[new Optional(), new SkipSelf(), MatSortHeaderIntl]],
  useFactory: MAT_SORT_HEADER_INTL_PROVIDER_FACTORY
};
var _MatSortHeaderBase = mixinDisabled(class {
});
var MatSortHeader = class extends _MatSortHeaderBase {
  constructor(_intl, _changeDetectorRef, _sort, _columnDef, _focusMonitor, _elementRef, _ariaDescriber) {
    super();
    this._intl = _intl;
    this._changeDetectorRef = _changeDetectorRef;
    this._sort = _sort;
    this._columnDef = _columnDef;
    this._focusMonitor = _focusMonitor;
    this._elementRef = _elementRef;
    this._ariaDescriber = _ariaDescriber;
    this._showIndicatorHint = false;
    this._viewState = {};
    this._arrowDirection = "";
    this._disableViewStateAnimation = false;
    this.arrowPosition = "after";
    this._sortActionDescription = "Sort";
    if (!_sort && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getSortHeaderNotContainedWithinSortError();
    }
    this._handleStateChanges();
  }
  /**
   * Description applied to MatSortHeader's button element with aria-describedby. This text should
   * describe the action that will occur when the user clicks the sort header.
   */
  get sortActionDescription() {
    return this._sortActionDescription;
  }
  set sortActionDescription(value) {
    this._updateSortActionDescription(value);
  }
  /** Overrides the disable clear value of the containing MatSort for this MatSortable. */
  get disableClear() {
    return this._disableClear;
  }
  set disableClear(v) {
    this._disableClear = coerceBooleanProperty(v);
  }
  ngOnInit() {
    if (!this.id && this._columnDef) {
      this.id = this._columnDef.name;
    }
    this._updateArrowDirection();
    this._setAnimationTransitionState({
      toState: this._isSorted() ? "active" : this._arrowDirection
    });
    this._sort.register(this);
    this._sortButton = this._elementRef.nativeElement.querySelector(".mat-sort-header-container");
    this._updateSortActionDescription(this._sortActionDescription);
  }
  ngAfterViewInit() {
    this._focusMonitor.monitor(this._elementRef, true).subscribe((origin) => {
      const newState = !!origin;
      if (newState !== this._showIndicatorHint) {
        this._setIndicatorHintVisible(newState);
        this._changeDetectorRef.markForCheck();
      }
    });
  }
  ngOnDestroy() {
    this._focusMonitor.stopMonitoring(this._elementRef);
    this._sort.deregister(this);
    this._rerenderSubscription.unsubscribe();
  }
  /**
   * Sets the "hint" state such that the arrow will be semi-transparently displayed as a hint to the
   * user showing what the active sort will become. If set to false, the arrow will fade away.
   */
  _setIndicatorHintVisible(visible) {
    if (this._isDisabled() && visible) {
      return;
    }
    this._showIndicatorHint = visible;
    if (!this._isSorted()) {
      this._updateArrowDirection();
      if (this._showIndicatorHint) {
        this._setAnimationTransitionState({
          fromState: this._arrowDirection,
          toState: "hint"
        });
      } else {
        this._setAnimationTransitionState({
          fromState: "hint",
          toState: this._arrowDirection
        });
      }
    }
  }
  /**
   * Sets the animation transition view state for the arrow's position and opacity. If the
   * `disableViewStateAnimation` flag is set to true, the `fromState` will be ignored so that
   * no animation appears.
   */
  _setAnimationTransitionState(viewState) {
    this._viewState = viewState || {};
    if (this._disableViewStateAnimation) {
      this._viewState = {
        toState: viewState.toState
      };
    }
  }
  /** Triggers the sort on this sort header and removes the indicator hint. */
  _toggleOnInteraction() {
    this._sort.sort(this);
    if (this._viewState.toState === "hint" || this._viewState.toState === "active") {
      this._disableViewStateAnimation = true;
    }
  }
  _handleClick() {
    if (!this._isDisabled()) {
      this._sort.sort(this);
    }
  }
  _handleKeydown(event) {
    if (!this._isDisabled() && (event.keyCode === SPACE || event.keyCode === ENTER)) {
      event.preventDefault();
      this._toggleOnInteraction();
    }
  }
  /** Whether this MatSortHeader is currently sorted in either ascending or descending order. */
  _isSorted() {
    return this._sort.active == this.id && (this._sort.direction === "asc" || this._sort.direction === "desc");
  }
  /** Returns the animation state for the arrow direction (indicator and pointers). */
  _getArrowDirectionState() {
    return `${this._isSorted() ? "active-" : ""}${this._arrowDirection}`;
  }
  /** Returns the arrow position state (opacity, translation). */
  _getArrowViewState() {
    const fromState = this._viewState.fromState;
    return (fromState ? `${fromState}-to-` : "") + this._viewState.toState;
  }
  /**
   * Updates the direction the arrow should be pointing. If it is not sorted, the arrow should be
   * facing the start direction. Otherwise if it is sorted, the arrow should point in the currently
   * active sorted direction. The reason this is updated through a function is because the direction
   * should only be changed at specific times - when deactivated but the hint is displayed and when
   * the sort is active and the direction changes. Otherwise the arrow's direction should linger
   * in cases such as the sort becoming deactivated but we want to animate the arrow away while
   * preserving its direction, even though the next sort direction is actually different and should
   * only be changed once the arrow displays again (hint or activation).
   */
  _updateArrowDirection() {
    this._arrowDirection = this._isSorted() ? this._sort.direction : this.start || this._sort.start;
  }
  _isDisabled() {
    return this._sort.disabled || this.disabled;
  }
  /**
   * Gets the aria-sort attribute that should be applied to this sort header. If this header
   * is not sorted, returns null so that the attribute is removed from the host element. Aria spec
   * says that the aria-sort property should only be present on one header at a time, so removing
   * ensures this is true.
   */
  _getAriaSortAttribute() {
    if (!this._isSorted()) {
      return "none";
    }
    return this._sort.direction == "asc" ? "ascending" : "descending";
  }
  /** Whether the arrow inside the sort header should be rendered. */
  _renderArrow() {
    return !this._isDisabled() || this._isSorted();
  }
  _updateSortActionDescription(newDescription) {
    if (this._sortButton) {
      this._ariaDescriber?.removeDescription(this._sortButton, this._sortActionDescription);
      this._ariaDescriber?.describe(this._sortButton, newDescription);
    }
    this._sortActionDescription = newDescription;
  }
  /** Handles changes in the sorting state. */
  _handleStateChanges() {
    this._rerenderSubscription = merge(this._sort.sortChange, this._sort._stateChanges, this._intl.changes).subscribe(() => {
      if (this._isSorted()) {
        this._updateArrowDirection();
        if (this._viewState.toState === "hint" || this._viewState.toState === "active") {
          this._disableViewStateAnimation = true;
        }
        this._setAnimationTransitionState({
          fromState: this._arrowDirection,
          toState: "active"
        });
        this._showIndicatorHint = false;
      }
      if (!this._isSorted() && this._viewState && this._viewState.toState === "active") {
        this._disableViewStateAnimation = false;
        this._setAnimationTransitionState({
          fromState: "active",
          toState: this._arrowDirection
        });
      }
      this._changeDetectorRef.markForCheck();
    });
  }
};
MatSortHeader.ɵfac = function MatSortHeader_Factory(ɵt) {
  return new (ɵt || MatSortHeader)(ɵɵdirectiveInject(MatSortHeaderIntl), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(MatSort, 8), ɵɵdirectiveInject("MAT_SORT_HEADER_COLUMN_DEF", 8), ɵɵdirectiveInject(FocusMonitor), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(AriaDescriber, 8));
};
MatSortHeader.ɵcmp = ɵɵdefineComponent({
  type: MatSortHeader,
  selectors: [["", "mat-sort-header", ""]],
  hostAttrs: [1, "mat-sort-header"],
  hostVars: 3,
  hostBindings: function MatSortHeader_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function MatSortHeader_click_HostBindingHandler() {
        return ctx._handleClick();
      })("keydown", function MatSortHeader_keydown_HostBindingHandler($event) {
        return ctx._handleKeydown($event);
      })("mouseenter", function MatSortHeader_mouseenter_HostBindingHandler() {
        return ctx._setIndicatorHintVisible(true);
      })("mouseleave", function MatSortHeader_mouseleave_HostBindingHandler() {
        return ctx._setIndicatorHintVisible(false);
      });
    }
    if (rf & 2) {
      ɵɵattribute("aria-sort", ctx._getAriaSortAttribute());
      ɵɵclassProp("mat-sort-header-disabled", ctx._isDisabled());
    }
  },
  inputs: {
    disabled: "disabled",
    id: [0, "mat-sort-header", "id"],
    arrowPosition: "arrowPosition",
    start: "start",
    sortActionDescription: "sortActionDescription",
    disableClear: "disableClear"
  },
  exportAs: ["matSortHeader"],
  features: [ɵɵInheritDefinitionFeature],
  attrs: _c02,
  ngContentSelectors: _c1,
  decls: 4,
  vars: 7,
  consts: [[1, "mat-sort-header-container", "mat-focus-indicator"], [1, "mat-sort-header-content"], ["class", "mat-sort-header-arrow", 4, "ngIf"], [1, "mat-sort-header-arrow"], [1, "mat-sort-header-stem"], [1, "mat-sort-header-indicator"], [1, "mat-sort-header-pointer-left"], [1, "mat-sort-header-pointer-right"], [1, "mat-sort-header-pointer-middle"]],
  template: function MatSortHeader_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0)(1, "div", 1);
      ɵɵprojection(2);
      ɵɵelementEnd();
      ɵɵtemplate(3, MatSortHeader_div_3_Template, 6, 6, "div", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassProp("mat-sort-header-sorted", ctx._isSorted())("mat-sort-header-position-before", ctx.arrowPosition == "before");
      ɵɵattribute("tabindex", ctx._isDisabled() ? null : 0)("role", ctx._isDisabled() ? null : "button");
      ɵɵadvance(3);
      ɵɵproperty("ngIf", ctx._renderArrow());
    }
  },
  dependencies: [NgIf],
  styles: [".mat-sort-header-container{display:flex;cursor:pointer;align-items:center;letter-spacing:normal;outline:0}[mat-sort-header].cdk-keyboard-focused .mat-sort-header-container,[mat-sort-header].cdk-program-focused .mat-sort-header-container{border-bottom:solid 1px currentColor}.mat-sort-header-disabled .mat-sort-header-container{cursor:default}.mat-sort-header-content{text-align:center;display:flex;align-items:center}.mat-sort-header-position-before{flex-direction:row-reverse}.mat-sort-header-arrow{height:12px;width:12px;min-width:12px;position:relative;display:flex;opacity:0}.mat-sort-header-arrow,[dir=rtl] .mat-sort-header-position-before .mat-sort-header-arrow{margin:0 0 0 6px}.mat-sort-header-position-before .mat-sort-header-arrow,[dir=rtl] .mat-sort-header-arrow{margin:0 6px 0 0}.mat-sort-header-stem{background:currentColor;height:10px;width:2px;margin:auto;display:flex;align-items:center}.cdk-high-contrast-active .mat-sort-header-stem{width:0;border-left:solid 2px}.mat-sort-header-indicator{width:100%;height:2px;display:flex;align-items:center;position:absolute;top:0;left:0}.mat-sort-header-pointer-middle{margin:auto;height:2px;width:2px;background:currentColor;transform:rotate(45deg)}.cdk-high-contrast-active .mat-sort-header-pointer-middle{width:0;height:0;border-top:solid 2px;border-left:solid 2px}.mat-sort-header-pointer-left,.mat-sort-header-pointer-right{background:currentColor;width:6px;height:2px;position:absolute;top:0}.cdk-high-contrast-active .mat-sort-header-pointer-left,.cdk-high-contrast-active .mat-sort-header-pointer-right{width:0;height:0;border-left:solid 6px;border-top:solid 2px}.mat-sort-header-pointer-left{transform-origin:right;left:0}.mat-sort-header-pointer-right{transform-origin:left;right:0}\n"],
  encapsulation: 2,
  data: {
    animation: [matSortAnimations.indicator, matSortAnimations.leftPointer, matSortAnimations.rightPointer, matSortAnimations.arrowOpacity, matSortAnimations.arrowPosition, matSortAnimations.allowChildren]
  },
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSortHeader, [{
    type: Component,
    args: [{
      selector: "[mat-sort-header]",
      exportAs: "matSortHeader",
      host: {
        "class": "mat-sort-header",
        "(click)": "_handleClick()",
        "(keydown)": "_handleKeydown($event)",
        "(mouseenter)": "_setIndicatorHintVisible(true)",
        "(mouseleave)": "_setIndicatorHintVisible(false)",
        "[attr.aria-sort]": "_getAriaSortAttribute()",
        "[class.mat-sort-header-disabled]": "_isDisabled()"
      },
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      inputs: ["disabled"],
      animations: [matSortAnimations.indicator, matSortAnimations.leftPointer, matSortAnimations.rightPointer, matSortAnimations.arrowOpacity, matSortAnimations.arrowPosition, matSortAnimations.allowChildren],
      template: '<!--\n  We set the `tabindex` on an element inside the table header, rather than the header itself,\n  because of a bug in NVDA where having a `tabindex` on a `th` breaks keyboard navigation in the\n  table (see https://github.com/nvaccess/nvda/issues/7718). This allows for the header to both\n  be focusable, and have screen readers read out its `aria-sort` state. We prefer this approach\n  over having a button with an `aria-label` inside the header, because the button\'s `aria-label`\n  will be read out as the user is navigating the table\'s cell (see #13012).\n\n  The approach is based off of: https://dequeuniversity.com/library/aria/tables/sf-sortable-grid\n-->\n<div class="mat-sort-header-container mat-focus-indicator"\n     [class.mat-sort-header-sorted]="_isSorted()"\n     [class.mat-sort-header-position-before]="arrowPosition == \'before\'"\n     [attr.tabindex]="_isDisabled() ? null : 0"\n     [attr.role]="_isDisabled() ? null : \'button\'">\n\n  <!--\n    TODO(crisbeto): this div isn\'t strictly necessary, but we have to keep it due to a large\n    number of screenshot diff failures. It should be removed eventually. Note that the difference\n    isn\'t visible with a shorter header, but once it breaks up into multiple lines, this element\n    causes it to be center-aligned, whereas removing it will keep the text to the left.\n  -->\n  <div class="mat-sort-header-content">\n    <ng-content></ng-content>\n  </div>\n\n  <!-- Disable animations while a current animation is running -->\n  <div class="mat-sort-header-arrow"\n       *ngIf="_renderArrow()"\n       [@arrowOpacity]="_getArrowViewState()"\n       [@arrowPosition]="_getArrowViewState()"\n       [@allowChildren]="_getArrowDirectionState()"\n       (@arrowPosition.start)="_disableViewStateAnimation = true"\n       (@arrowPosition.done)="_disableViewStateAnimation = false">\n    <div class="mat-sort-header-stem"></div>\n    <div class="mat-sort-header-indicator" [@indicator]="_getArrowDirectionState()">\n      <div class="mat-sort-header-pointer-left" [@leftPointer]="_getArrowDirectionState()"></div>\n      <div class="mat-sort-header-pointer-right" [@rightPointer]="_getArrowDirectionState()"></div>\n      <div class="mat-sort-header-pointer-middle"></div>\n    </div>\n  </div>\n</div>\n',
      styles: [".mat-sort-header-container{display:flex;cursor:pointer;align-items:center;letter-spacing:normal;outline:0}[mat-sort-header].cdk-keyboard-focused .mat-sort-header-container,[mat-sort-header].cdk-program-focused .mat-sort-header-container{border-bottom:solid 1px currentColor}.mat-sort-header-disabled .mat-sort-header-container{cursor:default}.mat-sort-header-content{text-align:center;display:flex;align-items:center}.mat-sort-header-position-before{flex-direction:row-reverse}.mat-sort-header-arrow{height:12px;width:12px;min-width:12px;position:relative;display:flex;opacity:0}.mat-sort-header-arrow,[dir=rtl] .mat-sort-header-position-before .mat-sort-header-arrow{margin:0 0 0 6px}.mat-sort-header-position-before .mat-sort-header-arrow,[dir=rtl] .mat-sort-header-arrow{margin:0 6px 0 0}.mat-sort-header-stem{background:currentColor;height:10px;width:2px;margin:auto;display:flex;align-items:center}.cdk-high-contrast-active .mat-sort-header-stem{width:0;border-left:solid 2px}.mat-sort-header-indicator{width:100%;height:2px;display:flex;align-items:center;position:absolute;top:0;left:0}.mat-sort-header-pointer-middle{margin:auto;height:2px;width:2px;background:currentColor;transform:rotate(45deg)}.cdk-high-contrast-active .mat-sort-header-pointer-middle{width:0;height:0;border-top:solid 2px;border-left:solid 2px}.mat-sort-header-pointer-left,.mat-sort-header-pointer-right{background:currentColor;width:6px;height:2px;position:absolute;top:0}.cdk-high-contrast-active .mat-sort-header-pointer-left,.cdk-high-contrast-active .mat-sort-header-pointer-right{width:0;height:0;border-left:solid 6px;border-top:solid 2px}.mat-sort-header-pointer-left{transform-origin:right;left:0}.mat-sort-header-pointer-right{transform-origin:left;right:0}\n"]
    }]
  }], function() {
    return [{
      type: MatSortHeaderIntl
    }, {
      type: ChangeDetectorRef
    }, {
      type: MatSort,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: ["MAT_SORT_HEADER_COLUMN_DEF"]
      }, {
        type: Optional
      }]
    }, {
      type: FocusMonitor
    }, {
      type: ElementRef
    }, {
      type: AriaDescriber,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    id: [{
      type: Input,
      args: ["mat-sort-header"]
    }],
    arrowPosition: [{
      type: Input
    }],
    start: [{
      type: Input
    }],
    sortActionDescription: [{
      type: Input
    }],
    disableClear: [{
      type: Input
    }]
  });
})();
var MatSortModule = class {
};
MatSortModule.ɵfac = function MatSortModule_Factory(ɵt) {
  return new (ɵt || MatSortModule)();
};
MatSortModule.ɵmod = ɵɵdefineNgModule({
  type: MatSortModule,
  declarations: [MatSort, MatSortHeader],
  imports: [CommonModule, MatCommonModule],
  exports: [MatSort, MatSortHeader]
});
MatSortModule.ɵinj = ɵɵdefineInjector({
  providers: [MAT_SORT_HEADER_INTL_PROVIDER],
  imports: [[CommonModule, MatCommonModule]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSortModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, MatCommonModule],
      exports: [MatSort, MatSortHeader],
      declarations: [MatSort, MatSortHeader],
      providers: [MAT_SORT_HEADER_INTL_PROVIDER]
    }]
  }], null, null);
})();

// node_modules/@angular/material/fesm2020/snack-bar.mjs
function SimpleSnackBar_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 2)(1, "button", 3);
    ɵɵlistener("click", function SimpleSnackBar_div_2_Template_button_click_1_listener() {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.action());
    });
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate(ctx_r1.data.action);
  }
}
function MatSnackBarContainer_ng_template_1_Template(rf, ctx) {
}
var MAT_SNACK_BAR_DATA = new InjectionToken("MatSnackBarData");
var MatSnackBarConfig = class {
  constructor() {
    this.politeness = "assertive";
    this.announcementMessage = "";
    this.duration = 0;
    this.data = null;
    this.horizontalPosition = "center";
    this.verticalPosition = "bottom";
  }
};
var MAX_TIMEOUT = Math.pow(2, 31) - 1;
var MatSnackBarRef = class {
  constructor(containerInstance, _overlayRef) {
    this._overlayRef = _overlayRef;
    this._afterDismissed = new Subject();
    this._afterOpened = new Subject();
    this._onAction = new Subject();
    this._dismissedByAction = false;
    this.containerInstance = containerInstance;
    containerInstance._onExit.subscribe(() => this._finishDismiss());
  }
  /** Dismisses the snack bar. */
  dismiss() {
    if (!this._afterDismissed.closed) {
      this.containerInstance.exit();
    }
    clearTimeout(this._durationTimeoutId);
  }
  /** Marks the snackbar action clicked. */
  dismissWithAction() {
    if (!this._onAction.closed) {
      this._dismissedByAction = true;
      this._onAction.next();
      this._onAction.complete();
      this.dismiss();
    }
    clearTimeout(this._durationTimeoutId);
  }
  /**
   * Marks the snackbar action clicked.
   * @deprecated Use `dismissWithAction` instead.
   * @breaking-change 8.0.0
   */
  closeWithAction() {
    this.dismissWithAction();
  }
  /** Dismisses the snack bar after some duration */
  _dismissAfter(duration) {
    this._durationTimeoutId = setTimeout(() => this.dismiss(), Math.min(duration, MAX_TIMEOUT));
  }
  /** Marks the snackbar as opened */
  _open() {
    if (!this._afterOpened.closed) {
      this._afterOpened.next();
      this._afterOpened.complete();
    }
  }
  /** Cleans up the DOM after closing. */
  _finishDismiss() {
    this._overlayRef.dispose();
    if (!this._onAction.closed) {
      this._onAction.complete();
    }
    this._afterDismissed.next({
      dismissedByAction: this._dismissedByAction
    });
    this._afterDismissed.complete();
    this._dismissedByAction = false;
  }
  /** Gets an observable that is notified when the snack bar is finished closing. */
  afterDismissed() {
    return this._afterDismissed;
  }
  /** Gets an observable that is notified when the snack bar has opened and appeared. */
  afterOpened() {
    return this.containerInstance._onEnter;
  }
  /** Gets an observable that is notified when the snack bar action is called. */
  onAction() {
    return this._onAction;
  }
};
var SimpleSnackBar = class {
  constructor(snackBarRef, data) {
    this.snackBarRef = snackBarRef;
    this.data = data;
  }
  /** Performs the action on the snack bar. */
  action() {
    this.snackBarRef.dismissWithAction();
  }
  /** If the action button should be shown. */
  get hasAction() {
    return !!this.data.action;
  }
};
SimpleSnackBar.ɵfac = function SimpleSnackBar_Factory(ɵt) {
  return new (ɵt || SimpleSnackBar)(ɵɵdirectiveInject(MatSnackBarRef), ɵɵdirectiveInject(MAT_SNACK_BAR_DATA));
};
SimpleSnackBar.ɵcmp = ɵɵdefineComponent({
  type: SimpleSnackBar,
  selectors: [["simple-snack-bar"]],
  hostAttrs: [1, "mat-simple-snackbar"],
  decls: 3,
  vars: 2,
  consts: [[1, "mat-simple-snack-bar-content"], ["class", "mat-simple-snackbar-action", 4, "ngIf"], [1, "mat-simple-snackbar-action"], ["mat-button", "", 3, "click"]],
  template: function SimpleSnackBar_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "span", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
      ɵɵtemplate(2, SimpleSnackBar_div_2_Template, 3, 1, "div", 1);
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate(ctx.data.message);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.hasAction);
    }
  },
  dependencies: [MatButton, NgIf],
  styles: [".mat-simple-snackbar{display:flex;justify-content:space-between;align-items:center;line-height:20px;opacity:1}.mat-simple-snackbar-action{flex-shrink:0;margin:-8px -8px -8px 8px}.mat-simple-snackbar-action button{max-height:36px;min-width:0}[dir=rtl] .mat-simple-snackbar-action{margin-left:-8px;margin-right:8px}.mat-simple-snack-bar-content{overflow:hidden;text-overflow:ellipsis}\n"],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SimpleSnackBar, [{
    type: Component,
    args: [{
      selector: "simple-snack-bar",
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        "class": "mat-simple-snackbar"
      },
      template: '<span class="mat-simple-snack-bar-content">{{data.message}}</span>\n<div class="mat-simple-snackbar-action"  *ngIf="hasAction">\n  <button mat-button (click)="action()">{{data.action}}</button>\n</div>\n',
      styles: [".mat-simple-snackbar{display:flex;justify-content:space-between;align-items:center;line-height:20px;opacity:1}.mat-simple-snackbar-action{flex-shrink:0;margin:-8px -8px -8px 8px}.mat-simple-snackbar-action button{max-height:36px;min-width:0}[dir=rtl] .mat-simple-snackbar-action{margin-left:-8px;margin-right:8px}.mat-simple-snack-bar-content{overflow:hidden;text-overflow:ellipsis}\n"]
    }]
  }], function() {
    return [{
      type: MatSnackBarRef
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [MAT_SNACK_BAR_DATA]
      }]
    }];
  }, null);
})();
var matSnackBarAnimations = {
  /** Animation that shows and hides a snack bar. */
  snackBarState: trigger("state", [state("void, hidden", style({
    transform: "scale(0.8)",
    opacity: 0
  })), state("visible", style({
    transform: "scale(1)",
    opacity: 1
  })), transition("* => visible", animate("150ms cubic-bezier(0, 0, 0.2, 1)")), transition("* => void, * => hidden", animate("75ms cubic-bezier(0.4, 0.0, 1, 1)", style({
    opacity: 0
  })))])
};
var MatSnackBarContainer = class extends BasePortalOutlet {
  constructor(_ngZone, _elementRef, _changeDetectorRef, _platform, snackBarConfig) {
    super();
    this._ngZone = _ngZone;
    this._elementRef = _elementRef;
    this._changeDetectorRef = _changeDetectorRef;
    this._platform = _platform;
    this.snackBarConfig = snackBarConfig;
    this._announceDelay = 150;
    this._destroyed = false;
    this._onAnnounce = new Subject();
    this._onExit = new Subject();
    this._onEnter = new Subject();
    this._animationState = "void";
    this.attachDomPortal = (portal) => {
      this._assertNotAttached();
      this._applySnackBarClasses();
      return this._portalOutlet.attachDomPortal(portal);
    };
    if (snackBarConfig.politeness === "assertive" && !snackBarConfig.announcementMessage) {
      this._live = "assertive";
    } else if (snackBarConfig.politeness === "off") {
      this._live = "off";
    } else {
      this._live = "polite";
    }
    if (this._platform.FIREFOX) {
      if (this._live === "polite") {
        this._role = "status";
      }
      if (this._live === "assertive") {
        this._role = "alert";
      }
    }
  }
  /** Attach a component portal as content to this snack bar container. */
  attachComponentPortal(portal) {
    this._assertNotAttached();
    this._applySnackBarClasses();
    return this._portalOutlet.attachComponentPortal(portal);
  }
  /** Attach a template portal as content to this snack bar container. */
  attachTemplatePortal(portal) {
    this._assertNotAttached();
    this._applySnackBarClasses();
    return this._portalOutlet.attachTemplatePortal(portal);
  }
  /** Handle end of animations, updating the state of the snackbar. */
  onAnimationEnd(event) {
    const {
      fromState,
      toState
    } = event;
    if (toState === "void" && fromState !== "void" || toState === "hidden") {
      this._completeExit();
    }
    if (toState === "visible") {
      const onEnter = this._onEnter;
      this._ngZone.run(() => {
        onEnter.next();
        onEnter.complete();
      });
    }
  }
  /** Begin animation of snack bar entrance into view. */
  enter() {
    if (!this._destroyed) {
      this._animationState = "visible";
      this._changeDetectorRef.detectChanges();
      this._screenReaderAnnounce();
    }
  }
  /** Begin animation of the snack bar exiting from view. */
  exit() {
    this._ngZone.run(() => {
      this._animationState = "hidden";
      this._elementRef.nativeElement.setAttribute("mat-exit", "");
      clearTimeout(this._announceTimeoutId);
    });
    return this._onExit;
  }
  /** Makes sure the exit callbacks have been invoked when the element is destroyed. */
  ngOnDestroy() {
    this._destroyed = true;
    this._completeExit();
  }
  /**
   * Waits for the zone to settle before removing the element. Helps prevent
   * errors where we end up removing an element which is in the middle of an animation.
   */
  _completeExit() {
    this._ngZone.onMicrotaskEmpty.pipe(take(1)).subscribe(() => {
      this._ngZone.run(() => {
        this._onExit.next();
        this._onExit.complete();
      });
    });
  }
  /** Applies the various positioning and user-configured CSS classes to the snack bar. */
  _applySnackBarClasses() {
    const element = this._elementRef.nativeElement;
    const panelClasses = this.snackBarConfig.panelClass;
    if (panelClasses) {
      if (Array.isArray(panelClasses)) {
        panelClasses.forEach((cssClass) => element.classList.add(cssClass));
      } else {
        element.classList.add(panelClasses);
      }
    }
    if (this.snackBarConfig.horizontalPosition === "center") {
      element.classList.add("mat-snack-bar-center");
    }
    if (this.snackBarConfig.verticalPosition === "top") {
      element.classList.add("mat-snack-bar-top");
    }
  }
  /** Asserts that no content is already attached to the container. */
  _assertNotAttached() {
    if (this._portalOutlet.hasAttached() && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("Attempting to attach snack bar content after content is already attached");
    }
  }
  /**
   * Starts a timeout to move the snack bar content to the live region so screen readers will
   * announce it.
   */
  _screenReaderAnnounce() {
    if (!this._announceTimeoutId) {
      this._ngZone.runOutsideAngular(() => {
        this._announceTimeoutId = setTimeout(() => {
          const inertElement = this._elementRef.nativeElement.querySelector("[aria-hidden]");
          const liveElement = this._elementRef.nativeElement.querySelector("[aria-live]");
          if (inertElement && liveElement) {
            let focusedElement = null;
            if (this._platform.isBrowser && document.activeElement instanceof HTMLElement && inertElement.contains(document.activeElement)) {
              focusedElement = document.activeElement;
            }
            inertElement.removeAttribute("aria-hidden");
            liveElement.appendChild(inertElement);
            focusedElement?.focus();
            this._onAnnounce.next();
            this._onAnnounce.complete();
          }
        }, this._announceDelay);
      });
    }
  }
};
MatSnackBarContainer.ɵfac = function MatSnackBarContainer_Factory(ɵt) {
  return new (ɵt || MatSnackBarContainer)(ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Platform), ɵɵdirectiveInject(MatSnackBarConfig));
};
MatSnackBarContainer.ɵcmp = ɵɵdefineComponent({
  type: MatSnackBarContainer,
  selectors: [["snack-bar-container"]],
  viewQuery: function MatSnackBarContainer_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(CdkPortalOutlet, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._portalOutlet = _t.first);
    }
  },
  hostAttrs: [1, "mat-snack-bar-container"],
  hostVars: 1,
  hostBindings: function MatSnackBarContainer_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵsyntheticHostListener("@state.done", function MatSnackBarContainer_animation_state_done_HostBindingHandler($event) {
        return ctx.onAnimationEnd($event);
      });
    }
    if (rf & 2) {
      ɵɵsyntheticHostProperty("@state", ctx._animationState);
    }
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 3,
  vars: 2,
  consts: [["aria-hidden", "true"], ["cdkPortalOutlet", ""]],
  template: function MatSnackBarContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 0);
      ɵɵtemplate(1, MatSnackBarContainer_ng_template_1_Template, 0, 0, "ng-template", 1);
      ɵɵelementEnd();
      ɵɵelement(2, "div");
    }
    if (rf & 2) {
      ɵɵadvance(2);
      ɵɵattribute("aria-live", ctx._live)("role", ctx._role);
    }
  },
  dependencies: [CdkPortalOutlet],
  styles: [".mat-snack-bar-container{border-radius:4px;box-sizing:border-box;display:block;margin:24px;max-width:33vw;min-width:344px;padding:14px 16px;min-height:48px;transform-origin:center}.cdk-high-contrast-active .mat-snack-bar-container{border:solid 1px}.mat-snack-bar-handset{width:100%}.mat-snack-bar-handset .mat-snack-bar-container{margin:8px;max-width:100%;min-width:0;width:100%}\n"],
  encapsulation: 2,
  data: {
    animation: [matSnackBarAnimations.snackBarState]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSnackBarContainer, [{
    type: Component,
    args: [{
      selector: "snack-bar-container",
      changeDetection: ChangeDetectionStrategy.Default,
      encapsulation: ViewEncapsulation$1.None,
      animations: [matSnackBarAnimations.snackBarState],
      host: {
        "class": "mat-snack-bar-container",
        "[@state]": "_animationState",
        "(@state.done)": "onAnimationEnd($event)"
      },
      template: '<!-- Initially holds the snack bar content, will be empty after announcing to screen readers. -->\n<div aria-hidden="true">\n  <ng-template cdkPortalOutlet></ng-template>\n</div>\n\n<!-- Will receive the snack bar content from the non-live div, move will happen a short delay after opening -->\n<div [attr.aria-live]="_live" [attr.role]="_role"></div>\n',
      styles: [".mat-snack-bar-container{border-radius:4px;box-sizing:border-box;display:block;margin:24px;max-width:33vw;min-width:344px;padding:14px 16px;min-height:48px;transform-origin:center}.cdk-high-contrast-active .mat-snack-bar-container{border:solid 1px}.mat-snack-bar-handset{width:100%}.mat-snack-bar-handset .mat-snack-bar-container{margin:8px;max-width:100%;min-width:0;width:100%}\n"]
    }]
  }], function() {
    return [{
      type: NgZone
    }, {
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: Platform
    }, {
      type: MatSnackBarConfig
    }];
  }, {
    _portalOutlet: [{
      type: ViewChild,
      args: [CdkPortalOutlet, {
        static: true
      }]
    }]
  });
})();
var MatSnackBarModule = class {
};
MatSnackBarModule.ɵfac = function MatSnackBarModule_Factory(ɵt) {
  return new (ɵt || MatSnackBarModule)();
};
MatSnackBarModule.ɵmod = ɵɵdefineNgModule({
  type: MatSnackBarModule,
  declarations: [MatSnackBarContainer, SimpleSnackBar],
  imports: [OverlayModule, PortalModule, CommonModule, MatButtonModule, MatCommonModule],
  exports: [MatSnackBarContainer, MatCommonModule]
});
MatSnackBarModule.ɵinj = ɵɵdefineInjector({
  imports: [[OverlayModule, PortalModule, CommonModule, MatButtonModule, MatCommonModule], MatCommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSnackBarModule, [{
    type: NgModule,
    args: [{
      imports: [OverlayModule, PortalModule, CommonModule, MatButtonModule, MatCommonModule],
      exports: [MatSnackBarContainer, MatCommonModule],
      declarations: [MatSnackBarContainer, SimpleSnackBar]
    }]
  }], null, null);
})();
var MAT_SNACK_BAR_DEFAULT_OPTIONS = new InjectionToken("mat-snack-bar-default-options", {
  providedIn: "root",
  factory: MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY
});
function MAT_SNACK_BAR_DEFAULT_OPTIONS_FACTORY() {
  return new MatSnackBarConfig();
}
var _MatSnackBarBase = class {
  constructor(_overlay, _live, _injector, _breakpointObserver, _parentSnackBar, _defaultConfig) {
    this._overlay = _overlay;
    this._live = _live;
    this._injector = _injector;
    this._breakpointObserver = _breakpointObserver;
    this._parentSnackBar = _parentSnackBar;
    this._defaultConfig = _defaultConfig;
    this._snackBarRefAtThisLevel = null;
  }
  /** Reference to the currently opened snackbar at *any* level. */
  get _openedSnackBarRef() {
    const parent = this._parentSnackBar;
    return parent ? parent._openedSnackBarRef : this._snackBarRefAtThisLevel;
  }
  set _openedSnackBarRef(value) {
    if (this._parentSnackBar) {
      this._parentSnackBar._openedSnackBarRef = value;
    } else {
      this._snackBarRefAtThisLevel = value;
    }
  }
  /**
   * Creates and dispatches a snack bar with a custom component for the content, removing any
   * currently opened snack bars.
   *
   * @param component Component to be instantiated.
   * @param config Extra configuration for the snack bar.
   */
  openFromComponent(component, config) {
    return this._attach(component, config);
  }
  /**
   * Creates and dispatches a snack bar with a custom template for the content, removing any
   * currently opened snack bars.
   *
   * @param template Template to be instantiated.
   * @param config Extra configuration for the snack bar.
   */
  openFromTemplate(template, config) {
    return this._attach(template, config);
  }
  /**
   * Opens a snackbar with a message and an optional action.
   * @param message The message to show in the snackbar.
   * @param action The label for the snackbar action.
   * @param config Additional configuration options for the snackbar.
   */
  open(message, action = "", config) {
    const _config = __spreadValues(__spreadValues({}, this._defaultConfig), config);
    _config.data = {
      message,
      action
    };
    if (_config.announcementMessage === message) {
      _config.announcementMessage = void 0;
    }
    return this.openFromComponent(this.simpleSnackBarComponent, _config);
  }
  /**
   * Dismisses the currently-visible snack bar.
   */
  dismiss() {
    if (this._openedSnackBarRef) {
      this._openedSnackBarRef.dismiss();
    }
  }
  ngOnDestroy() {
    if (this._snackBarRefAtThisLevel) {
      this._snackBarRefAtThisLevel.dismiss();
    }
  }
  /**
   * Attaches the snack bar container component to the overlay.
   */
  _attachSnackBarContainer(overlayRef, config) {
    const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
    const injector = Injector.create({
      parent: userInjector || this._injector,
      providers: [{
        provide: MatSnackBarConfig,
        useValue: config
      }]
    });
    const containerPortal = new ComponentPortal(this.snackBarContainerComponent, config.viewContainerRef, injector);
    const containerRef = overlayRef.attach(containerPortal);
    containerRef.instance.snackBarConfig = config;
    return containerRef.instance;
  }
  /**
   * Places a new component or a template as the content of the snack bar container.
   */
  _attach(content, userConfig) {
    const config = __spreadValues(__spreadValues(__spreadValues({}, new MatSnackBarConfig()), this._defaultConfig), userConfig);
    const overlayRef = this._createOverlay(config);
    const container = this._attachSnackBarContainer(overlayRef, config);
    const snackBarRef = new MatSnackBarRef(container, overlayRef);
    if (content instanceof TemplateRef) {
      const portal = new TemplatePortal(content, null, {
        $implicit: config.data,
        snackBarRef
      });
      snackBarRef.instance = container.attachTemplatePortal(portal);
    } else {
      const injector = this._createInjector(config, snackBarRef);
      const portal = new ComponentPortal(content, void 0, injector);
      const contentRef = container.attachComponentPortal(portal);
      snackBarRef.instance = contentRef.instance;
    }
    this._breakpointObserver.observe(Breakpoints.HandsetPortrait).pipe(takeUntil(overlayRef.detachments())).subscribe((state2) => {
      overlayRef.overlayElement.classList.toggle(this.handsetCssClass, state2.matches);
    });
    if (config.announcementMessage) {
      container._onAnnounce.subscribe(() => {
        this._live.announce(config.announcementMessage, config.politeness);
      });
    }
    this._animateSnackBar(snackBarRef, config);
    this._openedSnackBarRef = snackBarRef;
    return this._openedSnackBarRef;
  }
  /** Animates the old snack bar out and the new one in. */
  _animateSnackBar(snackBarRef, config) {
    snackBarRef.afterDismissed().subscribe(() => {
      if (this._openedSnackBarRef == snackBarRef) {
        this._openedSnackBarRef = null;
      }
      if (config.announcementMessage) {
        this._live.clear();
      }
    });
    if (this._openedSnackBarRef) {
      this._openedSnackBarRef.afterDismissed().subscribe(() => {
        snackBarRef.containerInstance.enter();
      });
      this._openedSnackBarRef.dismiss();
    } else {
      snackBarRef.containerInstance.enter();
    }
    if (config.duration && config.duration > 0) {
      snackBarRef.afterOpened().subscribe(() => snackBarRef._dismissAfter(config.duration));
    }
  }
  /**
   * Creates a new overlay and places it in the correct location.
   * @param config The user-specified snack bar config.
   */
  _createOverlay(config) {
    const overlayConfig = new OverlayConfig();
    overlayConfig.direction = config.direction;
    let positionStrategy = this._overlay.position().global();
    const isRtl = config.direction === "rtl";
    const isLeft = config.horizontalPosition === "left" || config.horizontalPosition === "start" && !isRtl || config.horizontalPosition === "end" && isRtl;
    const isRight = !isLeft && config.horizontalPosition !== "center";
    if (isLeft) {
      positionStrategy.left("0");
    } else if (isRight) {
      positionStrategy.right("0");
    } else {
      positionStrategy.centerHorizontally();
    }
    if (config.verticalPosition === "top") {
      positionStrategy.top("0");
    } else {
      positionStrategy.bottom("0");
    }
    overlayConfig.positionStrategy = positionStrategy;
    return this._overlay.create(overlayConfig);
  }
  /**
   * Creates an injector to be used inside of a snack bar component.
   * @param config Config that was used to create the snack bar.
   * @param snackBarRef Reference to the snack bar.
   */
  _createInjector(config, snackBarRef) {
    const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
    return Injector.create({
      parent: userInjector || this._injector,
      providers: [{
        provide: MatSnackBarRef,
        useValue: snackBarRef
      }, {
        provide: MAT_SNACK_BAR_DATA,
        useValue: config.data
      }]
    });
  }
};
_MatSnackBarBase.ɵfac = function _MatSnackBarBase_Factory(ɵt) {
  return new (ɵt || _MatSnackBarBase)(ɵɵinject(Overlay), ɵɵinject(LiveAnnouncer), ɵɵinject(Injector), ɵɵinject(BreakpointObserver), ɵɵinject(_MatSnackBarBase, 12), ɵɵinject(MAT_SNACK_BAR_DEFAULT_OPTIONS));
};
_MatSnackBarBase.ɵprov = ɵɵdefineInjectable({
  token: _MatSnackBarBase,
  factory: _MatSnackBarBase.ɵfac
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_MatSnackBarBase, [{
    type: Injectable
  }], function() {
    return [{
      type: Overlay
    }, {
      type: LiveAnnouncer
    }, {
      type: Injector
    }, {
      type: BreakpointObserver
    }, {
      type: _MatSnackBarBase,
      decorators: [{
        type: Optional
      }, {
        type: SkipSelf
      }]
    }, {
      type: MatSnackBarConfig,
      decorators: [{
        type: Inject,
        args: [MAT_SNACK_BAR_DEFAULT_OPTIONS]
      }]
    }];
  }, null);
})();
var MatSnackBar = class extends _MatSnackBarBase {
  constructor(overlay, live, injector, breakpointObserver, parentSnackBar, defaultConfig) {
    super(overlay, live, injector, breakpointObserver, parentSnackBar, defaultConfig);
    this.simpleSnackBarComponent = SimpleSnackBar;
    this.snackBarContainerComponent = MatSnackBarContainer;
    this.handsetCssClass = "mat-snack-bar-handset";
  }
};
MatSnackBar.ɵfac = function MatSnackBar_Factory(ɵt) {
  return new (ɵt || MatSnackBar)(ɵɵinject(Overlay), ɵɵinject(LiveAnnouncer), ɵɵinject(Injector), ɵɵinject(BreakpointObserver), ɵɵinject(MatSnackBar, 12), ɵɵinject(MAT_SNACK_BAR_DEFAULT_OPTIONS));
};
MatSnackBar.ɵprov = ɵɵdefineInjectable({
  token: MatSnackBar,
  factory: MatSnackBar.ɵfac,
  providedIn: MatSnackBarModule
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSnackBar, [{
    type: Injectable,
    args: [{
      providedIn: MatSnackBarModule
    }]
  }], function() {
    return [{
      type: Overlay
    }, {
      type: LiveAnnouncer
    }, {
      type: Injector
    }, {
      type: BreakpointObserver
    }, {
      type: MatSnackBar,
      decorators: [{
        type: Optional
      }, {
        type: SkipSelf
      }]
    }, {
      type: MatSnackBarConfig,
      decorators: [{
        type: Inject,
        args: [MAT_SNACK_BAR_DEFAULT_OPTIONS]
      }]
    }];
  }, null);
})();

// node_modules/@angular/material/fesm2020/slide-toggle.mjs
var _c03 = ["thumbContainer"];
var _c12 = ["toggleBar"];
var _c2 = ["input"];
var _c3 = ["*"];
var _c4 = (a0) => ({
  enterDuration: a0
});
var MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS = new InjectionToken("mat-slide-toggle-default-options", {
  providedIn: "root",
  factory: () => ({
    disableToggleValue: false
  })
});
var nextUniqueId = 0;
var MAT_SLIDE_TOGGLE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => MatSlideToggle),
  multi: true
};
var MatSlideToggleChange = class {
  constructor(source, checked) {
    this.source = source;
    this.checked = checked;
  }
};
var _MatSlideToggleBase = mixinTabIndex(mixinColor(mixinDisableRipple(mixinDisabled(class {
  constructor(_elementRef) {
    this._elementRef = _elementRef;
  }
}))));
var MatSlideToggle = class extends _MatSlideToggleBase {
  constructor(elementRef, _focusMonitor, _changeDetectorRef, tabIndex, defaults, animationMode) {
    super(elementRef);
    this._focusMonitor = _focusMonitor;
    this._changeDetectorRef = _changeDetectorRef;
    this.defaults = defaults;
    this._onChange = (_) => {
    };
    this._onTouched = () => {
    };
    this._uniqueId = `mat-slide-toggle-${++nextUniqueId}`;
    this._required = false;
    this._checked = false;
    this.name = null;
    this.id = this._uniqueId;
    this.labelPosition = "after";
    this.ariaLabel = null;
    this.ariaLabelledby = null;
    this.change = new EventEmitter();
    this.toggleChange = new EventEmitter();
    this.tabIndex = parseInt(tabIndex) || 0;
    this.color = this.defaultColor = defaults.color || "accent";
    this._noopAnimations = animationMode === "NoopAnimations";
  }
  /** Whether the slide-toggle is required. */
  get required() {
    return this._required;
  }
  set required(value) {
    this._required = coerceBooleanProperty(value);
  }
  /** Whether the slide-toggle element is checked or not. */
  get checked() {
    return this._checked;
  }
  set checked(value) {
    this._checked = coerceBooleanProperty(value);
    this._changeDetectorRef.markForCheck();
  }
  /** Returns the unique id for the visual hidden input. */
  get inputId() {
    return `${this.id || this._uniqueId}-input`;
  }
  ngAfterContentInit() {
    this._focusMonitor.monitor(this._elementRef, true).subscribe((focusOrigin) => {
      if (!focusOrigin) {
        Promise.resolve().then(() => this._onTouched());
      }
    });
  }
  ngOnDestroy() {
    this._focusMonitor.stopMonitoring(this._elementRef);
  }
  /** Method being called whenever the underlying input emits a change event. */
  _onChangeEvent(event) {
    event.stopPropagation();
    this.toggleChange.emit();
    if (this.defaults.disableToggleValue) {
      this._inputElement.nativeElement.checked = this.checked;
      return;
    }
    this.checked = this._inputElement.nativeElement.checked;
    this._emitChangeEvent();
  }
  /** Method being called whenever the slide-toggle has been clicked. */
  _onInputClick(event) {
    event.stopPropagation();
  }
  /** Implemented as part of ControlValueAccessor. */
  writeValue(value) {
    this.checked = !!value;
  }
  /** Implemented as part of ControlValueAccessor. */
  registerOnChange(fn) {
    this._onChange = fn;
  }
  /** Implemented as part of ControlValueAccessor. */
  registerOnTouched(fn) {
    this._onTouched = fn;
  }
  /** Implemented as a part of ControlValueAccessor. */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this._changeDetectorRef.markForCheck();
  }
  /** Focuses the slide-toggle. */
  focus(options, origin) {
    if (origin) {
      this._focusMonitor.focusVia(this._inputElement, origin, options);
    } else {
      this._inputElement.nativeElement.focus(options);
    }
  }
  /** Toggles the checked state of the slide-toggle. */
  toggle() {
    this.checked = !this.checked;
    this._onChange(this.checked);
  }
  /**
   * Emits a change event on the `change` output. Also notifies the FormControl about the change.
   */
  _emitChangeEvent() {
    this._onChange(this.checked);
    this.change.emit(new MatSlideToggleChange(this, this.checked));
  }
  /** Method being called whenever the label text changes. */
  _onLabelTextChange() {
    this._changeDetectorRef.detectChanges();
  }
};
MatSlideToggle.ɵfac = function MatSlideToggle_Factory(ɵt) {
  return new (ɵt || MatSlideToggle)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(FocusMonitor), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵinjectAttribute("tabindex"), ɵɵdirectiveInject(MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS), ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8));
};
MatSlideToggle.ɵcmp = ɵɵdefineComponent({
  type: MatSlideToggle,
  selectors: [["mat-slide-toggle"]],
  viewQuery: function MatSlideToggle_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c03, 5);
      ɵɵviewQuery(_c12, 5);
      ɵɵviewQuery(_c2, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._thumbEl = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._thumbBarEl = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._inputElement = _t.first);
    }
  },
  hostAttrs: [1, "mat-slide-toggle"],
  hostVars: 13,
  hostBindings: function MatSlideToggle_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵhostProperty("id", ctx.id);
      ɵɵattribute("tabindex", null)("aria-label", null)("aria-labelledby", null)("name", null);
      ɵɵclassProp("mat-checked", ctx.checked)("mat-disabled", ctx.disabled)("mat-slide-toggle-label-before", ctx.labelPosition == "before")("_mat-animation-noopable", ctx._noopAnimations);
    }
  },
  inputs: {
    disabled: "disabled",
    disableRipple: "disableRipple",
    color: "color",
    tabIndex: "tabIndex",
    name: "name",
    id: "id",
    labelPosition: "labelPosition",
    ariaLabel: [0, "aria-label", "ariaLabel"],
    ariaLabelledby: [0, "aria-labelledby", "ariaLabelledby"],
    ariaDescribedby: [0, "aria-describedby", "ariaDescribedby"],
    required: "required",
    checked: "checked"
  },
  outputs: {
    change: "change",
    toggleChange: "toggleChange"
  },
  exportAs: ["matSlideToggle"],
  features: [ɵɵProvidersFeature([MAT_SLIDE_TOGGLE_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c3,
  decls: 16,
  vars: 20,
  consts: [["label", ""], ["toggleBar", ""], ["input", ""], ["thumbContainer", ""], ["labelContent", ""], [1, "mat-slide-toggle-label"], [1, "mat-slide-toggle-bar"], ["type", "checkbox", "role", "switch", 1, "mat-slide-toggle-input", "cdk-visually-hidden", 3, "change", "click", "id", "required", "tabIndex", "checked", "disabled"], [1, "mat-slide-toggle-thumb-container"], [1, "mat-slide-toggle-thumb"], ["mat-ripple", "", 1, "mat-slide-toggle-ripple", "mat-focus-indicator", 3, "matRippleTrigger", "matRippleDisabled", "matRippleCentered", "matRippleRadius", "matRippleAnimation"], [1, "mat-ripple-element", "mat-slide-toggle-persistent-ripple"], [1, "mat-slide-toggle-content", 3, "cdkObserveContent"], [2, "display", "none"]],
  template: function MatSlideToggle_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵelementStart(0, "label", 5, 0)(2, "span", 6, 1)(4, "input", 7, 2);
      ɵɵlistener("change", function MatSlideToggle_Template_input_change_4_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._onChangeEvent($event));
      })("click", function MatSlideToggle_Template_input_click_4_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._onInputClick($event));
      });
      ɵɵelementEnd();
      ɵɵelementStart(6, "span", 8, 3);
      ɵɵelement(8, "span", 9);
      ɵɵelementStart(9, "span", 10);
      ɵɵelement(10, "span", 11);
      ɵɵelementEnd()()();
      ɵɵelementStart(11, "span", 12, 4);
      ɵɵlistener("cdkObserveContent", function MatSlideToggle_Template_span_cdkObserveContent_11_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._onLabelTextChange());
      });
      ɵɵelementStart(13, "span", 13);
      ɵɵtext(14, " ");
      ɵɵelementEnd();
      ɵɵprojection(15);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      const label_r2 = ɵɵreference(1);
      const labelContent_r3 = ɵɵreference(12);
      ɵɵattribute("for", ctx.inputId);
      ɵɵadvance(2);
      ɵɵclassProp("mat-slide-toggle-bar-no-side-margin", !labelContent_r3.textContent || !labelContent_r3.textContent.trim());
      ɵɵadvance(2);
      ɵɵproperty("id", ctx.inputId)("required", ctx.required)("tabIndex", ctx.tabIndex)("checked", ctx.checked)("disabled", ctx.disabled);
      ɵɵattribute("name", ctx.name)("aria-checked", ctx.checked)("aria-label", ctx.ariaLabel)("aria-labelledby", ctx.ariaLabelledby)("aria-describedby", ctx.ariaDescribedby);
      ɵɵadvance(5);
      ɵɵproperty("matRippleTrigger", label_r2)("matRippleDisabled", ctx.disableRipple || ctx.disabled)("matRippleCentered", true)("matRippleRadius", 20)("matRippleAnimation", ɵɵpureFunction1(18, _c4, ctx._noopAnimations ? 0 : 150));
    }
  },
  dependencies: [MatRipple, CdkObserveContent],
  styles: [".mat-slide-toggle{display:inline-block;height:24px;max-width:100%;line-height:24px;white-space:nowrap;outline:none;-webkit-tap-highlight-color:transparent}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(16px, 0, 0)}[dir=rtl] .mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(-16px, 0, 0)}.mat-slide-toggle.mat-disabled{opacity:.38}.mat-slide-toggle.mat-disabled .mat-slide-toggle-label,.mat-slide-toggle.mat-disabled .mat-slide-toggle-thumb-container{cursor:default}.mat-slide-toggle-label{-webkit-user-select:none;user-select:none;display:flex;flex:1;flex-direction:row;align-items:center;height:inherit;cursor:pointer}.mat-slide-toggle-content{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-slide-toggle-label-before .mat-slide-toggle-label{order:1}.mat-slide-toggle-label-before .mat-slide-toggle-bar{order:2}[dir=rtl] .mat-slide-toggle-label-before .mat-slide-toggle-bar,.mat-slide-toggle-bar{margin-right:8px;margin-left:0}[dir=rtl] .mat-slide-toggle-bar,.mat-slide-toggle-label-before .mat-slide-toggle-bar{margin-left:8px;margin-right:0}.mat-slide-toggle-bar-no-side-margin{margin-left:0;margin-right:0}.mat-slide-toggle-thumb-container{position:absolute;z-index:1;width:20px;height:20px;top:-3px;left:0;transform:translate3d(0, 0, 0);transition:all 80ms linear;transition-property:transform}._mat-animation-noopable .mat-slide-toggle-thumb-container{transition:none}[dir=rtl] .mat-slide-toggle-thumb-container{left:auto;right:0}.mat-slide-toggle-thumb{height:20px;width:20px;border-radius:50%;display:block}.mat-slide-toggle-bar{position:relative;width:36px;height:14px;flex-shrink:0;border-radius:8px}.mat-slide-toggle-input{bottom:0;left:10px}[dir=rtl] .mat-slide-toggle-input{left:auto;right:10px}.mat-slide-toggle-bar,.mat-slide-toggle-thumb{transition:all 80ms linear;transition-property:background-color;transition-delay:50ms}._mat-animation-noopable .mat-slide-toggle-bar,._mat-animation-noopable .mat-slide-toggle-thumb{transition:none}.mat-slide-toggle .mat-slide-toggle-ripple{position:absolute;top:calc(50% - 20px);left:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-slide-toggle .mat-slide-toggle-ripple .mat-ripple-element:not(.mat-slide-toggle-persistent-ripple){opacity:.12}.mat-slide-toggle-persistent-ripple{width:100%;height:100%;transform:none}.mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:.04}.mat-slide-toggle:not(.mat-disabled).cdk-keyboard-focused .mat-slide-toggle-persistent-ripple{opacity:.12}.mat-slide-toggle-persistent-ripple,.mat-slide-toggle.mat-disabled .mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:0}@media(hover: none){.mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{display:none}}.cdk-high-contrast-active .mat-slide-toggle-thumb,.cdk-high-contrast-active .mat-slide-toggle-bar{border:1px solid}.cdk-high-contrast-active .mat-slide-toggle.cdk-keyboard-focused .mat-slide-toggle-bar{outline:2px dotted;outline-offset:5px}\n"],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSlideToggle, [{
    type: Component,
    args: [{
      selector: "mat-slide-toggle",
      exportAs: "matSlideToggle",
      host: {
        "class": "mat-slide-toggle",
        "[id]": "id",
        // Needs to be removed since it causes some a11y issues (see #21266).
        "[attr.tabindex]": "null",
        "[attr.aria-label]": "null",
        "[attr.aria-labelledby]": "null",
        "[attr.name]": "null",
        "[class.mat-checked]": "checked",
        "[class.mat-disabled]": "disabled",
        "[class.mat-slide-toggle-label-before]": 'labelPosition == "before"',
        "[class._mat-animation-noopable]": "_noopAnimations"
      },
      providers: [MAT_SLIDE_TOGGLE_VALUE_ACCESSOR],
      inputs: ["disabled", "disableRipple", "color", "tabIndex"],
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<label [attr.for]="inputId" class="mat-slide-toggle-label" #label>\n  <span #toggleBar class="mat-slide-toggle-bar"\n       [class.mat-slide-toggle-bar-no-side-margin]="!labelContent.textContent || !labelContent.textContent.trim()">\n\n    <input #input class="mat-slide-toggle-input cdk-visually-hidden" type="checkbox"\n           role="switch"\n           [id]="inputId"\n           [required]="required"\n           [tabIndex]="tabIndex"\n           [checked]="checked"\n           [disabled]="disabled"\n           [attr.name]="name"\n           [attr.aria-checked]="checked"\n           [attr.aria-label]="ariaLabel"\n           [attr.aria-labelledby]="ariaLabelledby"\n           [attr.aria-describedby]="ariaDescribedby"\n           (change)="_onChangeEvent($event)"\n           (click)="_onInputClick($event)">\n\n    <span class="mat-slide-toggle-thumb-container" #thumbContainer>\n      <span class="mat-slide-toggle-thumb"></span>\n      <span class="mat-slide-toggle-ripple mat-focus-indicator" mat-ripple\n           [matRippleTrigger]="label"\n           [matRippleDisabled]="disableRipple || disabled"\n           [matRippleCentered]="true"\n           [matRippleRadius]="20"\n           [matRippleAnimation]="{enterDuration: _noopAnimations ? 0 : 150}">\n\n        <span class="mat-ripple-element mat-slide-toggle-persistent-ripple"></span>\n      </span>\n    </span>\n\n  </span>\n\n  <span class="mat-slide-toggle-content" #labelContent (cdkObserveContent)="_onLabelTextChange()">\n    <!-- Add an invisible span so JAWS can read the label -->\n    <span style="display:none">&nbsp;</span>\n    <ng-content></ng-content>\n  </span>\n</label>\n',
      styles: [".mat-slide-toggle{display:inline-block;height:24px;max-width:100%;line-height:24px;white-space:nowrap;outline:none;-webkit-tap-highlight-color:transparent}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(16px, 0, 0)}[dir=rtl] .mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(-16px, 0, 0)}.mat-slide-toggle.mat-disabled{opacity:.38}.mat-slide-toggle.mat-disabled .mat-slide-toggle-label,.mat-slide-toggle.mat-disabled .mat-slide-toggle-thumb-container{cursor:default}.mat-slide-toggle-label{-webkit-user-select:none;user-select:none;display:flex;flex:1;flex-direction:row;align-items:center;height:inherit;cursor:pointer}.mat-slide-toggle-content{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-slide-toggle-label-before .mat-slide-toggle-label{order:1}.mat-slide-toggle-label-before .mat-slide-toggle-bar{order:2}[dir=rtl] .mat-slide-toggle-label-before .mat-slide-toggle-bar,.mat-slide-toggle-bar{margin-right:8px;margin-left:0}[dir=rtl] .mat-slide-toggle-bar,.mat-slide-toggle-label-before .mat-slide-toggle-bar{margin-left:8px;margin-right:0}.mat-slide-toggle-bar-no-side-margin{margin-left:0;margin-right:0}.mat-slide-toggle-thumb-container{position:absolute;z-index:1;width:20px;height:20px;top:-3px;left:0;transform:translate3d(0, 0, 0);transition:all 80ms linear;transition-property:transform}._mat-animation-noopable .mat-slide-toggle-thumb-container{transition:none}[dir=rtl] .mat-slide-toggle-thumb-container{left:auto;right:0}.mat-slide-toggle-thumb{height:20px;width:20px;border-radius:50%;display:block}.mat-slide-toggle-bar{position:relative;width:36px;height:14px;flex-shrink:0;border-radius:8px}.mat-slide-toggle-input{bottom:0;left:10px}[dir=rtl] .mat-slide-toggle-input{left:auto;right:10px}.mat-slide-toggle-bar,.mat-slide-toggle-thumb{transition:all 80ms linear;transition-property:background-color;transition-delay:50ms}._mat-animation-noopable .mat-slide-toggle-bar,._mat-animation-noopable .mat-slide-toggle-thumb{transition:none}.mat-slide-toggle .mat-slide-toggle-ripple{position:absolute;top:calc(50% - 20px);left:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-slide-toggle .mat-slide-toggle-ripple .mat-ripple-element:not(.mat-slide-toggle-persistent-ripple){opacity:.12}.mat-slide-toggle-persistent-ripple{width:100%;height:100%;transform:none}.mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:.04}.mat-slide-toggle:not(.mat-disabled).cdk-keyboard-focused .mat-slide-toggle-persistent-ripple{opacity:.12}.mat-slide-toggle-persistent-ripple,.mat-slide-toggle.mat-disabled .mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:0}@media(hover: none){.mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{display:none}}.cdk-high-contrast-active .mat-slide-toggle-thumb,.cdk-high-contrast-active .mat-slide-toggle-bar{border:1px solid}.cdk-high-contrast-active .mat-slide-toggle.cdk-keyboard-focused .mat-slide-toggle-bar{outline:2px dotted;outline-offset:5px}\n"]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: FocusMonitor
    }, {
      type: ChangeDetectorRef
    }, {
      type: void 0,
      decorators: [{
        type: Attribute,
        args: ["tabindex"]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [ANIMATION_MODULE_TYPE]
      }]
    }];
  }, {
    _thumbEl: [{
      type: ViewChild,
      args: ["thumbContainer"]
    }],
    _thumbBarEl: [{
      type: ViewChild,
      args: ["toggleBar"]
    }],
    name: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    labelPosition: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input,
      args: ["aria-label"]
    }],
    ariaLabelledby: [{
      type: Input,
      args: ["aria-labelledby"]
    }],
    ariaDescribedby: [{
      type: Input,
      args: ["aria-describedby"]
    }],
    required: [{
      type: Input
    }],
    checked: [{
      type: Input
    }],
    change: [{
      type: Output
    }],
    toggleChange: [{
      type: Output
    }],
    _inputElement: [{
      type: ViewChild,
      args: ["input"]
    }]
  });
})();
var MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MatSlideToggleRequiredValidator),
  multi: true
};
var MatSlideToggleRequiredValidator = class extends CheckboxRequiredValidator {
};
MatSlideToggleRequiredValidator.ɵfac = /* @__PURE__ */ (() => {
  let ɵMatSlideToggleRequiredValidator_BaseFactory;
  return function MatSlideToggleRequiredValidator_Factory(ɵt) {
    return (ɵMatSlideToggleRequiredValidator_BaseFactory || (ɵMatSlideToggleRequiredValidator_BaseFactory = ɵɵgetInheritedFactory(MatSlideToggleRequiredValidator)))(ɵt || MatSlideToggleRequiredValidator);
  };
})();
MatSlideToggleRequiredValidator.ɵdir = ɵɵdefineDirective({
  type: MatSlideToggleRequiredValidator,
  selectors: [["mat-slide-toggle", "required", "", "formControlName", ""], ["mat-slide-toggle", "required", "", "formControl", ""], ["mat-slide-toggle", "required", "", "ngModel", ""]],
  features: [ɵɵProvidersFeature([MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR]), ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSlideToggleRequiredValidator, [{
    type: Directive,
    args: [{
      selector: `mat-slide-toggle[required][formControlName],
             mat-slide-toggle[required][formControl], mat-slide-toggle[required][ngModel]`,
      providers: [MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR]
    }]
  }], null, null);
})();
var _MatSlideToggleRequiredValidatorModule = class {
};
_MatSlideToggleRequiredValidatorModule.ɵfac = function _MatSlideToggleRequiredValidatorModule_Factory(ɵt) {
  return new (ɵt || _MatSlideToggleRequiredValidatorModule)();
};
_MatSlideToggleRequiredValidatorModule.ɵmod = ɵɵdefineNgModule({
  type: _MatSlideToggleRequiredValidatorModule,
  declarations: [MatSlideToggleRequiredValidator],
  exports: [MatSlideToggleRequiredValidator]
});
_MatSlideToggleRequiredValidatorModule.ɵinj = ɵɵdefineInjector({});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_MatSlideToggleRequiredValidatorModule, [{
    type: NgModule,
    args: [{
      exports: [MatSlideToggleRequiredValidator],
      declarations: [MatSlideToggleRequiredValidator]
    }]
  }], null, null);
})();
var MatSlideToggleModule = class {
};
MatSlideToggleModule.ɵfac = function MatSlideToggleModule_Factory(ɵt) {
  return new (ɵt || MatSlideToggleModule)();
};
MatSlideToggleModule.ɵmod = ɵɵdefineNgModule({
  type: MatSlideToggleModule,
  declarations: [MatSlideToggle],
  imports: [_MatSlideToggleRequiredValidatorModule, MatRippleModule, MatCommonModule, ObserversModule],
  exports: [_MatSlideToggleRequiredValidatorModule, MatSlideToggle, MatCommonModule]
});
MatSlideToggleModule.ɵinj = ɵɵdefineInjector({
  imports: [[_MatSlideToggleRequiredValidatorModule, MatRippleModule, MatCommonModule, ObserversModule], _MatSlideToggleRequiredValidatorModule, MatCommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSlideToggleModule, [{
    type: NgModule,
    args: [{
      imports: [_MatSlideToggleRequiredValidatorModule, MatRippleModule, MatCommonModule, ObserversModule],
      exports: [_MatSlideToggleRequiredValidatorModule, MatSlideToggle, MatCommonModule],
      declarations: [MatSlideToggle]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2020/accordion.mjs
var nextId$1 = 0;
var CDK_ACCORDION = new InjectionToken("CdkAccordion");
var CdkAccordion = class {
  constructor() {
    this._stateChanges = new Subject();
    this._openCloseAllActions = new Subject();
    this.id = `cdk-accordion-${nextId$1++}`;
    this._multi = false;
  }
  /** Whether the accordion should allow multiple expanded accordion items simultaneously. */
  get multi() {
    return this._multi;
  }
  set multi(multi) {
    this._multi = coerceBooleanProperty(multi);
  }
  /** Opens all enabled accordion items in an accordion where multi is enabled. */
  openAll() {
    if (this._multi) {
      this._openCloseAllActions.next(true);
    }
  }
  /** Closes all enabled accordion items in an accordion where multi is enabled. */
  closeAll() {
    this._openCloseAllActions.next(false);
  }
  ngOnChanges(changes) {
    this._stateChanges.next(changes);
  }
  ngOnDestroy() {
    this._stateChanges.complete();
    this._openCloseAllActions.complete();
  }
};
CdkAccordion.ɵfac = function CdkAccordion_Factory(ɵt) {
  return new (ɵt || CdkAccordion)();
};
CdkAccordion.ɵdir = ɵɵdefineDirective({
  type: CdkAccordion,
  selectors: [["cdk-accordion"], ["", "cdkAccordion", ""]],
  inputs: {
    multi: "multi"
  },
  exportAs: ["cdkAccordion"],
  features: [ɵɵProvidersFeature([{
    provide: CDK_ACCORDION,
    useExisting: CdkAccordion
  }]), ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkAccordion, [{
    type: Directive,
    args: [{
      selector: "cdk-accordion, [cdkAccordion]",
      exportAs: "cdkAccordion",
      providers: [{
        provide: CDK_ACCORDION,
        useExisting: CdkAccordion
      }]
    }]
  }], null, {
    multi: [{
      type: Input
    }]
  });
})();
var nextId = 0;
var CdkAccordionItem = class {
  constructor(accordion, _changeDetectorRef, _expansionDispatcher) {
    this.accordion = accordion;
    this._changeDetectorRef = _changeDetectorRef;
    this._expansionDispatcher = _expansionDispatcher;
    this._openCloseAllSubscription = Subscription.EMPTY;
    this.closed = new EventEmitter();
    this.opened = new EventEmitter();
    this.destroyed = new EventEmitter();
    this.expandedChange = new EventEmitter();
    this.id = `cdk-accordion-child-${nextId++}`;
    this._expanded = false;
    this._disabled = false;
    this._removeUniqueSelectionListener = () => {
    };
    this._removeUniqueSelectionListener = _expansionDispatcher.listen((id, accordionId) => {
      if (this.accordion && !this.accordion.multi && this.accordion.id === accordionId && this.id !== id) {
        this.expanded = false;
      }
    });
    if (this.accordion) {
      this._openCloseAllSubscription = this._subscribeToOpenCloseAllActions();
    }
  }
  /** Whether the AccordionItem is expanded. */
  get expanded() {
    return this._expanded;
  }
  set expanded(expanded) {
    expanded = coerceBooleanProperty(expanded);
    if (this._expanded !== expanded) {
      this._expanded = expanded;
      this.expandedChange.emit(expanded);
      if (expanded) {
        this.opened.emit();
        const accordionId = this.accordion ? this.accordion.id : this.id;
        this._expansionDispatcher.notify(this.id, accordionId);
      } else {
        this.closed.emit();
      }
      this._changeDetectorRef.markForCheck();
    }
  }
  /** Whether the AccordionItem is disabled. */
  get disabled() {
    return this._disabled;
  }
  set disabled(disabled) {
    this._disabled = coerceBooleanProperty(disabled);
  }
  /** Emits an event for the accordion item being destroyed. */
  ngOnDestroy() {
    this.opened.complete();
    this.closed.complete();
    this.destroyed.emit();
    this.destroyed.complete();
    this._removeUniqueSelectionListener();
    this._openCloseAllSubscription.unsubscribe();
  }
  /** Toggles the expanded state of the accordion item. */
  toggle() {
    if (!this.disabled) {
      this.expanded = !this.expanded;
    }
  }
  /** Sets the expanded state of the accordion item to false. */
  close() {
    if (!this.disabled) {
      this.expanded = false;
    }
  }
  /** Sets the expanded state of the accordion item to true. */
  open() {
    if (!this.disabled) {
      this.expanded = true;
    }
  }
  _subscribeToOpenCloseAllActions() {
    return this.accordion._openCloseAllActions.subscribe((expanded) => {
      if (!this.disabled) {
        this.expanded = expanded;
      }
    });
  }
};
CdkAccordionItem.ɵfac = function CdkAccordionItem_Factory(ɵt) {
  return new (ɵt || CdkAccordionItem)(ɵɵdirectiveInject(CDK_ACCORDION, 12), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(UniqueSelectionDispatcher));
};
CdkAccordionItem.ɵdir = ɵɵdefineDirective({
  type: CdkAccordionItem,
  selectors: [["cdk-accordion-item"], ["", "cdkAccordionItem", ""]],
  inputs: {
    expanded: "expanded",
    disabled: "disabled"
  },
  outputs: {
    closed: "closed",
    opened: "opened",
    destroyed: "destroyed",
    expandedChange: "expandedChange"
  },
  exportAs: ["cdkAccordionItem"],
  features: [ɵɵProvidersFeature([
    // Provide `CDK_ACCORDION` as undefined to prevent nested accordion items from
    // registering to the same accordion.
    {
      provide: CDK_ACCORDION,
      useValue: void 0
    }
  ])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkAccordionItem, [{
    type: Directive,
    args: [{
      selector: "cdk-accordion-item, [cdkAccordionItem]",
      exportAs: "cdkAccordionItem",
      providers: [
        // Provide `CDK_ACCORDION` as undefined to prevent nested accordion items from
        // registering to the same accordion.
        {
          provide: CDK_ACCORDION,
          useValue: void 0
        }
      ]
    }]
  }], function() {
    return [{
      type: CdkAccordion,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [CDK_ACCORDION]
      }, {
        type: SkipSelf
      }]
    }, {
      type: ChangeDetectorRef
    }, {
      type: UniqueSelectionDispatcher
    }];
  }, {
    closed: [{
      type: Output
    }],
    opened: [{
      type: Output
    }],
    destroyed: [{
      type: Output
    }],
    expandedChange: [{
      type: Output
    }],
    expanded: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }]
  });
})();
var CdkAccordionModule = class {
};
CdkAccordionModule.ɵfac = function CdkAccordionModule_Factory(ɵt) {
  return new (ɵt || CdkAccordionModule)();
};
CdkAccordionModule.ɵmod = ɵɵdefineNgModule({
  type: CdkAccordionModule,
  declarations: [CdkAccordion, CdkAccordionItem],
  exports: [CdkAccordion, CdkAccordionItem]
});
CdkAccordionModule.ɵinj = ɵɵdefineInjector({});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkAccordionModule, [{
    type: NgModule,
    args: [{
      exports: [CdkAccordion, CdkAccordionItem],
      declarations: [CdkAccordion, CdkAccordionItem]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2020/clipboard.mjs
var PendingCopy = class {
  constructor(text, _document) {
    this._document = _document;
    const textarea = this._textarea = this._document.createElement("textarea");
    const styles = textarea.style;
    styles.position = "fixed";
    styles.top = styles.opacity = "0";
    styles.left = "-999em";
    textarea.setAttribute("aria-hidden", "true");
    textarea.value = text;
    this._document.body.appendChild(textarea);
  }
  /** Finishes copying the text. */
  copy() {
    const textarea = this._textarea;
    let successful = false;
    try {
      if (textarea) {
        const currentFocus = this._document.activeElement;
        textarea.select();
        textarea.setSelectionRange(0, textarea.value.length);
        successful = this._document.execCommand("copy");
        if (currentFocus) {
          currentFocus.focus();
        }
      }
    } catch {
    }
    return successful;
  }
  /** Cleans up DOM changes used to perform the copy operation. */
  destroy() {
    const textarea = this._textarea;
    if (textarea) {
      textarea.remove();
      this._textarea = void 0;
    }
  }
};
var Clipboard = class {
  constructor(document2) {
    this._document = document2;
  }
  /**
   * Copies the provided text into the user's clipboard.
   *
   * @param text The string to copy.
   * @returns Whether the operation was successful.
   */
  copy(text) {
    const pendingCopy = this.beginCopy(text);
    const successful = pendingCopy.copy();
    pendingCopy.destroy();
    return successful;
  }
  /**
   * Prepares a string to be copied later. This is useful for large strings
   * which take too long to successfully render and be copied in the same tick.
   *
   * The caller must call `destroy` on the returned `PendingCopy`.
   *
   * @param text The string to copy.
   * @returns the pending copy operation.
   */
  beginCopy(text) {
    return new PendingCopy(text, this._document);
  }
};
Clipboard.ɵfac = function Clipboard_Factory(ɵt) {
  return new (ɵt || Clipboard)(ɵɵinject(DOCUMENT));
};
Clipboard.ɵprov = ɵɵdefineInjectable({
  token: Clipboard,
  factory: Clipboard.ɵfac,
  providedIn: "root"
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Clipboard, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, null);
})();
var CDK_COPY_TO_CLIPBOARD_CONFIG = new InjectionToken("CDK_COPY_TO_CLIPBOARD_CONFIG");
var CdkCopyToClipboard = class {
  constructor(_clipboard, _ngZone, config) {
    this._clipboard = _clipboard;
    this._ngZone = _ngZone;
    this.text = "";
    this.attempts = 1;
    this.copied = new EventEmitter();
    this._pending = /* @__PURE__ */ new Set();
    if (config && config.attempts != null) {
      this.attempts = config.attempts;
    }
  }
  /** Copies the current text to the clipboard. */
  copy(attempts = this.attempts) {
    if (attempts > 1) {
      let remainingAttempts = attempts;
      const pending = this._clipboard.beginCopy(this.text);
      this._pending.add(pending);
      const attempt = () => {
        const successful = pending.copy();
        if (!successful && --remainingAttempts && !this._destroyed) {
          this._currentTimeout = this._ngZone.runOutsideAngular(() => setTimeout(attempt, 1));
        } else {
          this._currentTimeout = null;
          this._pending.delete(pending);
          pending.destroy();
          this.copied.emit(successful);
        }
      };
      attempt();
    } else {
      this.copied.emit(this._clipboard.copy(this.text));
    }
  }
  ngOnDestroy() {
    if (this._currentTimeout) {
      clearTimeout(this._currentTimeout);
    }
    this._pending.forEach((copy) => copy.destroy());
    this._pending.clear();
    this._destroyed = true;
  }
};
CdkCopyToClipboard.ɵfac = function CdkCopyToClipboard_Factory(ɵt) {
  return new (ɵt || CdkCopyToClipboard)(ɵɵdirectiveInject(Clipboard), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(CDK_COPY_TO_CLIPBOARD_CONFIG, 8));
};
CdkCopyToClipboard.ɵdir = ɵɵdefineDirective({
  type: CdkCopyToClipboard,
  selectors: [["", "cdkCopyToClipboard", ""]],
  hostBindings: function CdkCopyToClipboard_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function CdkCopyToClipboard_click_HostBindingHandler() {
        return ctx.copy();
      });
    }
  },
  inputs: {
    text: [0, "cdkCopyToClipboard", "text"],
    attempts: [0, "cdkCopyToClipboardAttempts", "attempts"]
  },
  outputs: {
    copied: "cdkCopyToClipboardCopied"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkCopyToClipboard, [{
    type: Directive,
    args: [{
      selector: "[cdkCopyToClipboard]",
      host: {
        "(click)": "copy()"
      }
    }]
  }], function() {
    return [{
      type: Clipboard
    }, {
      type: NgZone
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [CDK_COPY_TO_CLIPBOARD_CONFIG]
      }]
    }];
  }, {
    text: [{
      type: Input,
      args: ["cdkCopyToClipboard"]
    }],
    attempts: [{
      type: Input,
      args: ["cdkCopyToClipboardAttempts"]
    }],
    copied: [{
      type: Output,
      args: ["cdkCopyToClipboardCopied"]
    }]
  });
})();
var ClipboardModule = class {
};
ClipboardModule.ɵfac = function ClipboardModule_Factory(ɵt) {
  return new (ɵt || ClipboardModule)();
};
ClipboardModule.ɵmod = ɵɵdefineNgModule({
  type: ClipboardModule,
  declarations: [CdkCopyToClipboard],
  exports: [CdkCopyToClipboard]
});
ClipboardModule.ɵinj = ɵɵdefineInjector({});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ClipboardModule, [{
    type: NgModule,
    args: [{
      declarations: [CdkCopyToClipboard],
      exports: [CdkCopyToClipboard]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2020/stepper.mjs
var _c04 = ["*"];
function CdkStep_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
var CdkStepHeader = class {
  constructor(_elementRef) {
    this._elementRef = _elementRef;
  }
  /** Focuses the step header. */
  focus() {
    this._elementRef.nativeElement.focus();
  }
};
CdkStepHeader.ɵfac = function CdkStepHeader_Factory(ɵt) {
  return new (ɵt || CdkStepHeader)(ɵɵdirectiveInject(ElementRef));
};
CdkStepHeader.ɵdir = ɵɵdefineDirective({
  type: CdkStepHeader,
  selectors: [["", "cdkStepHeader", ""]],
  hostAttrs: ["role", "tab"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkStepHeader, [{
    type: Directive,
    args: [{
      selector: "[cdkStepHeader]",
      host: {
        "role": "tab"
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, null);
})();
var CdkStepLabel = class {
  constructor(template) {
    this.template = template;
  }
};
CdkStepLabel.ɵfac = function CdkStepLabel_Factory(ɵt) {
  return new (ɵt || CdkStepLabel)(ɵɵdirectiveInject(TemplateRef));
};
CdkStepLabel.ɵdir = ɵɵdefineDirective({
  type: CdkStepLabel,
  selectors: [["", "cdkStepLabel", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkStepLabel, [{
    type: Directive,
    args: [{
      selector: "[cdkStepLabel]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var nextId2 = 0;
var STEP_STATE = {
  NUMBER: "number",
  EDIT: "edit",
  DONE: "done",
  ERROR: "error"
};
var STEPPER_GLOBAL_OPTIONS = new InjectionToken("STEPPER_GLOBAL_OPTIONS");
var CdkStep = class {
  constructor(_stepper, stepperOptions) {
    this._stepper = _stepper;
    this.interacted = false;
    this.interactedStream = new EventEmitter();
    this._editable = true;
    this._optional = false;
    this._completedOverride = null;
    this._customError = null;
    this._stepperOptions = stepperOptions ? stepperOptions : {};
    this._displayDefaultIndicatorType = this._stepperOptions.displayDefaultIndicatorType !== false;
  }
  /** Whether the user can return to this step once it has been marked as completed. */
  get editable() {
    return this._editable;
  }
  set editable(value) {
    this._editable = coerceBooleanProperty(value);
  }
  /** Whether the completion of step is optional. */
  get optional() {
    return this._optional;
  }
  set optional(value) {
    this._optional = coerceBooleanProperty(value);
  }
  /** Whether step is marked as completed. */
  get completed() {
    return this._completedOverride == null ? this._getDefaultCompleted() : this._completedOverride;
  }
  set completed(value) {
    this._completedOverride = coerceBooleanProperty(value);
  }
  _getDefaultCompleted() {
    return this.stepControl ? this.stepControl.valid && this.interacted : this.interacted;
  }
  /** Whether step has an error. */
  get hasError() {
    return this._customError == null ? this._getDefaultError() : this._customError;
  }
  set hasError(value) {
    this._customError = coerceBooleanProperty(value);
  }
  _getDefaultError() {
    return this.stepControl && this.stepControl.invalid && this.interacted;
  }
  /** Selects this step component. */
  select() {
    this._stepper.selected = this;
  }
  /** Resets the step to its initial state. Note that this includes resetting form data. */
  reset() {
    this.interacted = false;
    if (this._completedOverride != null) {
      this._completedOverride = false;
    }
    if (this._customError != null) {
      this._customError = false;
    }
    if (this.stepControl) {
      this.stepControl.reset();
    }
  }
  ngOnChanges() {
    this._stepper._stateChanged();
  }
  _markAsInteracted() {
    if (!this.interacted) {
      this.interacted = true;
      this.interactedStream.emit(this);
    }
  }
  /** Determines whether the error state can be shown. */
  _showError() {
    return this._stepperOptions.showError ?? this._customError != null;
  }
};
CdkStep.ɵfac = function CdkStep_Factory(ɵt) {
  return new (ɵt || CdkStep)(ɵɵdirectiveInject(forwardRef(() => CdkStepper)), ɵɵdirectiveInject(STEPPER_GLOBAL_OPTIONS, 8));
};
CdkStep.ɵcmp = ɵɵdefineComponent({
  type: CdkStep,
  selectors: [["cdk-step"]],
  contentQueries: function CdkStep_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, CdkStepLabel, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.stepLabel = _t.first);
    }
  },
  viewQuery: function CdkStep_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(TemplateRef, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.content = _t.first);
    }
  },
  inputs: {
    stepControl: "stepControl",
    label: "label",
    errorMessage: "errorMessage",
    ariaLabel: [0, "aria-label", "ariaLabel"],
    ariaLabelledby: [0, "aria-labelledby", "ariaLabelledby"],
    state: "state",
    editable: "editable",
    optional: "optional",
    completed: "completed",
    hasError: "hasError"
  },
  outputs: {
    interactedStream: "interacted"
  },
  exportAs: ["cdkStep"],
  features: [ɵɵNgOnChangesFeature],
  ngContentSelectors: _c04,
  decls: 1,
  vars: 0,
  template: function CdkStep_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, CdkStep_ng_template_0_Template, 1, 0, "ng-template");
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkStep, [{
    type: Component,
    args: [{
      selector: "cdk-step",
      exportAs: "cdkStep",
      template: "<ng-template><ng-content></ng-content></ng-template>",
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], function() {
    return [{
      type: CdkStepper,
      decorators: [{
        type: Inject,
        args: [forwardRef(() => CdkStepper)]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [STEPPER_GLOBAL_OPTIONS]
      }]
    }];
  }, {
    stepLabel: [{
      type: ContentChild,
      args: [CdkStepLabel]
    }],
    content: [{
      type: ViewChild,
      args: [TemplateRef, {
        static: true
      }]
    }],
    stepControl: [{
      type: Input
    }],
    interactedStream: [{
      type: Output,
      args: ["interacted"]
    }],
    label: [{
      type: Input
    }],
    errorMessage: [{
      type: Input
    }],
    ariaLabel: [{
      type: Input,
      args: ["aria-label"]
    }],
    ariaLabelledby: [{
      type: Input,
      args: ["aria-labelledby"]
    }],
    state: [{
      type: Input
    }],
    editable: [{
      type: Input
    }],
    optional: [{
      type: Input
    }],
    completed: [{
      type: Input
    }],
    hasError: [{
      type: Input
    }]
  });
})();
var CdkStepper = class {
  constructor(_dir, _changeDetectorRef, _elementRef, _document) {
    this._dir = _dir;
    this._changeDetectorRef = _changeDetectorRef;
    this._elementRef = _elementRef;
    this._destroyed = new Subject();
    this.steps = new QueryList();
    this._sortedHeaders = new QueryList();
    this._linear = false;
    this._selectedIndex = 0;
    this.selectionChange = new EventEmitter();
    this._orientation = "horizontal";
    this._groupId = nextId2++;
  }
  /** Whether the validity of previous steps should be checked or not. */
  get linear() {
    return this._linear;
  }
  set linear(value) {
    this._linear = coerceBooleanProperty(value);
  }
  /** The index of the selected step. */
  get selectedIndex() {
    return this._selectedIndex;
  }
  set selectedIndex(index) {
    const newIndex = coerceNumberProperty(index);
    if (this.steps && this._steps) {
      if (!this._isValidIndex(newIndex) && (typeof ngDevMode === "undefined" || ngDevMode)) {
        throw Error("cdkStepper: Cannot assign out-of-bounds value to `selectedIndex`.");
      }
      this.selected?._markAsInteracted();
      if (this._selectedIndex !== newIndex && !this._anyControlsInvalidOrPending(newIndex) && (newIndex >= this._selectedIndex || this.steps.toArray()[newIndex].editable)) {
        this._updateSelectedItemIndex(newIndex);
      }
    } else {
      this._selectedIndex = newIndex;
    }
  }
  /** The step that is selected. */
  get selected() {
    return this.steps ? this.steps.toArray()[this.selectedIndex] : void 0;
  }
  set selected(step) {
    this.selectedIndex = step && this.steps ? this.steps.toArray().indexOf(step) : -1;
  }
  /** Orientation of the stepper. */
  get orientation() {
    return this._orientation;
  }
  set orientation(value) {
    this._orientation = value;
    if (this._keyManager) {
      this._keyManager.withVerticalOrientation(value === "vertical");
    }
  }
  ngAfterContentInit() {
    this._steps.changes.pipe(startWith(this._steps), takeUntil(this._destroyed)).subscribe((steps) => {
      this.steps.reset(steps.filter((step) => step._stepper === this));
      this.steps.notifyOnChanges();
    });
  }
  ngAfterViewInit() {
    this._stepHeader.changes.pipe(startWith(this._stepHeader), takeUntil(this._destroyed)).subscribe((headers) => {
      this._sortedHeaders.reset(headers.toArray().sort((a, b) => {
        const documentPosition = a._elementRef.nativeElement.compareDocumentPosition(b._elementRef.nativeElement);
        return documentPosition & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : 1;
      }));
      this._sortedHeaders.notifyOnChanges();
    });
    this._keyManager = new FocusKeyManager(this._sortedHeaders).withWrap().withHomeAndEnd().withVerticalOrientation(this._orientation === "vertical");
    (this._dir ? this._dir.change : of()).pipe(startWith(this._layoutDirection()), takeUntil(this._destroyed)).subscribe((direction) => this._keyManager.withHorizontalOrientation(direction));
    this._keyManager.updateActiveItem(this._selectedIndex);
    this.steps.changes.subscribe(() => {
      if (!this.selected) {
        this._selectedIndex = Math.max(this._selectedIndex - 1, 0);
      }
    });
    if (!this._isValidIndex(this._selectedIndex)) {
      this._selectedIndex = 0;
    }
  }
  ngOnDestroy() {
    this.steps.destroy();
    this._sortedHeaders.destroy();
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** Selects and focuses the next step in list. */
  next() {
    this.selectedIndex = Math.min(this._selectedIndex + 1, this.steps.length - 1);
  }
  /** Selects and focuses the previous step in list. */
  previous() {
    this.selectedIndex = Math.max(this._selectedIndex - 1, 0);
  }
  /** Resets the stepper to its initial state. Note that this includes clearing form data. */
  reset() {
    this._updateSelectedItemIndex(0);
    this.steps.forEach((step) => step.reset());
    this._stateChanged();
  }
  /** Returns a unique id for each step label element. */
  _getStepLabelId(i) {
    return `cdk-step-label-${this._groupId}-${i}`;
  }
  /** Returns unique id for each step content element. */
  _getStepContentId(i) {
    return `cdk-step-content-${this._groupId}-${i}`;
  }
  /** Marks the component to be change detected. */
  _stateChanged() {
    this._changeDetectorRef.markForCheck();
  }
  /** Returns position state of the step with the given index. */
  _getAnimationDirection(index) {
    const position = index - this._selectedIndex;
    if (position < 0) {
      return this._layoutDirection() === "rtl" ? "next" : "previous";
    } else if (position > 0) {
      return this._layoutDirection() === "rtl" ? "previous" : "next";
    }
    return "current";
  }
  /** Returns the type of icon to be displayed. */
  _getIndicatorType(index, state2 = STEP_STATE.NUMBER) {
    const step = this.steps.toArray()[index];
    const isCurrentStep = this._isCurrentStep(index);
    return step._displayDefaultIndicatorType ? this._getDefaultIndicatorLogic(step, isCurrentStep) : this._getGuidelineLogic(step, isCurrentStep, state2);
  }
  _getDefaultIndicatorLogic(step, isCurrentStep) {
    if (step._showError() && step.hasError && !isCurrentStep) {
      return STEP_STATE.ERROR;
    } else if (!step.completed || isCurrentStep) {
      return STEP_STATE.NUMBER;
    } else {
      return step.editable ? STEP_STATE.EDIT : STEP_STATE.DONE;
    }
  }
  _getGuidelineLogic(step, isCurrentStep, state2 = STEP_STATE.NUMBER) {
    if (step._showError() && step.hasError && !isCurrentStep) {
      return STEP_STATE.ERROR;
    } else if (step.completed && !isCurrentStep) {
      return STEP_STATE.DONE;
    } else if (step.completed && isCurrentStep) {
      return state2;
    } else if (step.editable && isCurrentStep) {
      return STEP_STATE.EDIT;
    } else {
      return state2;
    }
  }
  _isCurrentStep(index) {
    return this._selectedIndex === index;
  }
  /** Returns the index of the currently-focused step header. */
  _getFocusIndex() {
    return this._keyManager ? this._keyManager.activeItemIndex : this._selectedIndex;
  }
  _updateSelectedItemIndex(newIndex) {
    const stepsArray = this.steps.toArray();
    this.selectionChange.emit({
      selectedIndex: newIndex,
      previouslySelectedIndex: this._selectedIndex,
      selectedStep: stepsArray[newIndex],
      previouslySelectedStep: stepsArray[this._selectedIndex]
    });
    this._containsFocus() ? this._keyManager.setActiveItem(newIndex) : this._keyManager.updateActiveItem(newIndex);
    this._selectedIndex = newIndex;
    this._stateChanged();
  }
  _onKeydown(event) {
    const hasModifier = hasModifierKey(event);
    const keyCode = event.keyCode;
    const manager = this._keyManager;
    if (manager.activeItemIndex != null && !hasModifier && (keyCode === SPACE || keyCode === ENTER)) {
      this.selectedIndex = manager.activeItemIndex;
      event.preventDefault();
    } else {
      manager.onKeydown(event);
    }
  }
  _anyControlsInvalidOrPending(index) {
    if (this._linear && index >= 0) {
      return this.steps.toArray().slice(0, index).some((step) => {
        const control = step.stepControl;
        const isIncomplete = control ? control.invalid || control.pending || !step.interacted : !step.completed;
        return isIncomplete && !step.optional && !step._completedOverride;
      });
    }
    return false;
  }
  _layoutDirection() {
    return this._dir && this._dir.value === "rtl" ? "rtl" : "ltr";
  }
  /** Checks whether the stepper contains the focused element. */
  _containsFocus() {
    const stepperElement = this._elementRef.nativeElement;
    const focusedElement = _getFocusedElementPierceShadowDom();
    return stepperElement === focusedElement || stepperElement.contains(focusedElement);
  }
  /** Checks whether the passed-in index is a valid step index. */
  _isValidIndex(index) {
    return index > -1 && (!this.steps || index < this.steps.length);
  }
};
CdkStepper.ɵfac = function CdkStepper_Factory(ɵt) {
  return new (ɵt || CdkStepper)(ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DOCUMENT));
};
CdkStepper.ɵdir = ɵɵdefineDirective({
  type: CdkStepper,
  selectors: [["", "cdkStepper", ""]],
  contentQueries: function CdkStepper_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, CdkStep, 5);
      ɵɵcontentQuery(dirIndex, CdkStepHeader, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._steps = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._stepHeader = _t);
    }
  },
  inputs: {
    linear: "linear",
    selectedIndex: "selectedIndex",
    selected: "selected",
    orientation: "orientation"
  },
  outputs: {
    selectionChange: "selectionChange"
  },
  exportAs: ["cdkStepper"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkStepper, [{
    type: Directive,
    args: [{
      selector: "[cdkStepper]",
      exportAs: "cdkStepper"
    }]
  }], function() {
    return [{
      type: Directionality,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, {
    _steps: [{
      type: ContentChildren,
      args: [CdkStep, {
        descendants: true
      }]
    }],
    _stepHeader: [{
      type: ContentChildren,
      args: [CdkStepHeader, {
        descendants: true
      }]
    }],
    linear: [{
      type: Input
    }],
    selectedIndex: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    selectionChange: [{
      type: Output
    }],
    orientation: [{
      type: Input
    }]
  });
})();
var CdkStepperNext = class {
  constructor(_stepper) {
    this._stepper = _stepper;
    this.type = "submit";
  }
};
CdkStepperNext.ɵfac = function CdkStepperNext_Factory(ɵt) {
  return new (ɵt || CdkStepperNext)(ɵɵdirectiveInject(CdkStepper));
};
CdkStepperNext.ɵdir = ɵɵdefineDirective({
  type: CdkStepperNext,
  selectors: [["button", "cdkStepperNext", ""]],
  hostVars: 1,
  hostBindings: function CdkStepperNext_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function CdkStepperNext_click_HostBindingHandler() {
        return ctx._stepper.next();
      });
    }
    if (rf & 2) {
      ɵɵhostProperty("type", ctx.type);
    }
  },
  inputs: {
    type: "type"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkStepperNext, [{
    type: Directive,
    args: [{
      selector: "button[cdkStepperNext]",
      host: {
        "[type]": "type",
        "(click)": "_stepper.next()"
      }
    }]
  }], function() {
    return [{
      type: CdkStepper
    }];
  }, {
    type: [{
      type: Input
    }]
  });
})();
var CdkStepperPrevious = class {
  constructor(_stepper) {
    this._stepper = _stepper;
    this.type = "button";
  }
};
CdkStepperPrevious.ɵfac = function CdkStepperPrevious_Factory(ɵt) {
  return new (ɵt || CdkStepperPrevious)(ɵɵdirectiveInject(CdkStepper));
};
CdkStepperPrevious.ɵdir = ɵɵdefineDirective({
  type: CdkStepperPrevious,
  selectors: [["button", "cdkStepperPrevious", ""]],
  hostVars: 1,
  hostBindings: function CdkStepperPrevious_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function CdkStepperPrevious_click_HostBindingHandler() {
        return ctx._stepper.previous();
      });
    }
    if (rf & 2) {
      ɵɵhostProperty("type", ctx.type);
    }
  },
  inputs: {
    type: "type"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkStepperPrevious, [{
    type: Directive,
    args: [{
      selector: "button[cdkStepperPrevious]",
      host: {
        "[type]": "type",
        "(click)": "_stepper.previous()"
      }
    }]
  }], function() {
    return [{
      type: CdkStepper
    }];
  }, {
    type: [{
      type: Input
    }]
  });
})();
var CdkStepperModule = class {
};
CdkStepperModule.ɵfac = function CdkStepperModule_Factory(ɵt) {
  return new (ɵt || CdkStepperModule)();
};
CdkStepperModule.ɵmod = ɵɵdefineNgModule({
  type: CdkStepperModule,
  declarations: [CdkStep, CdkStepper, CdkStepHeader, CdkStepLabel, CdkStepperNext, CdkStepperPrevious],
  imports: [BidiModule],
  exports: [CdkStep, CdkStepper, CdkStepHeader, CdkStepLabel, CdkStepperNext, CdkStepperPrevious]
});
CdkStepperModule.ɵinj = ɵɵdefineInjector({
  imports: [[BidiModule]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkStepperModule, [{
    type: NgModule,
    args: [{
      imports: [BidiModule],
      exports: [CdkStep, CdkStepper, CdkStepHeader, CdkStepLabel, CdkStepperNext, CdkStepperPrevious],
      declarations: [CdkStep, CdkStepper, CdkStepHeader, CdkStepLabel, CdkStepperNext, CdkStepperPrevious]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2020/tree.mjs
var CDK_TREE_NODE_OUTLET_NODE = new InjectionToken("CDK_TREE_NODE_OUTLET_NODE");
var CdkTreeNodeOutlet = class {
  constructor(viewContainer, _node) {
    this.viewContainer = viewContainer;
    this._node = _node;
  }
};
CdkTreeNodeOutlet.ɵfac = function CdkTreeNodeOutlet_Factory(ɵt) {
  return new (ɵt || CdkTreeNodeOutlet)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(CDK_TREE_NODE_OUTLET_NODE, 8));
};
CdkTreeNodeOutlet.ɵdir = ɵɵdefineDirective({
  type: CdkTreeNodeOutlet,
  selectors: [["", "cdkTreeNodeOutlet", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTreeNodeOutlet, [{
    type: Directive,
    args: [{
      selector: "[cdkTreeNodeOutlet]"
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [CDK_TREE_NODE_OUTLET_NODE]
      }, {
        type: Optional
      }]
    }];
  }, null);
})();
var CdkTreeNodeOutletContext = class {
  constructor(data) {
    this.$implicit = data;
  }
};
var CdkTreeNodeDef = class {
  /** @docs-private */
  constructor(template) {
    this.template = template;
  }
};
CdkTreeNodeDef.ɵfac = function CdkTreeNodeDef_Factory(ɵt) {
  return new (ɵt || CdkTreeNodeDef)(ɵɵdirectiveInject(TemplateRef));
};
CdkTreeNodeDef.ɵdir = ɵɵdefineDirective({
  type: CdkTreeNodeDef,
  selectors: [["", "cdkTreeNodeDef", ""]],
  inputs: {
    when: [0, "cdkTreeNodeDefWhen", "when"]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTreeNodeDef, [{
    type: Directive,
    args: [{
      selector: "[cdkTreeNodeDef]",
      inputs: ["when: cdkTreeNodeDefWhen"]
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
function getTreeNoValidDataSourceError() {
  return Error(`A valid data source must be provided.`);
}
function getTreeMultipleDefaultNodeDefsError() {
  return Error(`There can only be one default row without a when predicate function.`);
}
function getTreeMissingMatchingNodeDefError() {
  return Error(`Could not find a matching node definition for the provided node data.`);
}
function getTreeControlMissingError() {
  return Error(`Could not find a tree control for the tree.`);
}
function getTreeControlFunctionsMissingError() {
  return Error(`Could not find functions for nested/flat tree in tree control.`);
}
var CdkTree = class {
  constructor(_differs, _changeDetectorRef) {
    this._differs = _differs;
    this._changeDetectorRef = _changeDetectorRef;
    this._onDestroy = new Subject();
    this._levels = /* @__PURE__ */ new Map();
    this.viewChange = new BehaviorSubject({
      start: 0,
      end: Number.MAX_VALUE
    });
  }
  /**
   * Provides a stream containing the latest data array to render. Influenced by the tree's
   * stream of view window (what dataNodes are currently on screen).
   * Data source can be an observable of data array, or a data array to render.
   */
  get dataSource() {
    return this._dataSource;
  }
  set dataSource(dataSource) {
    if (this._dataSource !== dataSource) {
      this._switchDataSource(dataSource);
    }
  }
  ngOnInit() {
    this._dataDiffer = this._differs.find([]).create(this.trackBy);
    if (!this.treeControl && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTreeControlMissingError();
    }
  }
  ngOnDestroy() {
    this._nodeOutlet.viewContainer.clear();
    this.viewChange.complete();
    this._onDestroy.next();
    this._onDestroy.complete();
    if (this._dataSource && typeof this._dataSource.disconnect === "function") {
      this.dataSource.disconnect(this);
    }
    if (this._dataSubscription) {
      this._dataSubscription.unsubscribe();
      this._dataSubscription = null;
    }
  }
  ngAfterContentChecked() {
    const defaultNodeDefs = this._nodeDefs.filter((def) => !def.when);
    if (defaultNodeDefs.length > 1 && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTreeMultipleDefaultNodeDefsError();
    }
    this._defaultNodeDef = defaultNodeDefs[0];
    if (this.dataSource && this._nodeDefs && !this._dataSubscription) {
      this._observeRenderChanges();
    }
  }
  // TODO(tinayuangao): Work on keyboard traversal and actions, make sure it's working for RTL
  //     and nested trees.
  /**
   * Switch to the provided data source by resetting the data and unsubscribing from the current
   * render change subscription if one exists. If the data source is null, interpret this by
   * clearing the node outlet. Otherwise start listening for new data.
   */
  _switchDataSource(dataSource) {
    if (this._dataSource && typeof this._dataSource.disconnect === "function") {
      this.dataSource.disconnect(this);
    }
    if (this._dataSubscription) {
      this._dataSubscription.unsubscribe();
      this._dataSubscription = null;
    }
    if (!dataSource) {
      this._nodeOutlet.viewContainer.clear();
    }
    this._dataSource = dataSource;
    if (this._nodeDefs) {
      this._observeRenderChanges();
    }
  }
  /** Set up a subscription for the data provided by the data source. */
  _observeRenderChanges() {
    let dataStream;
    if (isDataSource(this._dataSource)) {
      dataStream = this._dataSource.connect(this);
    } else if (isObservable(this._dataSource)) {
      dataStream = this._dataSource;
    } else if (Array.isArray(this._dataSource)) {
      dataStream = of(this._dataSource);
    }
    if (dataStream) {
      this._dataSubscription = dataStream.pipe(takeUntil(this._onDestroy)).subscribe((data) => this.renderNodeChanges(data));
    } else if (typeof ngDevMode === "undefined" || ngDevMode) {
      throw getTreeNoValidDataSourceError();
    }
  }
  /** Check for changes made in the data and render each change (node added/removed/moved). */
  renderNodeChanges(data, dataDiffer = this._dataDiffer, viewContainer = this._nodeOutlet.viewContainer, parentData) {
    const changes = dataDiffer.diff(data);
    if (!changes) {
      return;
    }
    changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
      if (item.previousIndex == null) {
        this.insertNode(data[currentIndex], currentIndex, viewContainer, parentData);
      } else if (currentIndex == null) {
        viewContainer.remove(adjustedPreviousIndex);
        this._levels.delete(item.item);
      } else {
        const view = viewContainer.get(adjustedPreviousIndex);
        viewContainer.move(view, currentIndex);
      }
    });
    this._changeDetectorRef.detectChanges();
  }
  /**
   * Finds the matching node definition that should be used for this node data. If there is only
   * one node definition, it is returned. Otherwise, find the node definition that has a when
   * predicate that returns true with the data. If none return true, return the default node
   * definition.
   */
  _getNodeDef(data, i) {
    if (this._nodeDefs.length === 1) {
      return this._nodeDefs.first;
    }
    const nodeDef = this._nodeDefs.find((def) => def.when && def.when(i, data)) || this._defaultNodeDef;
    if (!nodeDef && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTreeMissingMatchingNodeDefError();
    }
    return nodeDef;
  }
  /**
   * Create the embedded view for the data node template and place it in the correct index location
   * within the data node view container.
   */
  insertNode(nodeData, index, viewContainer, parentData) {
    const node = this._getNodeDef(nodeData, index);
    const context = new CdkTreeNodeOutletContext(nodeData);
    if (this.treeControl.getLevel) {
      context.level = this.treeControl.getLevel(nodeData);
    } else if (typeof parentData !== "undefined" && this._levels.has(parentData)) {
      context.level = this._levels.get(parentData) + 1;
    } else {
      context.level = 0;
    }
    this._levels.set(nodeData, context.level);
    const container = viewContainer ? viewContainer : this._nodeOutlet.viewContainer;
    container.createEmbeddedView(node.template, context, index);
    if (CdkTreeNode.mostRecentTreeNode) {
      CdkTreeNode.mostRecentTreeNode.data = nodeData;
    }
  }
};
CdkTree.ɵfac = function CdkTree_Factory(ɵt) {
  return new (ɵt || CdkTree)(ɵɵdirectiveInject(IterableDiffers), ɵɵdirectiveInject(ChangeDetectorRef));
};
CdkTree.ɵcmp = ɵɵdefineComponent({
  type: CdkTree,
  selectors: [["cdk-tree"]],
  contentQueries: function CdkTree_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, CdkTreeNodeDef, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._nodeDefs = _t);
    }
  },
  viewQuery: function CdkTree_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(CdkTreeNodeOutlet, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._nodeOutlet = _t.first);
    }
  },
  hostAttrs: ["role", "tree", 1, "cdk-tree"],
  inputs: {
    dataSource: "dataSource",
    treeControl: "treeControl",
    trackBy: "trackBy"
  },
  exportAs: ["cdkTree"],
  decls: 1,
  vars: 0,
  consts: [["cdkTreeNodeOutlet", ""]],
  template: function CdkTree_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0);
    }
  },
  dependencies: [CdkTreeNodeOutlet],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTree, [{
    type: Component,
    args: [{
      selector: "cdk-tree",
      exportAs: "cdkTree",
      template: `<ng-container cdkTreeNodeOutlet></ng-container>`,
      host: {
        "class": "cdk-tree",
        "role": "tree"
      },
      encapsulation: ViewEncapsulation$1.None,
      // The "OnPush" status for the `CdkTree` component is effectively a noop, so we are removing it.
      // The view for `CdkTree` consists entirely of templates declared in other views. As they are
      // declared elsewhere, they are checked when their declaration points are checked.
      // tslint:disable-next-line:validate-decorators
      changeDetection: ChangeDetectionStrategy.Default
    }]
  }], function() {
    return [{
      type: IterableDiffers
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    dataSource: [{
      type: Input
    }],
    treeControl: [{
      type: Input
    }],
    trackBy: [{
      type: Input
    }],
    _nodeOutlet: [{
      type: ViewChild,
      args: [CdkTreeNodeOutlet, {
        static: true
      }]
    }],
    _nodeDefs: [{
      type: ContentChildren,
      args: [CdkTreeNodeDef, {
        // We need to use `descendants: true`, because Ivy will no longer match
        // indirect descendants if it's left as false.
        descendants: true
      }]
    }]
  });
})();
var CdkTreeNode = class _CdkTreeNode {
  constructor(_elementRef, _tree) {
    this._elementRef = _elementRef;
    this._tree = _tree;
    this._destroyed = new Subject();
    this._dataChanges = new Subject();
    _CdkTreeNode.mostRecentTreeNode = this;
    this.role = "treeitem";
  }
  /**
   * The role of the tree node.
   * @deprecated The correct role is 'treeitem', 'group' should not be used. This input will be
   *   removed in a future version.
   * @breaking-change 12.0.0 Remove this input
   */
  get role() {
    return "treeitem";
  }
  set role(_role) {
    this._elementRef.nativeElement.setAttribute("role", _role);
  }
  /** The tree node's data. */
  get data() {
    return this._data;
  }
  set data(value) {
    if (value !== this._data) {
      this._data = value;
      this._setRoleFromData();
      this._dataChanges.next();
    }
  }
  get isExpanded() {
    return this._tree.treeControl.isExpanded(this._data);
  }
  get level() {
    return this._tree.treeControl.getLevel ? this._tree.treeControl.getLevel(this._data) : this._parentNodeAriaLevel;
  }
  ngOnInit() {
    this._parentNodeAriaLevel = getParentNodeAriaLevel(this._elementRef.nativeElement);
    this._elementRef.nativeElement.setAttribute("aria-level", `${this.level + 1}`);
  }
  ngOnDestroy() {
    if (_CdkTreeNode.mostRecentTreeNode === this) {
      _CdkTreeNode.mostRecentTreeNode = null;
    }
    this._dataChanges.complete();
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** Focuses the menu item. Implements for FocusableOption. */
  focus() {
    this._elementRef.nativeElement.focus();
  }
  // TODO: role should eventually just be set in the component host
  _setRoleFromData() {
    if (!this._tree.treeControl.isExpandable && !this._tree.treeControl.getChildren && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTreeControlFunctionsMissingError();
    }
    this.role = "treeitem";
  }
};
CdkTreeNode.mostRecentTreeNode = null;
CdkTreeNode.ɵfac = function CdkTreeNode_Factory(ɵt) {
  return new (ɵt || CdkTreeNode)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(CdkTree));
};
CdkTreeNode.ɵdir = ɵɵdefineDirective({
  type: CdkTreeNode,
  selectors: [["cdk-tree-node"]],
  hostAttrs: [1, "cdk-tree-node"],
  hostVars: 1,
  hostBindings: function CdkTreeNode_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-expanded", ctx.isExpanded);
    }
  },
  inputs: {
    role: "role"
  },
  exportAs: ["cdkTreeNode"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTreeNode, [{
    type: Directive,
    args: [{
      selector: "cdk-tree-node",
      exportAs: "cdkTreeNode",
      host: {
        "class": "cdk-tree-node",
        "[attr.aria-expanded]": "isExpanded"
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: CdkTree
    }];
  }, {
    role: [{
      type: Input
    }]
  });
})();
function getParentNodeAriaLevel(nodeElement) {
  let parent = nodeElement.parentElement;
  while (parent && !isNodeElement(parent)) {
    parent = parent.parentElement;
  }
  if (!parent) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      throw Error("Incorrect tree structure containing detached node.");
    } else {
      return -1;
    }
  } else if (parent.classList.contains("cdk-nested-tree-node")) {
    return coerceNumberProperty(parent.getAttribute("aria-level"));
  } else {
    return 0;
  }
}
function isNodeElement(element) {
  const classList = element.classList;
  return !!(classList?.contains("cdk-nested-tree-node") || classList?.contains("cdk-tree"));
}
var CdkNestedTreeNode = class extends CdkTreeNode {
  constructor(elementRef, tree, _differs) {
    super(elementRef, tree);
    this._differs = _differs;
  }
  ngAfterContentInit() {
    this._dataDiffer = this._differs.find([]).create(this._tree.trackBy);
    if (!this._tree.treeControl.getChildren && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getTreeControlFunctionsMissingError();
    }
    const childrenNodes = this._tree.treeControl.getChildren(this.data);
    if (Array.isArray(childrenNodes)) {
      this.updateChildrenNodes(childrenNodes);
    } else if (isObservable(childrenNodes)) {
      childrenNodes.pipe(takeUntil(this._destroyed)).subscribe((result) => this.updateChildrenNodes(result));
    }
    this.nodeOutlet.changes.pipe(takeUntil(this._destroyed)).subscribe(() => this.updateChildrenNodes());
  }
  // This is a workaround for https://github.com/angular/angular/issues/23091
  // In aot mode, the lifecycle hooks from parent class are not called.
  ngOnInit() {
    super.ngOnInit();
  }
  ngOnDestroy() {
    this._clear();
    super.ngOnDestroy();
  }
  /** Add children dataNodes to the NodeOutlet */
  updateChildrenNodes(children) {
    const outlet = this._getNodeOutlet();
    if (children) {
      this._children = children;
    }
    if (outlet && this._children) {
      const viewContainer = outlet.viewContainer;
      this._tree.renderNodeChanges(this._children, this._dataDiffer, viewContainer, this._data);
    } else {
      this._dataDiffer.diff([]);
    }
  }
  /** Clear the children dataNodes. */
  _clear() {
    const outlet = this._getNodeOutlet();
    if (outlet) {
      outlet.viewContainer.clear();
      this._dataDiffer.diff([]);
    }
  }
  /** Gets the outlet for the current node. */
  _getNodeOutlet() {
    const outlets = this.nodeOutlet;
    return outlets && outlets.find((outlet) => !outlet._node || outlet._node === this);
  }
};
CdkNestedTreeNode.ɵfac = function CdkNestedTreeNode_Factory(ɵt) {
  return new (ɵt || CdkNestedTreeNode)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(CdkTree), ɵɵdirectiveInject(IterableDiffers));
};
CdkNestedTreeNode.ɵdir = ɵɵdefineDirective({
  type: CdkNestedTreeNode,
  selectors: [["cdk-nested-tree-node"]],
  contentQueries: function CdkNestedTreeNode_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, CdkTreeNodeOutlet, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.nodeOutlet = _t);
    }
  },
  hostAttrs: [1, "cdk-nested-tree-node"],
  inputs: {
    role: "role",
    disabled: "disabled",
    tabIndex: "tabIndex"
  },
  exportAs: ["cdkNestedTreeNode"],
  features: [ɵɵProvidersFeature([{
    provide: CdkTreeNode,
    useExisting: CdkNestedTreeNode
  }, {
    provide: CDK_TREE_NODE_OUTLET_NODE,
    useExisting: CdkNestedTreeNode
  }]), ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkNestedTreeNode, [{
    type: Directive,
    args: [{
      selector: "cdk-nested-tree-node",
      exportAs: "cdkNestedTreeNode",
      inputs: ["role", "disabled", "tabIndex"],
      providers: [{
        provide: CdkTreeNode,
        useExisting: CdkNestedTreeNode
      }, {
        provide: CDK_TREE_NODE_OUTLET_NODE,
        useExisting: CdkNestedTreeNode
      }],
      host: {
        "class": "cdk-nested-tree-node"
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: CdkTree
    }, {
      type: IterableDiffers
    }];
  }, {
    nodeOutlet: [{
      type: ContentChildren,
      args: [CdkTreeNodeOutlet, {
        // We need to use `descendants: true`, because Ivy will no longer match
        // indirect descendants if it's left as false.
        descendants: true
      }]
    }]
  });
})();
var cssUnitPattern = /([A-Za-z%]+)$/;
var CdkTreeNodePadding = class {
  constructor(_treeNode, _tree, _element, _dir) {
    this._treeNode = _treeNode;
    this._tree = _tree;
    this._element = _element;
    this._dir = _dir;
    this._destroyed = new Subject();
    this.indentUnits = "px";
    this._indent = 40;
    this._setPadding();
    if (_dir) {
      _dir.change.pipe(takeUntil(this._destroyed)).subscribe(() => this._setPadding(true));
    }
    _treeNode._dataChanges.subscribe(() => this._setPadding());
  }
  /** The level of depth of the tree node. The padding will be `level * indent` pixels. */
  get level() {
    return this._level;
  }
  set level(value) {
    this._setLevelInput(value);
  }
  /**
   * The indent for each level. Can be a number or a CSS string.
   * Default number 40px from material design menu sub-menu spec.
   */
  get indent() {
    return this._indent;
  }
  set indent(indent) {
    this._setIndentInput(indent);
  }
  ngOnDestroy() {
    this._destroyed.next();
    this._destroyed.complete();
  }
  /** The padding indent value for the tree node. Returns a string with px numbers if not null. */
  _paddingIndent() {
    const nodeLevel = this._treeNode.data && this._tree.treeControl.getLevel ? this._tree.treeControl.getLevel(this._treeNode.data) : null;
    const level = this._level == null ? nodeLevel : this._level;
    return typeof level === "number" ? `${level * this._indent}${this.indentUnits}` : null;
  }
  _setPadding(forceChange = false) {
    const padding = this._paddingIndent();
    if (padding !== this._currentPadding || forceChange) {
      const element = this._element.nativeElement;
      const paddingProp = this._dir && this._dir.value === "rtl" ? "paddingRight" : "paddingLeft";
      const resetProp = paddingProp === "paddingLeft" ? "paddingRight" : "paddingLeft";
      element.style[paddingProp] = padding || "";
      element.style[resetProp] = "";
      this._currentPadding = padding;
    }
  }
  /**
   * This has been extracted to a util because of TS 4 and VE.
   * View Engine doesn't support property rename inheritance.
   * TS 4.0 doesn't allow properties to override accessors or vice-versa.
   * @docs-private
   */
  _setLevelInput(value) {
    this._level = coerceNumberProperty(value, null);
    this._setPadding();
  }
  /**
   * This has been extracted to a util because of TS 4 and VE.
   * View Engine doesn't support property rename inheritance.
   * TS 4.0 doesn't allow properties to override accessors or vice-versa.
   * @docs-private
   */
  _setIndentInput(indent) {
    let value = indent;
    let units = "px";
    if (typeof indent === "string") {
      const parts = indent.split(cssUnitPattern);
      value = parts[0];
      units = parts[1] || units;
    }
    this.indentUnits = units;
    this._indent = coerceNumberProperty(value);
    this._setPadding();
  }
};
CdkTreeNodePadding.ɵfac = function CdkTreeNodePadding_Factory(ɵt) {
  return new (ɵt || CdkTreeNodePadding)(ɵɵdirectiveInject(CdkTreeNode), ɵɵdirectiveInject(CdkTree), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Directionality, 8));
};
CdkTreeNodePadding.ɵdir = ɵɵdefineDirective({
  type: CdkTreeNodePadding,
  selectors: [["", "cdkTreeNodePadding", ""]],
  inputs: {
    level: [0, "cdkTreeNodePadding", "level"],
    indent: [0, "cdkTreeNodePaddingIndent", "indent"]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTreeNodePadding, [{
    type: Directive,
    args: [{
      selector: "[cdkTreeNodePadding]"
    }]
  }], function() {
    return [{
      type: CdkTreeNode
    }, {
      type: CdkTree
    }, {
      type: ElementRef
    }, {
      type: Directionality,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    level: [{
      type: Input,
      args: ["cdkTreeNodePadding"]
    }],
    indent: [{
      type: Input,
      args: ["cdkTreeNodePaddingIndent"]
    }]
  });
})();
var CdkTreeNodeToggle = class {
  constructor(_tree, _treeNode) {
    this._tree = _tree;
    this._treeNode = _treeNode;
    this._recursive = false;
  }
  /** Whether expand/collapse the node recursively. */
  get recursive() {
    return this._recursive;
  }
  set recursive(value) {
    this._recursive = coerceBooleanProperty(value);
  }
  _toggle(event) {
    this.recursive ? this._tree.treeControl.toggleDescendants(this._treeNode.data) : this._tree.treeControl.toggle(this._treeNode.data);
    event.stopPropagation();
  }
};
CdkTreeNodeToggle.ɵfac = function CdkTreeNodeToggle_Factory(ɵt) {
  return new (ɵt || CdkTreeNodeToggle)(ɵɵdirectiveInject(CdkTree), ɵɵdirectiveInject(CdkTreeNode));
};
CdkTreeNodeToggle.ɵdir = ɵɵdefineDirective({
  type: CdkTreeNodeToggle,
  selectors: [["", "cdkTreeNodeToggle", ""]],
  hostBindings: function CdkTreeNodeToggle_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function CdkTreeNodeToggle_click_HostBindingHandler($event) {
        return ctx._toggle($event);
      });
    }
  },
  inputs: {
    recursive: [0, "cdkTreeNodeToggleRecursive", "recursive"]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTreeNodeToggle, [{
    type: Directive,
    args: [{
      selector: "[cdkTreeNodeToggle]",
      host: {
        "(click)": "_toggle($event)"
      }
    }]
  }], function() {
    return [{
      type: CdkTree
    }, {
      type: CdkTreeNode
    }];
  }, {
    recursive: [{
      type: Input,
      args: ["cdkTreeNodeToggleRecursive"]
    }]
  });
})();
var EXPORTED_DECLARATIONS = [CdkNestedTreeNode, CdkTreeNodeDef, CdkTreeNodePadding, CdkTreeNodeToggle, CdkTree, CdkTreeNode, CdkTreeNodeOutlet];
var CdkTreeModule = class {
};
CdkTreeModule.ɵfac = function CdkTreeModule_Factory(ɵt) {
  return new (ɵt || CdkTreeModule)();
};
CdkTreeModule.ɵmod = ɵɵdefineNgModule({
  type: CdkTreeModule,
  declarations: [CdkNestedTreeNode, CdkTreeNodeDef, CdkTreeNodePadding, CdkTreeNodeToggle, CdkTree, CdkTreeNode, CdkTreeNodeOutlet],
  exports: [CdkNestedTreeNode, CdkTreeNodeDef, CdkTreeNodePadding, CdkTreeNodeToggle, CdkTree, CdkTreeNode, CdkTreeNodeOutlet]
});
CdkTreeModule.ɵinj = ɵɵdefineInjector({});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTreeModule, [{
    type: NgModule,
    args: [{
      exports: EXPORTED_DECLARATIONS,
      declarations: EXPORTED_DECLARATIONS
    }]
  }], null, null);
})();

// node_modules/@angular/material/fesm2020/bottom-sheet.mjs
function MatBottomSheetContainer_ng_template_0_Template(rf, ctx) {
}
var matBottomSheetAnimations = {
  /** Animation that shows and hides a bottom sheet. */
  bottomSheetState: trigger("state", [state("void, hidden", style({
    transform: "translateY(100%)"
  })), state("visible", style({
    transform: "translateY(0%)"
  })), transition("visible => void, visible => hidden", group([animate(`${AnimationDurations.COMPLEX} ${AnimationCurves.ACCELERATION_CURVE}`), query("@*", animateChild(), {
    optional: true
  })])), transition("void => visible", group([animate(`${AnimationDurations.EXITING} ${AnimationCurves.DECELERATION_CURVE}`), query("@*", animateChild(), {
    optional: true
  })]))])
};
var MAT_BOTTOM_SHEET_DATA = new InjectionToken("MatBottomSheetData");
var MatBottomSheetConfig = class {
  constructor() {
    this.data = null;
    this.hasBackdrop = true;
    this.disableClose = false;
    this.ariaLabel = null;
    this.closeOnNavigation = true;
    this.autoFocus = "dialog";
    this.restoreFocus = true;
  }
};
var MatBottomSheetContainer = class extends BasePortalOutlet {
  constructor(_elementRef, _changeDetectorRef, _focusTrapFactory, _interactivityChecker, _ngZone, breakpointObserver, document2, bottomSheetConfig) {
    super();
    this._elementRef = _elementRef;
    this._changeDetectorRef = _changeDetectorRef;
    this._focusTrapFactory = _focusTrapFactory;
    this._interactivityChecker = _interactivityChecker;
    this._ngZone = _ngZone;
    this.bottomSheetConfig = bottomSheetConfig;
    this._animationState = "void";
    this._animationStateChanged = new EventEmitter();
    this._elementFocusedBeforeOpened = null;
    this.attachDomPortal = (portal) => {
      this._validatePortalAttached();
      this._setPanelClass();
      this._savePreviouslyFocusedElement();
      return this._portalOutlet.attachDomPortal(portal);
    };
    this._document = document2;
    this._breakpointSubscription = breakpointObserver.observe([Breakpoints.Medium, Breakpoints.Large, Breakpoints.XLarge]).subscribe(() => {
      this._toggleClass("mat-bottom-sheet-container-medium", breakpointObserver.isMatched(Breakpoints.Medium));
      this._toggleClass("mat-bottom-sheet-container-large", breakpointObserver.isMatched(Breakpoints.Large));
      this._toggleClass("mat-bottom-sheet-container-xlarge", breakpointObserver.isMatched(Breakpoints.XLarge));
    });
  }
  /** Attach a component portal as content to this bottom sheet container. */
  attachComponentPortal(portal) {
    this._validatePortalAttached();
    this._setPanelClass();
    this._savePreviouslyFocusedElement();
    return this._portalOutlet.attachComponentPortal(portal);
  }
  /** Attach a template portal as content to this bottom sheet container. */
  attachTemplatePortal(portal) {
    this._validatePortalAttached();
    this._setPanelClass();
    this._savePreviouslyFocusedElement();
    return this._portalOutlet.attachTemplatePortal(portal);
  }
  /** Begin animation of bottom sheet entrance into view. */
  enter() {
    if (!this._destroyed) {
      this._animationState = "visible";
      this._changeDetectorRef.detectChanges();
    }
  }
  /** Begin animation of the bottom sheet exiting from view. */
  exit() {
    if (!this._destroyed) {
      this._animationState = "hidden";
      this._changeDetectorRef.markForCheck();
    }
  }
  ngOnDestroy() {
    this._breakpointSubscription.unsubscribe();
    this._destroyed = true;
  }
  _onAnimationDone(event) {
    if (event.toState === "hidden") {
      this._restoreFocus();
    } else if (event.toState === "visible") {
      this._trapFocus();
    }
    this._animationStateChanged.emit(event);
  }
  _onAnimationStart(event) {
    this._animationStateChanged.emit(event);
  }
  _toggleClass(cssClass, add) {
    this._elementRef.nativeElement.classList.toggle(cssClass, add);
  }
  _validatePortalAttached() {
    if (this._portalOutlet.hasAttached() && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("Attempting to attach bottom sheet content after content is already attached");
    }
  }
  _setPanelClass() {
    const element = this._elementRef.nativeElement;
    element.classList.add(...coerceArray(this.bottomSheetConfig.panelClass || []));
  }
  /**
   * Focuses the provided element. If the element is not focusable, it will add a tabIndex
   * attribute to forcefully focus it. The attribute is removed after focus is moved.
   * @param element The element to focus.
   */
  _forceFocus(element, options) {
    if (!this._interactivityChecker.isFocusable(element)) {
      element.tabIndex = -1;
      this._ngZone.runOutsideAngular(() => {
        const callback = () => {
          element.removeEventListener("blur", callback);
          element.removeEventListener("mousedown", callback);
          element.removeAttribute("tabindex");
        };
        element.addEventListener("blur", callback);
        element.addEventListener("mousedown", callback);
      });
    }
    element.focus(options);
  }
  /**
   * Focuses the first element that matches the given selector within the focus trap.
   * @param selector The CSS selector for the element to set focus to.
   */
  _focusByCssSelector(selector, options) {
    let elementToFocus = this._elementRef.nativeElement.querySelector(selector);
    if (elementToFocus) {
      this._forceFocus(elementToFocus, options);
    }
  }
  /**
   * Moves the focus inside the focus trap. When autoFocus is not set to 'bottom-sheet',
   * if focus cannot be moved then focus will go to the bottom sheet container.
   */
  _trapFocus() {
    const element = this._elementRef.nativeElement;
    if (!this._focusTrap) {
      this._focusTrap = this._focusTrapFactory.create(element);
    }
    switch (this.bottomSheetConfig.autoFocus) {
      case false:
      case "dialog":
        const activeElement = _getFocusedElementPierceShadowDom();
        if (activeElement !== element && !element.contains(activeElement)) {
          element.focus();
        }
        break;
      case true:
      case "first-tabbable":
        this._focusTrap.focusInitialElementWhenReady();
        break;
      case "first-heading":
        this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role="heading"]');
        break;
      default:
        this._focusByCssSelector(this.bottomSheetConfig.autoFocus);
        break;
    }
  }
  /** Restores focus to the element that was focused before the bottom sheet was opened. */
  _restoreFocus() {
    const toFocus = this._elementFocusedBeforeOpened;
    if (this.bottomSheetConfig.restoreFocus && toFocus && typeof toFocus.focus === "function") {
      const activeElement = _getFocusedElementPierceShadowDom();
      const element = this._elementRef.nativeElement;
      if (!activeElement || activeElement === this._document.body || activeElement === element || element.contains(activeElement)) {
        toFocus.focus();
      }
    }
    if (this._focusTrap) {
      this._focusTrap.destroy();
    }
  }
  /** Saves a reference to the element that was focused before the bottom sheet was opened. */
  _savePreviouslyFocusedElement() {
    this._elementFocusedBeforeOpened = _getFocusedElementPierceShadowDom();
    if (this._elementRef.nativeElement.focus) {
      this._ngZone.runOutsideAngular(() => {
        Promise.resolve().then(() => this._elementRef.nativeElement.focus());
      });
    }
  }
};
MatBottomSheetContainer.ɵfac = function MatBottomSheetContainer_Factory(ɵt) {
  return new (ɵt || MatBottomSheetContainer)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(FocusTrapFactory), ɵɵdirectiveInject(InteractivityChecker), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(BreakpointObserver), ɵɵdirectiveInject(DOCUMENT, 8), ɵɵdirectiveInject(MatBottomSheetConfig));
};
MatBottomSheetContainer.ɵcmp = ɵɵdefineComponent({
  type: MatBottomSheetContainer,
  selectors: [["mat-bottom-sheet-container"]],
  viewQuery: function MatBottomSheetContainer_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(CdkPortalOutlet, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._portalOutlet = _t.first);
    }
  },
  hostAttrs: ["tabindex", "-1", "role", "dialog", "aria-modal", "true", 1, "mat-bottom-sheet-container"],
  hostVars: 2,
  hostBindings: function MatBottomSheetContainer_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵsyntheticHostListener("@state.start", function MatBottomSheetContainer_animation_state_start_HostBindingHandler($event) {
        return ctx._onAnimationStart($event);
      })("@state.done", function MatBottomSheetContainer_animation_state_done_HostBindingHandler($event) {
        return ctx._onAnimationDone($event);
      });
    }
    if (rf & 2) {
      ɵɵsyntheticHostProperty("@state", ctx._animationState);
      ɵɵattribute("aria-label", ctx.bottomSheetConfig == null ? null : ctx.bottomSheetConfig.ariaLabel);
    }
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 1,
  vars: 0,
  consts: [["cdkPortalOutlet", ""]],
  template: function MatBottomSheetContainer_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵtemplate(0, MatBottomSheetContainer_ng_template_0_Template, 0, 0, "ng-template", 0);
    }
  },
  dependencies: [CdkPortalOutlet],
  styles: [".mat-bottom-sheet-container{padding:8px 16px;min-width:100vw;box-sizing:border-box;display:block;outline:0;max-height:80vh;overflow:auto}.cdk-high-contrast-active .mat-bottom-sheet-container{outline:1px solid}.mat-bottom-sheet-container-xlarge,.mat-bottom-sheet-container-large,.mat-bottom-sheet-container-medium{border-top-left-radius:4px;border-top-right-radius:4px}.mat-bottom-sheet-container-medium{min-width:384px;max-width:calc(100vw - 128px)}.mat-bottom-sheet-container-large{min-width:512px;max-width:calc(100vw - 256px)}.mat-bottom-sheet-container-xlarge{min-width:576px;max-width:calc(100vw - 384px)}\n"],
  encapsulation: 2,
  data: {
    animation: [matBottomSheetAnimations.bottomSheetState]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatBottomSheetContainer, [{
    type: Component,
    args: [{
      selector: "mat-bottom-sheet-container",
      changeDetection: ChangeDetectionStrategy.Default,
      encapsulation: ViewEncapsulation$1.None,
      animations: [matBottomSheetAnimations.bottomSheetState],
      host: {
        "class": "mat-bottom-sheet-container",
        "tabindex": "-1",
        "role": "dialog",
        "aria-modal": "true",
        "[attr.aria-label]": "bottomSheetConfig?.ariaLabel",
        "[@state]": "_animationState",
        "(@state.start)": "_onAnimationStart($event)",
        "(@state.done)": "_onAnimationDone($event)"
      },
      template: "<ng-template cdkPortalOutlet></ng-template>\r\n",
      styles: [".mat-bottom-sheet-container{padding:8px 16px;min-width:100vw;box-sizing:border-box;display:block;outline:0;max-height:80vh;overflow:auto}.cdk-high-contrast-active .mat-bottom-sheet-container{outline:1px solid}.mat-bottom-sheet-container-xlarge,.mat-bottom-sheet-container-large,.mat-bottom-sheet-container-medium{border-top-left-radius:4px;border-top-right-radius:4px}.mat-bottom-sheet-container-medium{min-width:384px;max-width:calc(100vw - 128px)}.mat-bottom-sheet-container-large{min-width:512px;max-width:calc(100vw - 256px)}.mat-bottom-sheet-container-xlarge{min-width:576px;max-width:calc(100vw - 384px)}\n"]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: FocusTrapFactory
    }, {
      type: InteractivityChecker
    }, {
      type: NgZone
    }, {
      type: BreakpointObserver
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [DOCUMENT]
      }]
    }, {
      type: MatBottomSheetConfig
    }];
  }, {
    _portalOutlet: [{
      type: ViewChild,
      args: [CdkPortalOutlet, {
        static: true
      }]
    }]
  });
})();
var MatBottomSheetModule = class {
};
MatBottomSheetModule.ɵfac = function MatBottomSheetModule_Factory(ɵt) {
  return new (ɵt || MatBottomSheetModule)();
};
MatBottomSheetModule.ɵmod = ɵɵdefineNgModule({
  type: MatBottomSheetModule,
  declarations: [MatBottomSheetContainer],
  imports: [OverlayModule, MatCommonModule, PortalModule],
  exports: [MatBottomSheetContainer, MatCommonModule]
});
MatBottomSheetModule.ɵinj = ɵɵdefineInjector({
  imports: [[OverlayModule, MatCommonModule, PortalModule], MatCommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatBottomSheetModule, [{
    type: NgModule,
    args: [{
      imports: [OverlayModule, MatCommonModule, PortalModule],
      exports: [MatBottomSheetContainer, MatCommonModule],
      declarations: [MatBottomSheetContainer]
    }]
  }], null, null);
})();
var MatBottomSheetRef = class {
  constructor(containerInstance, _overlayRef) {
    this._overlayRef = _overlayRef;
    this._afterDismissed = new Subject();
    this._afterOpened = new Subject();
    this.containerInstance = containerInstance;
    this.disableClose = containerInstance.bottomSheetConfig.disableClose;
    containerInstance._animationStateChanged.pipe(filter((event) => event.phaseName === "done" && event.toState === "visible"), take(1)).subscribe(() => {
      this._afterOpened.next();
      this._afterOpened.complete();
    });
    containerInstance._animationStateChanged.pipe(filter((event) => event.phaseName === "done" && event.toState === "hidden"), take(1)).subscribe(() => {
      clearTimeout(this._closeFallbackTimeout);
      _overlayRef.dispose();
    });
    _overlayRef.detachments().pipe(take(1)).subscribe(() => {
      this._afterDismissed.next(this._result);
      this._afterDismissed.complete();
    });
    merge(_overlayRef.backdropClick(), _overlayRef.keydownEvents().pipe(filter((event) => event.keyCode === ESCAPE))).subscribe((event) => {
      if (!this.disableClose && (event.type !== "keydown" || !hasModifierKey(event))) {
        event.preventDefault();
        this.dismiss();
      }
    });
  }
  /**
   * Dismisses the bottom sheet.
   * @param result Data to be passed back to the bottom sheet opener.
   */
  dismiss(result) {
    if (!this._afterDismissed.closed) {
      this.containerInstance._animationStateChanged.pipe(filter((event) => event.phaseName === "start"), take(1)).subscribe((event) => {
        this._closeFallbackTimeout = setTimeout(() => {
          this._overlayRef.dispose();
        }, event.totalTime + 100);
        this._overlayRef.detachBackdrop();
      });
      this._result = result;
      this.containerInstance.exit();
    }
  }
  /** Gets an observable that is notified when the bottom sheet is finished closing. */
  afterDismissed() {
    return this._afterDismissed;
  }
  /** Gets an observable that is notified when the bottom sheet has opened and appeared. */
  afterOpened() {
    return this._afterOpened;
  }
  /**
   * Gets an observable that emits when the overlay's backdrop has been clicked.
   */
  backdropClick() {
    return this._overlayRef.backdropClick();
  }
  /**
   * Gets an observable that emits when keydown events are targeted on the overlay.
   */
  keydownEvents() {
    return this._overlayRef.keydownEvents();
  }
};
var MAT_BOTTOM_SHEET_DEFAULT_OPTIONS = new InjectionToken("mat-bottom-sheet-default-options");
var MatBottomSheet = class {
  constructor(_overlay, _injector, _parentBottomSheet, _defaultOptions) {
    this._overlay = _overlay;
    this._injector = _injector;
    this._parentBottomSheet = _parentBottomSheet;
    this._defaultOptions = _defaultOptions;
    this._bottomSheetRefAtThisLevel = null;
  }
  /** Reference to the currently opened bottom sheet. */
  get _openedBottomSheetRef() {
    const parent = this._parentBottomSheet;
    return parent ? parent._openedBottomSheetRef : this._bottomSheetRefAtThisLevel;
  }
  set _openedBottomSheetRef(value) {
    if (this._parentBottomSheet) {
      this._parentBottomSheet._openedBottomSheetRef = value;
    } else {
      this._bottomSheetRefAtThisLevel = value;
    }
  }
  open(componentOrTemplateRef, config) {
    const _config = _applyConfigDefaults(this._defaultOptions || new MatBottomSheetConfig(), config);
    const overlayRef = this._createOverlay(_config);
    const container = this._attachContainer(overlayRef, _config);
    const ref = new MatBottomSheetRef(container, overlayRef);
    if (componentOrTemplateRef instanceof TemplateRef) {
      container.attachTemplatePortal(new TemplatePortal(componentOrTemplateRef, null, {
        $implicit: _config.data,
        bottomSheetRef: ref
      }));
    } else {
      const portal = new ComponentPortal(componentOrTemplateRef, void 0, this._createInjector(_config, ref));
      const contentRef = container.attachComponentPortal(portal);
      ref.instance = contentRef.instance;
    }
    ref.afterDismissed().subscribe(() => {
      if (this._openedBottomSheetRef == ref) {
        this._openedBottomSheetRef = null;
      }
    });
    if (this._openedBottomSheetRef) {
      this._openedBottomSheetRef.afterDismissed().subscribe(() => ref.containerInstance.enter());
      this._openedBottomSheetRef.dismiss();
    } else {
      ref.containerInstance.enter();
    }
    this._openedBottomSheetRef = ref;
    return ref;
  }
  /**
   * Dismisses the currently-visible bottom sheet.
   * @param result Data to pass to the bottom sheet instance.
   */
  dismiss(result) {
    if (this._openedBottomSheetRef) {
      this._openedBottomSheetRef.dismiss(result);
    }
  }
  ngOnDestroy() {
    if (this._bottomSheetRefAtThisLevel) {
      this._bottomSheetRefAtThisLevel.dismiss();
    }
  }
  /**
   * Attaches the bottom sheet container component to the overlay.
   */
  _attachContainer(overlayRef, config) {
    const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
    const injector = Injector.create({
      parent: userInjector || this._injector,
      providers: [{
        provide: MatBottomSheetConfig,
        useValue: config
      }]
    });
    const containerPortal = new ComponentPortal(MatBottomSheetContainer, config.viewContainerRef, injector);
    const containerRef = overlayRef.attach(containerPortal);
    return containerRef.instance;
  }
  /**
   * Creates a new overlay and places it in the correct location.
   * @param config The user-specified bottom sheet config.
   */
  _createOverlay(config) {
    const overlayConfig = new OverlayConfig({
      direction: config.direction,
      hasBackdrop: config.hasBackdrop,
      disposeOnNavigation: config.closeOnNavigation,
      maxWidth: "100%",
      scrollStrategy: config.scrollStrategy || this._overlay.scrollStrategies.block(),
      positionStrategy: this._overlay.position().global().centerHorizontally().bottom("0")
    });
    if (config.backdropClass) {
      overlayConfig.backdropClass = config.backdropClass;
    }
    return this._overlay.create(overlayConfig);
  }
  /**
   * Creates an injector to be used inside of a bottom sheet component.
   * @param config Config that was used to create the bottom sheet.
   * @param bottomSheetRef Reference to the bottom sheet.
   */
  _createInjector(config, bottomSheetRef) {
    const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;
    const providers = [{
      provide: MatBottomSheetRef,
      useValue: bottomSheetRef
    }, {
      provide: MAT_BOTTOM_SHEET_DATA,
      useValue: config.data
    }];
    if (config.direction && (!userInjector || !userInjector.get(Directionality, null, InjectFlags.Optional))) {
      providers.push({
        provide: Directionality,
        useValue: {
          value: config.direction,
          change: of()
        }
      });
    }
    return Injector.create({
      parent: userInjector || this._injector,
      providers
    });
  }
};
MatBottomSheet.ɵfac = function MatBottomSheet_Factory(ɵt) {
  return new (ɵt || MatBottomSheet)(ɵɵinject(Overlay), ɵɵinject(Injector), ɵɵinject(MatBottomSheet, 12), ɵɵinject(MAT_BOTTOM_SHEET_DEFAULT_OPTIONS, 8));
};
MatBottomSheet.ɵprov = ɵɵdefineInjectable({
  token: MatBottomSheet,
  factory: MatBottomSheet.ɵfac,
  providedIn: MatBottomSheetModule
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatBottomSheet, [{
    type: Injectable,
    args: [{
      providedIn: MatBottomSheetModule
    }]
  }], function() {
    return [{
      type: Overlay
    }, {
      type: Injector
    }, {
      type: MatBottomSheet,
      decorators: [{
        type: Optional
      }, {
        type: SkipSelf
      }]
    }, {
      type: MatBottomSheetConfig,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [MAT_BOTTOM_SHEET_DEFAULT_OPTIONS]
      }]
    }];
  }, null);
})();
function _applyConfigDefaults(defaults, config) {
  return __spreadValues(__spreadValues({}, defaults), config);
}

// node_modules/@angular/material/fesm2020/chips.mjs
var _c05 = ["*"];
var MAT_CHIP_REMOVE = new InjectionToken("MatChipRemove");
var MAT_CHIP_AVATAR = new InjectionToken("MatChipAvatar");
var MAT_CHIP_TRAILING_ICON = new InjectionToken("MatChipTrailingIcon");
var MatChipBase = class {
  constructor(_elementRef) {
    this._elementRef = _elementRef;
  }
};
var _MatChipMixinBase = mixinTabIndex(mixinColor(mixinDisableRipple(MatChipBase), "primary"), -1);
var MatChipAvatar = class {
};
MatChipAvatar.ɵfac = function MatChipAvatar_Factory(ɵt) {
  return new (ɵt || MatChipAvatar)();
};
MatChipAvatar.ɵdir = ɵɵdefineDirective({
  type: MatChipAvatar,
  selectors: [["mat-chip-avatar"], ["", "matChipAvatar", ""]],
  hostAttrs: [1, "mat-chip-avatar"],
  features: [ɵɵProvidersFeature([{
    provide: MAT_CHIP_AVATAR,
    useExisting: MatChipAvatar
  }])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatChipAvatar, [{
    type: Directive,
    args: [{
      selector: "mat-chip-avatar, [matChipAvatar]",
      host: {
        "class": "mat-chip-avatar"
      },
      providers: [{
        provide: MAT_CHIP_AVATAR,
        useExisting: MatChipAvatar
      }]
    }]
  }], null, null);
})();
var MatChipTrailingIcon = class {
};
MatChipTrailingIcon.ɵfac = function MatChipTrailingIcon_Factory(ɵt) {
  return new (ɵt || MatChipTrailingIcon)();
};
MatChipTrailingIcon.ɵdir = ɵɵdefineDirective({
  type: MatChipTrailingIcon,
  selectors: [["mat-chip-trailing-icon"], ["", "matChipTrailingIcon", ""]],
  hostAttrs: [1, "mat-chip-trailing-icon"],
  features: [ɵɵProvidersFeature([{
    provide: MAT_CHIP_TRAILING_ICON,
    useExisting: MatChipTrailingIcon
  }])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatChipTrailingIcon, [{
    type: Directive,
    args: [{
      selector: "mat-chip-trailing-icon, [matChipTrailingIcon]",
      host: {
        "class": "mat-chip-trailing-icon"
      },
      providers: [{
        provide: MAT_CHIP_TRAILING_ICON,
        useExisting: MatChipTrailingIcon
      }]
    }]
  }], null, null);
})();
var MatChip = class extends _MatChipMixinBase {
  constructor(elementRef, _ngZone, platform, globalRippleOptions, _changeDetectorRef, _document, animationMode, tabIndex) {
    super(elementRef);
    this._ngZone = _ngZone;
    this._changeDetectorRef = _changeDetectorRef;
    this._hasFocus = false;
    this.chipListSelectable = true;
    this._chipListMultiple = false;
    this._chipListDisabled = false;
    this._selected = false;
    this._selectable = true;
    this._disabled = false;
    this._removable = true;
    this._onFocus = new Subject();
    this._onBlur = new Subject();
    this.selectionChange = new EventEmitter();
    this.destroyed = new EventEmitter();
    this.removed = new EventEmitter();
    this._addHostClassName();
    this._chipRippleTarget = _document.createElement("div");
    this._chipRippleTarget.classList.add("mat-chip-ripple");
    this._elementRef.nativeElement.appendChild(this._chipRippleTarget);
    this._chipRipple = new RippleRenderer(this, _ngZone, this._chipRippleTarget, platform);
    this._chipRipple.setupTriggerEvents(elementRef);
    this.rippleConfig = globalRippleOptions || {};
    this._animationsDisabled = animationMode === "NoopAnimations";
    this.tabIndex = tabIndex != null ? parseInt(tabIndex) || -1 : -1;
  }
  /**
   * Whether ripples are disabled on interaction
   * @docs-private
   */
  get rippleDisabled() {
    return this.disabled || this.disableRipple || this._animationsDisabled || !!this.rippleConfig.disabled;
  }
  /** Whether the chip is selected. */
  get selected() {
    return this._selected;
  }
  set selected(value) {
    const coercedValue = coerceBooleanProperty(value);
    if (coercedValue !== this._selected) {
      this._selected = coercedValue;
      this._dispatchSelectionChange();
    }
  }
  /** The value of the chip. Defaults to the content inside `<mat-chip>` tags. */
  get value() {
    return this._value !== void 0 ? this._value : this._elementRef.nativeElement.textContent;
  }
  set value(value) {
    this._value = value;
  }
  /**
   * Whether or not the chip is selectable. When a chip is not selectable,
   * changes to its selected state are always ignored. By default a chip is
   * selectable, and it becomes non-selectable if its parent chip list is
   * not selectable.
   */
  get selectable() {
    return this._selectable && this.chipListSelectable;
  }
  set selectable(value) {
    this._selectable = coerceBooleanProperty(value);
  }
  /** Whether the chip is disabled. */
  get disabled() {
    return this._chipListDisabled || this._disabled;
  }
  set disabled(value) {
    this._disabled = coerceBooleanProperty(value);
  }
  /**
   * Determines whether or not the chip displays the remove styling and emits (removed) events.
   */
  get removable() {
    return this._removable;
  }
  set removable(value) {
    this._removable = coerceBooleanProperty(value);
  }
  /** The ARIA selected applied to the chip. */
  get ariaSelected() {
    return this.selectable && (this._chipListMultiple || this.selected) ? this.selected.toString() : null;
  }
  _addHostClassName() {
    const basicChipAttrName = "mat-basic-chip";
    const element = this._elementRef.nativeElement;
    if (element.hasAttribute(basicChipAttrName) || element.tagName.toLowerCase() === basicChipAttrName) {
      element.classList.add(basicChipAttrName);
      return;
    } else {
      element.classList.add("mat-standard-chip");
    }
  }
  ngOnDestroy() {
    this.destroyed.emit({
      chip: this
    });
    this._chipRipple._removeTriggerEvents();
  }
  /** Selects the chip. */
  select() {
    if (!this._selected) {
      this._selected = true;
      this._dispatchSelectionChange();
      this._changeDetectorRef.markForCheck();
    }
  }
  /** Deselects the chip. */
  deselect() {
    if (this._selected) {
      this._selected = false;
      this._dispatchSelectionChange();
      this._changeDetectorRef.markForCheck();
    }
  }
  /** Select this chip and emit selected event */
  selectViaInteraction() {
    if (!this._selected) {
      this._selected = true;
      this._dispatchSelectionChange(true);
      this._changeDetectorRef.markForCheck();
    }
  }
  /** Toggles the current selected state of this chip. */
  toggleSelected(isUserInput = false) {
    this._selected = !this.selected;
    this._dispatchSelectionChange(isUserInput);
    this._changeDetectorRef.markForCheck();
    return this.selected;
  }
  /** Allows for programmatic focusing of the chip. */
  focus() {
    if (!this._hasFocus) {
      this._elementRef.nativeElement.focus();
      this._onFocus.next({
        chip: this
      });
    }
    this._hasFocus = true;
  }
  /**
   * Allows for programmatic removal of the chip. Called by the MatChipList when the DELETE or
   * BACKSPACE keys are pressed.
   *
   * Informs any listeners of the removal request. Does not remove the chip from the DOM.
   */
  remove() {
    if (this.removable) {
      this.removed.emit({
        chip: this
      });
    }
  }
  /** Handles click events on the chip. */
  _handleClick(event) {
    if (this.disabled) {
      event.preventDefault();
    }
  }
  /** Handle custom key presses. */
  _handleKeydown(event) {
    if (this.disabled) {
      return;
    }
    switch (event.keyCode) {
      case DELETE:
      case BACKSPACE:
        this.remove();
        event.preventDefault();
        break;
      case SPACE:
        if (this.selectable) {
          this.toggleSelected(true);
        }
        event.preventDefault();
        break;
    }
  }
  _blur() {
    this._ngZone.onStable.pipe(take(1)).subscribe(() => {
      this._ngZone.run(() => {
        this._hasFocus = false;
        this._onBlur.next({
          chip: this
        });
      });
    });
  }
  _dispatchSelectionChange(isUserInput = false) {
    this.selectionChange.emit({
      source: this,
      isUserInput,
      selected: this._selected
    });
  }
};
MatChip.ɵfac = function MatChip_Factory(ɵt) {
  return new (ɵt || MatChip)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Platform), ɵɵdirectiveInject(MAT_RIPPLE_GLOBAL_OPTIONS, 8), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8), ɵɵinjectAttribute("tabindex"));
};
MatChip.ɵdir = ɵɵdefineDirective({
  type: MatChip,
  selectors: [["mat-basic-chip"], ["", "mat-basic-chip", ""], ["mat-chip"], ["", "mat-chip", ""]],
  contentQueries: function MatChip_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, MAT_CHIP_AVATAR, 5);
      ɵɵcontentQuery(dirIndex, MAT_CHIP_TRAILING_ICON, 5);
      ɵɵcontentQuery(dirIndex, MAT_CHIP_REMOVE, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.avatar = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.trailingIcon = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.removeIcon = _t.first);
    }
  },
  hostAttrs: ["role", "option", 1, "mat-chip", "mat-focus-indicator"],
  hostVars: 14,
  hostBindings: function MatChip_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function MatChip_click_HostBindingHandler($event) {
        return ctx._handleClick($event);
      })("keydown", function MatChip_keydown_HostBindingHandler($event) {
        return ctx._handleKeydown($event);
      })("focus", function MatChip_focus_HostBindingHandler() {
        return ctx.focus();
      })("blur", function MatChip_blur_HostBindingHandler() {
        return ctx._blur();
      });
    }
    if (rf & 2) {
      ɵɵattribute("tabindex", ctx.disabled ? null : ctx.tabIndex)("disabled", ctx.disabled || null)("aria-disabled", ctx.disabled.toString())("aria-selected", ctx.ariaSelected);
      ɵɵclassProp("mat-chip-selected", ctx.selected)("mat-chip-with-avatar", ctx.avatar)("mat-chip-with-trailing-icon", ctx.trailingIcon || ctx.removeIcon)("mat-chip-disabled", ctx.disabled)("_mat-animation-noopable", ctx._animationsDisabled);
    }
  },
  inputs: {
    color: "color",
    disableRipple: "disableRipple",
    tabIndex: "tabIndex",
    selected: "selected",
    value: "value",
    selectable: "selectable",
    disabled: "disabled",
    removable: "removable"
  },
  outputs: {
    selectionChange: "selectionChange",
    destroyed: "destroyed",
    removed: "removed"
  },
  exportAs: ["matChip"],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatChip, [{
    type: Directive,
    args: [{
      selector: `mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]`,
      inputs: ["color", "disableRipple", "tabIndex"],
      exportAs: "matChip",
      host: {
        "class": "mat-chip mat-focus-indicator",
        "[attr.tabindex]": "disabled ? null : tabIndex",
        "role": "option",
        "[class.mat-chip-selected]": "selected",
        "[class.mat-chip-with-avatar]": "avatar",
        "[class.mat-chip-with-trailing-icon]": "trailingIcon || removeIcon",
        "[class.mat-chip-disabled]": "disabled",
        "[class._mat-animation-noopable]": "_animationsDisabled",
        "[attr.disabled]": "disabled || null",
        "[attr.aria-disabled]": "disabled.toString()",
        "[attr.aria-selected]": "ariaSelected",
        "(click)": "_handleClick($event)",
        "(keydown)": "_handleKeydown($event)",
        "(focus)": "focus()",
        "(blur)": "_blur()"
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Platform
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [MAT_RIPPLE_GLOBAL_OPTIONS]
      }]
    }, {
      type: ChangeDetectorRef
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [ANIMATION_MODULE_TYPE]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Attribute,
        args: ["tabindex"]
      }]
    }];
  }, {
    avatar: [{
      type: ContentChild,
      args: [MAT_CHIP_AVATAR]
    }],
    trailingIcon: [{
      type: ContentChild,
      args: [MAT_CHIP_TRAILING_ICON]
    }],
    removeIcon: [{
      type: ContentChild,
      args: [MAT_CHIP_REMOVE]
    }],
    selected: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    selectable: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    removable: [{
      type: Input
    }],
    selectionChange: [{
      type: Output
    }],
    destroyed: [{
      type: Output
    }],
    removed: [{
      type: Output
    }]
  });
})();
var MatChipRemove = class {
  constructor(_parentChip, elementRef) {
    this._parentChip = _parentChip;
    if (elementRef.nativeElement.nodeName === "BUTTON") {
      elementRef.nativeElement.setAttribute("type", "button");
    }
  }
  /** Calls the parent chip's public `remove()` method if applicable. */
  _handleClick(event) {
    const parentChip = this._parentChip;
    if (parentChip.removable && !parentChip.disabled) {
      parentChip.remove();
    }
    event.stopPropagation();
    event.preventDefault();
  }
};
MatChipRemove.ɵfac = function MatChipRemove_Factory(ɵt) {
  return new (ɵt || MatChipRemove)(ɵɵdirectiveInject(MatChip), ɵɵdirectiveInject(ElementRef));
};
MatChipRemove.ɵdir = ɵɵdefineDirective({
  type: MatChipRemove,
  selectors: [["", "matChipRemove", ""]],
  hostAttrs: [1, "mat-chip-remove", "mat-chip-trailing-icon"],
  hostBindings: function MatChipRemove_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function MatChipRemove_click_HostBindingHandler($event) {
        return ctx._handleClick($event);
      });
    }
  },
  features: [ɵɵProvidersFeature([{
    provide: MAT_CHIP_REMOVE,
    useExisting: MatChipRemove
  }])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatChipRemove, [{
    type: Directive,
    args: [{
      selector: "[matChipRemove]",
      host: {
        "class": "mat-chip-remove mat-chip-trailing-icon",
        "(click)": "_handleClick($event)"
      },
      providers: [{
        provide: MAT_CHIP_REMOVE,
        useExisting: MatChipRemove
      }]
    }]
  }], function() {
    return [{
      type: MatChip
    }, {
      type: ElementRef
    }];
  }, null);
})();
var MAT_CHIPS_DEFAULT_OPTIONS = new InjectionToken("mat-chips-default-options");
var _MatChipListBase = mixinErrorState(class {
  constructor(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {
    this._defaultErrorStateMatcher = _defaultErrorStateMatcher;
    this._parentForm = _parentForm;
    this._parentFormGroup = _parentFormGroup;
    this.ngControl = ngControl;
  }
});
var nextUniqueId$1 = 0;
var MatChipListChange = class {
  constructor(source, value) {
    this.source = source;
    this.value = value;
  }
};
var MatChipList = class extends _MatChipListBase {
  constructor(_elementRef, _changeDetectorRef, _dir, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, ngControl) {
    super(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);
    this._elementRef = _elementRef;
    this._changeDetectorRef = _changeDetectorRef;
    this._dir = _dir;
    this.controlType = "mat-chip-list";
    this._lastDestroyedChipIndex = null;
    this._destroyed = new Subject();
    this._uid = `mat-chip-list-${nextUniqueId$1++}`;
    this._tabIndex = 0;
    this._userTabIndex = null;
    this._onTouched = () => {
    };
    this._onChange = () => {
    };
    this._multiple = false;
    this._compareWith = (o1, o2) => o1 === o2;
    this._disabled = false;
    this.ariaOrientation = "horizontal";
    this._selectable = true;
    this.change = new EventEmitter();
    this.valueChange = new EventEmitter();
    if (this.ngControl) {
      this.ngControl.valueAccessor = this;
    }
  }
  /** The array of selected chips inside chip list. */
  get selected() {
    return this.multiple ? this._selectionModel?.selected || [] : this._selectionModel?.selected[0];
  }
  /** The ARIA role applied to the chip list. */
  get role() {
    return this.empty ? null : "listbox";
  }
  /** Whether the user should be allowed to select multiple chips. */
  get multiple() {
    return this._multiple;
  }
  set multiple(value) {
    this._multiple = coerceBooleanProperty(value);
    this._syncChipsState();
  }
  /**
   * A function to compare the option values with the selected values. The first argument
   * is a value from an option. The second is a value from the selection. A boolean
   * should be returned.
   */
  get compareWith() {
    return this._compareWith;
  }
  set compareWith(fn) {
    this._compareWith = fn;
    if (this._selectionModel) {
      this._initializeSelection();
    }
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  get value() {
    return this._value;
  }
  set value(value) {
    this.writeValue(value);
    this._value = value;
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  get id() {
    return this._chipInput ? this._chipInput.id : this._uid;
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  get required() {
    return this._required ?? this.ngControl?.control?.hasValidator(Validators.required) ?? false;
  }
  set required(value) {
    this._required = coerceBooleanProperty(value);
    this.stateChanges.next();
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  get placeholder() {
    return this._chipInput ? this._chipInput.placeholder : this._placeholder;
  }
  set placeholder(value) {
    this._placeholder = value;
    this.stateChanges.next();
  }
  /** Whether any chips or the matChipInput inside of this chip-list has focus. */
  get focused() {
    return this._chipInput && this._chipInput.focused || this._hasFocusedChip();
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  get empty() {
    return (!this._chipInput || this._chipInput.empty) && (!this.chips || this.chips.length === 0);
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  get shouldLabelFloat() {
    return !this.empty || this.focused;
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  get disabled() {
    return this.ngControl ? !!this.ngControl.disabled : this._disabled;
  }
  set disabled(value) {
    this._disabled = coerceBooleanProperty(value);
    this._syncChipsState();
  }
  /**
   * Whether or not this chip list is selectable. When a chip list is not selectable,
   * the selected states for all the chips inside the chip list are always ignored.
   */
  get selectable() {
    return this._selectable;
  }
  set selectable(value) {
    this._selectable = coerceBooleanProperty(value);
    if (this.chips) {
      this.chips.forEach((chip) => chip.chipListSelectable = this._selectable);
    }
  }
  set tabIndex(value) {
    this._userTabIndex = value;
    this._tabIndex = value;
  }
  /** Combined stream of all of the child chips' selection change events. */
  get chipSelectionChanges() {
    return merge(...this.chips.map((chip) => chip.selectionChange));
  }
  /** Combined stream of all of the child chips' focus change events. */
  get chipFocusChanges() {
    return merge(...this.chips.map((chip) => chip._onFocus));
  }
  /** Combined stream of all of the child chips' blur change events. */
  get chipBlurChanges() {
    return merge(...this.chips.map((chip) => chip._onBlur));
  }
  /** Combined stream of all of the child chips' remove change events. */
  get chipRemoveChanges() {
    return merge(...this.chips.map((chip) => chip.destroyed));
  }
  ngAfterContentInit() {
    this._keyManager = new FocusKeyManager(this.chips).withWrap().withVerticalOrientation().withHomeAndEnd().withHorizontalOrientation(this._dir ? this._dir.value : "ltr");
    if (this._dir) {
      this._dir.change.pipe(takeUntil(this._destroyed)).subscribe((dir) => this._keyManager.withHorizontalOrientation(dir));
    }
    this._keyManager.tabOut.pipe(takeUntil(this._destroyed)).subscribe(() => {
      this._allowFocusEscape();
    });
    this.chips.changes.pipe(startWith(null), takeUntil(this._destroyed)).subscribe(() => {
      if (this.disabled) {
        Promise.resolve().then(() => {
          this._syncChipsState();
        });
      }
      this._resetChips();
      this._initializeSelection();
      this._updateTabIndex();
      this._updateFocusForDestroyedChips();
      this.stateChanges.next();
    });
  }
  ngOnInit() {
    this._selectionModel = new SelectionModel(this.multiple, void 0, false);
    this.stateChanges.next();
  }
  ngDoCheck() {
    if (this.ngControl) {
      this.updateErrorState();
      if (this.ngControl.disabled !== this._disabled) {
        this.disabled = !!this.ngControl.disabled;
      }
    }
  }
  ngOnDestroy() {
    this._destroyed.next();
    this._destroyed.complete();
    this.stateChanges.complete();
    this._dropSubscriptions();
  }
  /** Associates an HTML input element with this chip list. */
  registerInput(inputElement) {
    this._chipInput = inputElement;
    this._elementRef.nativeElement.setAttribute("data-mat-chip-input", inputElement.id);
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  setDescribedByIds(ids) {
    this._ariaDescribedby = ids.join(" ");
  }
  // Implemented as part of ControlValueAccessor.
  writeValue(value) {
    if (this.chips) {
      this._setSelectionByValue(value, false);
    }
  }
  // Implemented as part of ControlValueAccessor.
  registerOnChange(fn) {
    this._onChange = fn;
  }
  // Implemented as part of ControlValueAccessor.
  registerOnTouched(fn) {
    this._onTouched = fn;
  }
  // Implemented as part of ControlValueAccessor.
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
    this.stateChanges.next();
  }
  /**
   * Implemented as part of MatFormFieldControl.
   * @docs-private
   */
  onContainerClick(event) {
    if (!this._originatesFromChip(event)) {
      this.focus();
    }
  }
  /**
   * Focuses the first non-disabled chip in this chip list, or the associated input when there
   * are no eligible chips.
   */
  focus(options) {
    if (this.disabled) {
      return;
    }
    if (this._chipInput && this._chipInput.focused) {
    } else if (this.chips.length > 0) {
      this._keyManager.setFirstItemActive();
      this.stateChanges.next();
    } else {
      this._focusInput(options);
      this.stateChanges.next();
    }
  }
  /** Attempt to focus an input if we have one. */
  _focusInput(options) {
    if (this._chipInput) {
      this._chipInput.focus(options);
    }
  }
  /**
   * Pass events to the keyboard manager. Available here for tests.
   */
  _keydown(event) {
    const target = event.target;
    if (target && target.classList.contains("mat-chip")) {
      this._keyManager.onKeydown(event);
      this.stateChanges.next();
    }
  }
  /**
   * Check the tab index as you should not be allowed to focus an empty list.
   */
  _updateTabIndex() {
    this._tabIndex = this._userTabIndex || (this.chips.length === 0 ? -1 : 0);
  }
  /**
   * If the amount of chips changed, we need to update the
   * key manager state and focus the next closest chip.
   */
  _updateFocusForDestroyedChips() {
    if (this._lastDestroyedChipIndex != null) {
      if (this.chips.length) {
        const newChipIndex = Math.min(this._lastDestroyedChipIndex, this.chips.length - 1);
        this._keyManager.setActiveItem(newChipIndex);
      } else {
        this.focus();
      }
    }
    this._lastDestroyedChipIndex = null;
  }
  /**
   * Utility to ensure all indexes are valid.
   *
   * @param index The index to be checked.
   * @returns True if the index is valid for our list of chips.
   */
  _isValidIndex(index) {
    return index >= 0 && index < this.chips.length;
  }
  _setSelectionByValue(value, isUserInput = true) {
    this._clearSelection();
    this.chips.forEach((chip) => chip.deselect());
    if (Array.isArray(value)) {
      value.forEach((currentValue) => this._selectValue(currentValue, isUserInput));
      this._sortValues();
    } else {
      const correspondingChip = this._selectValue(value, isUserInput);
      if (correspondingChip) {
        if (isUserInput) {
          this._keyManager.setActiveItem(correspondingChip);
        }
      }
    }
  }
  /**
   * Finds and selects the chip based on its value.
   * @returns Chip that has the corresponding value.
   */
  _selectValue(value, isUserInput = true) {
    const correspondingChip = this.chips.find((chip) => {
      return chip.value != null && this._compareWith(chip.value, value);
    });
    if (correspondingChip) {
      isUserInput ? correspondingChip.selectViaInteraction() : correspondingChip.select();
      this._selectionModel.select(correspondingChip);
    }
    return correspondingChip;
  }
  _initializeSelection() {
    Promise.resolve().then(() => {
      if (this.ngControl || this._value) {
        this._setSelectionByValue(this.ngControl ? this.ngControl.value : this._value, false);
        this.stateChanges.next();
      }
    });
  }
  /**
   * Deselects every chip in the list.
   * @param skip Chip that should not be deselected.
   */
  _clearSelection(skip2) {
    this._selectionModel.clear();
    this.chips.forEach((chip) => {
      if (chip !== skip2) {
        chip.deselect();
      }
    });
    this.stateChanges.next();
  }
  /**
   * Sorts the model values, ensuring that they keep the same
   * order that they have in the panel.
   */
  _sortValues() {
    if (this._multiple) {
      this._selectionModel.clear();
      this.chips.forEach((chip) => {
        if (chip.selected) {
          this._selectionModel.select(chip);
        }
      });
      this.stateChanges.next();
    }
  }
  /** Emits change event to set the model value. */
  _propagateChanges(fallbackValue) {
    let valueToEmit = null;
    if (Array.isArray(this.selected)) {
      valueToEmit = this.selected.map((chip) => chip.value);
    } else {
      valueToEmit = this.selected ? this.selected.value : fallbackValue;
    }
    this._value = valueToEmit;
    this.change.emit(new MatChipListChange(this, valueToEmit));
    this.valueChange.emit(valueToEmit);
    this._onChange(valueToEmit);
    this._changeDetectorRef.markForCheck();
  }
  /** When blurred, mark the field as touched when focus moved outside the chip list. */
  _blur() {
    if (!this._hasFocusedChip()) {
      this._keyManager.setActiveItem(-1);
    }
    if (!this.disabled) {
      if (this._chipInput) {
        setTimeout(() => {
          if (!this.focused) {
            this._markAsTouched();
          }
        });
      } else {
        this._markAsTouched();
      }
    }
  }
  /** Mark the field as touched */
  _markAsTouched() {
    this._onTouched();
    this._changeDetectorRef.markForCheck();
    this.stateChanges.next();
  }
  /**
   * Removes the `tabindex` from the chip list and resets it back afterwards, allowing the
   * user to tab out of it. This prevents the list from capturing focus and redirecting
   * it back to the first chip, creating a focus trap, if it user tries to tab away.
   */
  _allowFocusEscape() {
    if (this._tabIndex !== -1) {
      this._tabIndex = -1;
      setTimeout(() => {
        this._tabIndex = this._userTabIndex || 0;
        this._changeDetectorRef.markForCheck();
      });
    }
  }
  _resetChips() {
    this._dropSubscriptions();
    this._listenToChipsFocus();
    this._listenToChipsSelection();
    this._listenToChipsRemoved();
  }
  _dropSubscriptions() {
    if (this._chipFocusSubscription) {
      this._chipFocusSubscription.unsubscribe();
      this._chipFocusSubscription = null;
    }
    if (this._chipBlurSubscription) {
      this._chipBlurSubscription.unsubscribe();
      this._chipBlurSubscription = null;
    }
    if (this._chipSelectionSubscription) {
      this._chipSelectionSubscription.unsubscribe();
      this._chipSelectionSubscription = null;
    }
    if (this._chipRemoveSubscription) {
      this._chipRemoveSubscription.unsubscribe();
      this._chipRemoveSubscription = null;
    }
  }
  /** Listens to user-generated selection events on each chip. */
  _listenToChipsSelection() {
    this._chipSelectionSubscription = this.chipSelectionChanges.subscribe((event) => {
      event.source.selected ? this._selectionModel.select(event.source) : this._selectionModel.deselect(event.source);
      if (!this.multiple) {
        this.chips.forEach((chip) => {
          if (!this._selectionModel.isSelected(chip) && chip.selected) {
            chip.deselect();
          }
        });
      }
      if (event.isUserInput) {
        this._propagateChanges();
      }
    });
  }
  /** Listens to user-generated selection events on each chip. */
  _listenToChipsFocus() {
    this._chipFocusSubscription = this.chipFocusChanges.subscribe((event) => {
      let chipIndex = this.chips.toArray().indexOf(event.chip);
      if (this._isValidIndex(chipIndex)) {
        this._keyManager.updateActiveItem(chipIndex);
      }
      this.stateChanges.next();
    });
    this._chipBlurSubscription = this.chipBlurChanges.subscribe(() => {
      this._blur();
      this.stateChanges.next();
    });
  }
  _listenToChipsRemoved() {
    this._chipRemoveSubscription = this.chipRemoveChanges.subscribe((event) => {
      const chip = event.chip;
      const chipIndex = this.chips.toArray().indexOf(event.chip);
      if (this._isValidIndex(chipIndex) && chip._hasFocus) {
        this._lastDestroyedChipIndex = chipIndex;
      }
    });
  }
  /** Checks whether an event comes from inside a chip element. */
  _originatesFromChip(event) {
    let currentElement = event.target;
    while (currentElement && currentElement !== this._elementRef.nativeElement) {
      if (currentElement.classList.contains("mat-chip")) {
        return true;
      }
      currentElement = currentElement.parentElement;
    }
    return false;
  }
  /** Checks whether any of the chips is focused. */
  _hasFocusedChip() {
    return this.chips && this.chips.some((chip) => chip._hasFocus);
  }
  /** Syncs the list's state with the individual chips. */
  _syncChipsState() {
    if (this.chips) {
      this.chips.forEach((chip) => {
        chip._chipListDisabled = this._disabled;
        chip._chipListMultiple = this.multiple;
      });
    }
  }
};
MatChipList.ɵfac = function MatChipList_Factory(ɵt) {
  return new (ɵt || MatChipList)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(NgForm, 8), ɵɵdirectiveInject(FormGroupDirective, 8), ɵɵdirectiveInject(ErrorStateMatcher), ɵɵdirectiveInject(NgControl, 10));
};
MatChipList.ɵcmp = ɵɵdefineComponent({
  type: MatChipList,
  selectors: [["mat-chip-list"]],
  contentQueries: function MatChipList_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, MatChip, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.chips = _t);
    }
  },
  hostAttrs: [1, "mat-chip-list"],
  hostVars: 15,
  hostBindings: function MatChipList_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focus", function MatChipList_focus_HostBindingHandler() {
        return ctx.focus();
      })("blur", function MatChipList_blur_HostBindingHandler() {
        return ctx._blur();
      })("keydown", function MatChipList_keydown_HostBindingHandler($event) {
        return ctx._keydown($event);
      });
    }
    if (rf & 2) {
      ɵɵhostProperty("id", ctx._uid);
      ɵɵattribute("tabindex", ctx.disabled ? null : ctx._tabIndex)("aria-describedby", ctx._ariaDescribedby || null)("aria-required", ctx.role ? ctx.required : null)("aria-disabled", ctx.disabled.toString())("aria-invalid", ctx.errorState)("aria-multiselectable", ctx.multiple)("role", ctx.role)("aria-orientation", ctx.ariaOrientation);
      ɵɵclassProp("mat-chip-list-disabled", ctx.disabled)("mat-chip-list-invalid", ctx.errorState)("mat-chip-list-required", ctx.required);
    }
  },
  inputs: {
    errorStateMatcher: "errorStateMatcher",
    multiple: "multiple",
    compareWith: "compareWith",
    value: "value",
    required: "required",
    placeholder: "placeholder",
    disabled: "disabled",
    ariaOrientation: [0, "aria-orientation", "ariaOrientation"],
    selectable: "selectable",
    tabIndex: "tabIndex"
  },
  outputs: {
    change: "change",
    valueChange: "valueChange"
  },
  exportAs: ["matChipList"],
  features: [ɵɵProvidersFeature([{
    provide: MatFormFieldControl,
    useExisting: MatChipList
  }]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c05,
  decls: 2,
  vars: 0,
  consts: [[1, "mat-chip-list-wrapper"]],
  template: function MatChipList_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
  },
  styles: ['.mat-chip{position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;border:none;-webkit-appearance:none;-moz-appearance:none}.mat-standard-chip{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:inline-flex;padding:7px 12px;border-radius:16px;align-items:center;cursor:default;min-height:32px;height:1px}._mat-animation-noopable.mat-standard-chip{transition:none;animation:none}.mat-standard-chip .mat-chip-remove{border:none;-webkit-appearance:none;-moz-appearance:none;padding:0;background:none}.mat-standard-chip .mat-chip-remove.mat-icon,.mat-standard-chip .mat-chip-remove .mat-icon{width:18px;height:18px;font-size:18px}.mat-standard-chip::after{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit;opacity:0;content:"";pointer-events:none;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-standard-chip:hover::after{opacity:.12}.mat-standard-chip:focus{outline:none}.mat-standard-chip:focus::after{opacity:.16}.cdk-high-contrast-active .mat-standard-chip{outline:solid 1px}.cdk-high-contrast-active .mat-standard-chip:focus{outline:dotted 2px}.cdk-high-contrast-active .mat-standard-chip.mat-chip-selected{outline-width:3px}.mat-standard-chip.mat-chip-disabled::after{opacity:0}.mat-standard-chip.mat-chip-disabled .mat-chip-remove,.mat-standard-chip.mat-chip-disabled .mat-chip-trailing-icon{cursor:default}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar,.mat-standard-chip.mat-chip-with-avatar{padding-top:0;padding-bottom:0}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-right:8px;padding-left:0}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-left:8px;padding-right:0}.mat-standard-chip.mat-chip-with-trailing-icon{padding-top:7px;padding-bottom:7px;padding-right:8px;padding-left:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon{padding-left:8px;padding-right:12px}.mat-standard-chip.mat-chip-with-avatar{padding-left:0;padding-right:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-avatar{padding-right:0;padding-left:12px}.mat-standard-chip .mat-chip-avatar{width:24px;height:24px;margin-right:8px;margin-left:4px}[dir=rtl] .mat-standard-chip .mat-chip-avatar{margin-left:8px;margin-right:4px}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{width:18px;height:18px;cursor:pointer}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-standard-chip .mat-chip-remove,[dir=rtl] .mat-standard-chip .mat-chip-trailing-icon{margin-right:8px;margin-left:0}.mat-chip-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit;overflow:hidden;transform:translateZ(0)}.mat-chip-list-wrapper{display:flex;flex-direction:row;flex-wrap:wrap;align-items:center;margin:-4px}.mat-chip-list-wrapper input.mat-input-element,.mat-chip-list-wrapper .mat-standard-chip{margin:4px}.mat-chip-list-stacked .mat-chip-list-wrapper{flex-direction:column;align-items:flex-start}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-standard-chip{width:100%}.mat-chip-avatar{border-radius:50%;justify-content:center;align-items:center;display:flex;overflow:hidden;object-fit:cover}input.mat-chip-input{width:150px;margin:4px;flex:1 0 150px}\n'],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatChipList, [{
    type: Component,
    args: [{
      selector: "mat-chip-list",
      template: `<div class="mat-chip-list-wrapper"><ng-content></ng-content></div>`,
      exportAs: "matChipList",
      host: {
        "[attr.tabindex]": "disabled ? null : _tabIndex",
        "[attr.aria-describedby]": "_ariaDescribedby || null",
        "[attr.aria-required]": "role ? required : null",
        "[attr.aria-disabled]": "disabled.toString()",
        "[attr.aria-invalid]": "errorState",
        "[attr.aria-multiselectable]": "multiple",
        "[attr.role]": "role",
        "[class.mat-chip-list-disabled]": "disabled",
        "[class.mat-chip-list-invalid]": "errorState",
        "[class.mat-chip-list-required]": "required",
        "[attr.aria-orientation]": "ariaOrientation",
        "class": "mat-chip-list",
        "(focus)": "focus()",
        "(blur)": "_blur()",
        "(keydown)": "_keydown($event)",
        "[id]": "_uid"
      },
      providers: [{
        provide: MatFormFieldControl,
        useExisting: MatChipList
      }],
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: ['.mat-chip{position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;border:none;-webkit-appearance:none;-moz-appearance:none}.mat-standard-chip{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:inline-flex;padding:7px 12px;border-radius:16px;align-items:center;cursor:default;min-height:32px;height:1px}._mat-animation-noopable.mat-standard-chip{transition:none;animation:none}.mat-standard-chip .mat-chip-remove{border:none;-webkit-appearance:none;-moz-appearance:none;padding:0;background:none}.mat-standard-chip .mat-chip-remove.mat-icon,.mat-standard-chip .mat-chip-remove .mat-icon{width:18px;height:18px;font-size:18px}.mat-standard-chip::after{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit;opacity:0;content:"";pointer-events:none;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-standard-chip:hover::after{opacity:.12}.mat-standard-chip:focus{outline:none}.mat-standard-chip:focus::after{opacity:.16}.cdk-high-contrast-active .mat-standard-chip{outline:solid 1px}.cdk-high-contrast-active .mat-standard-chip:focus{outline:dotted 2px}.cdk-high-contrast-active .mat-standard-chip.mat-chip-selected{outline-width:3px}.mat-standard-chip.mat-chip-disabled::after{opacity:0}.mat-standard-chip.mat-chip-disabled .mat-chip-remove,.mat-standard-chip.mat-chip-disabled .mat-chip-trailing-icon{cursor:default}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar,.mat-standard-chip.mat-chip-with-avatar{padding-top:0;padding-bottom:0}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-right:8px;padding-left:0}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-left:8px;padding-right:0}.mat-standard-chip.mat-chip-with-trailing-icon{padding-top:7px;padding-bottom:7px;padding-right:8px;padding-left:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon{padding-left:8px;padding-right:12px}.mat-standard-chip.mat-chip-with-avatar{padding-left:0;padding-right:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-avatar{padding-right:0;padding-left:12px}.mat-standard-chip .mat-chip-avatar{width:24px;height:24px;margin-right:8px;margin-left:4px}[dir=rtl] .mat-standard-chip .mat-chip-avatar{margin-left:8px;margin-right:4px}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{width:18px;height:18px;cursor:pointer}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-standard-chip .mat-chip-remove,[dir=rtl] .mat-standard-chip .mat-chip-trailing-icon{margin-right:8px;margin-left:0}.mat-chip-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit;overflow:hidden;transform:translateZ(0)}.mat-chip-list-wrapper{display:flex;flex-direction:row;flex-wrap:wrap;align-items:center;margin:-4px}.mat-chip-list-wrapper input.mat-input-element,.mat-chip-list-wrapper .mat-standard-chip{margin:4px}.mat-chip-list-stacked .mat-chip-list-wrapper{flex-direction:column;align-items:flex-start}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-standard-chip{width:100%}.mat-chip-avatar{border-radius:50%;justify-content:center;align-items:center;display:flex;overflow:hidden;object-fit:cover}input.mat-chip-input{width:150px;margin:4px;flex:1 0 150px}\n']
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: Directionality,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgForm,
      decorators: [{
        type: Optional
      }]
    }, {
      type: FormGroupDirective,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ErrorStateMatcher
    }, {
      type: NgControl,
      decorators: [{
        type: Optional
      }, {
        type: Self
      }]
    }];
  }, {
    errorStateMatcher: [{
      type: Input
    }],
    multiple: [{
      type: Input
    }],
    compareWith: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    required: [{
      type: Input
    }],
    placeholder: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }],
    ariaOrientation: [{
      type: Input,
      args: ["aria-orientation"]
    }],
    selectable: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }],
    change: [{
      type: Output
    }],
    valueChange: [{
      type: Output
    }],
    chips: [{
      type: ContentChildren,
      args: [MatChip, {
        // We need to use `descendants: true`, because Ivy will no longer match
        // indirect descendants if it's left as false.
        descendants: true
      }]
    }]
  });
})();
var nextUniqueId2 = 0;
var MatChipInput = class {
  constructor(_elementRef, _defaultOptions) {
    this._elementRef = _elementRef;
    this._defaultOptions = _defaultOptions;
    this.focused = false;
    this._addOnBlur = false;
    this.separatorKeyCodes = this._defaultOptions.separatorKeyCodes;
    this.chipEnd = new EventEmitter();
    this.placeholder = "";
    this.id = `mat-chip-list-input-${nextUniqueId2++}`;
    this._disabled = false;
    this.inputElement = this._elementRef.nativeElement;
  }
  /** Register input for chip list */
  set chipList(value) {
    if (value) {
      this._chipList = value;
      this._chipList.registerInput(this);
    }
  }
  /**
   * Whether or not the chipEnd event will be emitted when the input is blurred.
   */
  get addOnBlur() {
    return this._addOnBlur;
  }
  set addOnBlur(value) {
    this._addOnBlur = coerceBooleanProperty(value);
  }
  /** Whether the input is disabled. */
  get disabled() {
    return this._disabled || this._chipList && this._chipList.disabled;
  }
  set disabled(value) {
    this._disabled = coerceBooleanProperty(value);
  }
  /** Whether the input is empty. */
  get empty() {
    return !this.inputElement.value;
  }
  ngOnChanges() {
    this._chipList.stateChanges.next();
  }
  ngOnDestroy() {
    this.chipEnd.complete();
  }
  ngAfterContentInit() {
    this._focusLastChipOnBackspace = this.empty;
  }
  /** Utility method to make host definition/tests more clear. */
  _keydown(event) {
    if (event) {
      if (event.keyCode === TAB && !hasModifierKey(event, "shiftKey")) {
        this._chipList._allowFocusEscape();
      }
      if (event.keyCode === BACKSPACE && this._focusLastChipOnBackspace) {
        this._chipList._keyManager.setLastItemActive();
        event.preventDefault();
        return;
      } else {
        this._focusLastChipOnBackspace = false;
      }
    }
    this._emitChipEnd(event);
  }
  /**
   * Pass events to the keyboard manager. Available here for tests.
   */
  _keyup(event) {
    if (!this._focusLastChipOnBackspace && event.keyCode === BACKSPACE && this.empty) {
      this._focusLastChipOnBackspace = true;
      event.preventDefault();
    }
  }
  /** Checks to see if the blur should emit the (chipEnd) event. */
  _blur() {
    if (this.addOnBlur) {
      this._emitChipEnd();
    }
    this.focused = false;
    if (!this._chipList.focused) {
      this._chipList._blur();
    }
    this._chipList.stateChanges.next();
  }
  _focus() {
    this.focused = true;
    this._focusLastChipOnBackspace = this.empty;
    this._chipList.stateChanges.next();
  }
  /** Checks to see if the (chipEnd) event needs to be emitted. */
  _emitChipEnd(event) {
    if (!this.inputElement.value && !!event) {
      this._chipList._keydown(event);
    }
    if (!event || this._isSeparatorKey(event)) {
      this.chipEnd.emit({
        input: this.inputElement,
        value: this.inputElement.value,
        chipInput: this
      });
      event?.preventDefault();
    }
  }
  _onInput() {
    this._chipList.stateChanges.next();
  }
  /** Focuses the input. */
  focus(options) {
    this.inputElement.focus(options);
  }
  /** Clears the input */
  clear() {
    this.inputElement.value = "";
    this._focusLastChipOnBackspace = true;
  }
  /** Checks whether a keycode is one of the configured separators. */
  _isSeparatorKey(event) {
    return !hasModifierKey(event) && new Set(this.separatorKeyCodes).has(event.keyCode);
  }
};
MatChipInput.ɵfac = function MatChipInput_Factory(ɵt) {
  return new (ɵt || MatChipInput)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(MAT_CHIPS_DEFAULT_OPTIONS));
};
MatChipInput.ɵdir = ɵɵdefineDirective({
  type: MatChipInput,
  selectors: [["input", "matChipInputFor", ""]],
  hostAttrs: [1, "mat-chip-input", "mat-input-element"],
  hostVars: 5,
  hostBindings: function MatChipInput_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("keydown", function MatChipInput_keydown_HostBindingHandler($event) {
        return ctx._keydown($event);
      })("keyup", function MatChipInput_keyup_HostBindingHandler($event) {
        return ctx._keyup($event);
      })("blur", function MatChipInput_blur_HostBindingHandler() {
        return ctx._blur();
      })("focus", function MatChipInput_focus_HostBindingHandler() {
        return ctx._focus();
      })("input", function MatChipInput_input_HostBindingHandler() {
        return ctx._onInput();
      });
    }
    if (rf & 2) {
      ɵɵhostProperty("id", ctx.id);
      ɵɵattribute("disabled", ctx.disabled || null)("placeholder", ctx.placeholder || null)("aria-invalid", ctx._chipList && ctx._chipList.ngControl ? ctx._chipList.ngControl.invalid : null)("aria-required", ctx._chipList && ctx._chipList.required || null);
    }
  },
  inputs: {
    chipList: [0, "matChipInputFor", "chipList"],
    addOnBlur: [0, "matChipInputAddOnBlur", "addOnBlur"],
    separatorKeyCodes: [0, "matChipInputSeparatorKeyCodes", "separatorKeyCodes"],
    placeholder: "placeholder",
    id: "id",
    disabled: "disabled"
  },
  outputs: {
    chipEnd: "matChipInputTokenEnd"
  },
  exportAs: ["matChipInput", "matChipInputFor"],
  features: [ɵɵNgOnChangesFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatChipInput, [{
    type: Directive,
    args: [{
      selector: "input[matChipInputFor]",
      exportAs: "matChipInput, matChipInputFor",
      host: {
        "class": "mat-chip-input mat-input-element",
        "(keydown)": "_keydown($event)",
        "(keyup)": "_keyup($event)",
        "(blur)": "_blur()",
        "(focus)": "_focus()",
        "(input)": "_onInput()",
        "[id]": "id",
        "[attr.disabled]": "disabled || null",
        "[attr.placeholder]": "placeholder || null",
        "[attr.aria-invalid]": "_chipList && _chipList.ngControl ? _chipList.ngControl.invalid : null",
        "[attr.aria-required]": "_chipList && _chipList.required || null"
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [MAT_CHIPS_DEFAULT_OPTIONS]
      }]
    }];
  }, {
    chipList: [{
      type: Input,
      args: ["matChipInputFor"]
    }],
    addOnBlur: [{
      type: Input,
      args: ["matChipInputAddOnBlur"]
    }],
    separatorKeyCodes: [{
      type: Input,
      args: ["matChipInputSeparatorKeyCodes"]
    }],
    chipEnd: [{
      type: Output,
      args: ["matChipInputTokenEnd"]
    }],
    placeholder: [{
      type: Input
    }],
    id: [{
      type: Input
    }],
    disabled: [{
      type: Input
    }]
  });
})();
var CHIP_DECLARATIONS = [MatChipList, MatChip, MatChipInput, MatChipRemove, MatChipAvatar, MatChipTrailingIcon];
var MatChipsModule = class {
};
MatChipsModule.ɵfac = function MatChipsModule_Factory(ɵt) {
  return new (ɵt || MatChipsModule)();
};
MatChipsModule.ɵmod = ɵɵdefineNgModule({
  type: MatChipsModule,
  declarations: [MatChipList, MatChip, MatChipInput, MatChipRemove, MatChipAvatar, MatChipTrailingIcon],
  imports: [MatCommonModule],
  exports: [MatChipList, MatChip, MatChipInput, MatChipRemove, MatChipAvatar, MatChipTrailingIcon]
});
MatChipsModule.ɵinj = ɵɵdefineInjector({
  providers: [ErrorStateMatcher, {
    provide: MAT_CHIPS_DEFAULT_OPTIONS,
    useValue: {
      separatorKeyCodes: [ENTER]
    }
  }],
  imports: [[MatCommonModule]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatChipsModule, [{
    type: NgModule,
    args: [{
      imports: [MatCommonModule],
      exports: CHIP_DECLARATIONS,
      declarations: CHIP_DECLARATIONS,
      providers: [ErrorStateMatcher, {
        provide: MAT_CHIPS_DEFAULT_OPTIONS,
        useValue: {
          separatorKeyCodes: [ENTER]
        }
      }]
    }]
  }], null, null);
})();

// node_modules/@angular/material/fesm2020/stepper.mjs
function MatStepHeader_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainer(0, 8);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngTemplateOutlet", ctx_r0.iconOverrides[ctx_r0.state])("ngTemplateOutletContext", ctx_r0._getIconContext());
  }
}
function MatStepHeader_ng_container_4_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 13);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0._getDefaultTextForState(ctx_r0.state));
  }
}
function MatStepHeader_ng_container_4_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 14);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0._intl.completedLabel);
  }
}
function MatStepHeader_ng_container_4_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 14);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0._intl.editableLabel);
  }
}
function MatStepHeader_ng_container_4_mat_icon_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon", 13);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0._getDefaultTextForState(ctx_r0.state));
  }
}
function MatStepHeader_ng_container_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 9);
    ɵɵtemplate(1, MatStepHeader_ng_container_4_span_1_Template, 2, 1, "span", 10)(2, MatStepHeader_ng_container_4_span_2_Template, 2, 1, "span", 11)(3, MatStepHeader_ng_container_4_span_3_Template, 2, 1, "span", 11)(4, MatStepHeader_ng_container_4_mat_icon_4_Template, 2, 1, "mat-icon", 12);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("ngSwitch", ctx_r0.state);
    ɵɵadvance();
    ɵɵproperty("ngSwitchCase", "number");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.state === "done");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r0.state === "edit");
  }
}
function MatStepHeader_div_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 15);
    ɵɵelementContainer(1, 16);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", ctx_r0._templateLabel().template);
  }
}
function MatStepHeader_div_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 15);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.label);
  }
}
function MatStepHeader_div_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 17);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0._intl.optionalLabel);
  }
}
function MatStepHeader_div_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 18);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵtextInterpolate(ctx_r0.errorMessage);
  }
}
var _c06 = ["*"];
function MatStep_ng_template_0_ng_template_1_Template(rf, ctx) {
}
function MatStep_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
    ɵɵtemplate(1, MatStep_ng_template_0_ng_template_1_Template, 0, 0, "ng-template", 0);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("cdkPortalOutlet", ctx_r0._portal);
  }
}
var _c13 = (a0, a1) => ({
  step: a0,
  i: a1
});
function MatStepper_ng_container_1_ng_container_2_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "div", 9);
  }
}
function MatStepper_ng_container_1_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementContainer(1, 7);
    ɵɵtemplate(2, MatStepper_ng_container_1_ng_container_2_div_2_Template, 1, 0, "div", 8);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const step_r1 = ctx.$implicit;
    const i_r2 = ctx.index;
    const isLast_r3 = ctx.last;
    ɵɵnextContext(2);
    const stepTemplate_r4 = ɵɵreference(4);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", stepTemplate_r4)("ngTemplateOutletContext", ɵɵpureFunction2(3, _c13, step_r1, i_r2));
    ɵɵadvance();
    ɵɵproperty("ngIf", !isLast_r3);
  }
}
function MatStepper_ng_container_1_div_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 10);
    ɵɵlistener("@horizontalStepTransition.done", function MatStepper_ng_container_1_div_4_Template_div_animation_horizontalStepTransition_done_0_listener($event) {
      ɵɵrestoreView(_r5);
      const ctx_r5 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r5._animationDone.next($event));
    });
    ɵɵelementContainer(1, 11);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const step_r7 = ctx.$implicit;
    const i_r8 = ctx.index;
    const ctx_r5 = ɵɵnextContext(2);
    ɵɵproperty("@horizontalStepTransition", ctx_r5._getAnimationDirection(i_r8))("id", ctx_r5._getStepContentId(i_r8));
    ɵɵattribute("aria-labelledby", ctx_r5._getStepLabelId(i_r8))("aria-expanded", ctx_r5.selectedIndex === i_r8);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", step_r7.content);
  }
}
function MatStepper_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "div", 3);
    ɵɵtemplate(2, MatStepper_ng_container_1_ng_container_2_Template, 3, 6, "ng-container", 4);
    ɵɵelementEnd();
    ɵɵelementStart(3, "div", 5);
    ɵɵtemplate(4, MatStepper_ng_container_1_div_4_Template, 2, 5, "div", 6);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r5.steps);
    ɵɵadvance(2);
    ɵɵproperty("ngForOf", ctx_r5.steps);
  }
}
function MatStepper_ng_container_2_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 13);
    ɵɵelementContainer(1, 7);
    ɵɵelementStart(2, "div", 14)(3, "div", 15);
    ɵɵlistener("@verticalStepTransition.done", function MatStepper_ng_container_2_div_1_Template_div_animation_verticalStepTransition_done_3_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r5 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r5._animationDone.next($event));
    });
    ɵɵelementStart(4, "div", 16);
    ɵɵelementContainer(5, 11);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const step_r10 = ctx.$implicit;
    const i_r11 = ctx.index;
    const isLast_r12 = ctx.last;
    const ctx_r5 = ɵɵnextContext(2);
    const stepTemplate_r4 = ɵɵreference(4);
    ɵɵadvance();
    ɵɵproperty("ngTemplateOutlet", stepTemplate_r4)("ngTemplateOutletContext", ɵɵpureFunction2(9, _c13, step_r10, i_r11));
    ɵɵadvance();
    ɵɵclassProp("mat-stepper-vertical-line", !isLast_r12);
    ɵɵadvance();
    ɵɵproperty("@verticalStepTransition", ctx_r5._getAnimationDirection(i_r11))("id", ctx_r5._getStepContentId(i_r11));
    ɵɵattribute("aria-labelledby", ctx_r5._getStepLabelId(i_r11))("aria-expanded", ctx_r5.selectedIndex === i_r11);
    ɵɵadvance(2);
    ɵɵproperty("ngTemplateOutlet", step_r10.content);
  }
}
function MatStepper_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, MatStepper_ng_container_2_div_1_Template, 6, 12, "div", 12);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const ctx_r5 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r5.steps);
  }
}
function MatStepper_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-step-header", 17);
    ɵɵlistener("click", function MatStepper_ng_template_3_Template_mat_step_header_click_0_listener() {
      const step_r14 = ɵɵrestoreView(_r13).step;
      return ɵɵresetView(step_r14.select());
    })("keydown", function MatStepper_ng_template_3_Template_mat_step_header_keydown_0_listener($event) {
      ɵɵrestoreView(_r13);
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5._onKeydown($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const step_r14 = ctx.step;
    const i_r15 = ctx.i;
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassProp("mat-horizontal-stepper-header", ctx_r5.orientation === "horizontal")("mat-vertical-stepper-header", ctx_r5.orientation === "vertical");
    ɵɵproperty("tabIndex", ctx_r5._getFocusIndex() === i_r15 ? 0 : -1)("id", ctx_r5._getStepLabelId(i_r15))("index", i_r15)("state", ctx_r5._getIndicatorType(i_r15, step_r14.state))("label", step_r14.stepLabel || step_r14.label)("selected", ctx_r5.selectedIndex === i_r15)("active", ctx_r5._stepIsNavigable(i_r15, step_r14))("optional", step_r14.optional)("errorMessage", step_r14.errorMessage)("iconOverrides", ctx_r5._iconOverrides)("disableRipple", ctx_r5.disableRipple || !ctx_r5._stepIsNavigable(i_r15, step_r14))("color", step_r14.color || ctx_r5.color);
    ɵɵattribute("aria-posinset", i_r15 + 1)("aria-setsize", ctx_r5.steps.length)("aria-controls", ctx_r5._getStepContentId(i_r15))("aria-selected", ctx_r5.selectedIndex == i_r15)("aria-label", step_r14.ariaLabel || null)("aria-labelledby", !step_r14.ariaLabel && step_r14.ariaLabelledby ? step_r14.ariaLabelledby : null)("aria-disabled", ctx_r5._stepIsNavigable(i_r15, step_r14) ? null : true);
  }
}
var MatStepLabel = class extends CdkStepLabel {
};
MatStepLabel.ɵfac = /* @__PURE__ */ (() => {
  let ɵMatStepLabel_BaseFactory;
  return function MatStepLabel_Factory(ɵt) {
    return (ɵMatStepLabel_BaseFactory || (ɵMatStepLabel_BaseFactory = ɵɵgetInheritedFactory(MatStepLabel)))(ɵt || MatStepLabel);
  };
})();
MatStepLabel.ɵdir = ɵɵdefineDirective({
  type: MatStepLabel,
  selectors: [["", "matStepLabel", ""]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatStepLabel, [{
    type: Directive,
    args: [{
      selector: "[matStepLabel]"
    }]
  }], null, null);
})();
var MatStepperIntl = class {
  constructor() {
    this.changes = new Subject();
    this.optionalLabel = "Optional";
    this.completedLabel = "Completed";
    this.editableLabel = "Editable";
  }
};
MatStepperIntl.ɵfac = function MatStepperIntl_Factory(ɵt) {
  return new (ɵt || MatStepperIntl)();
};
MatStepperIntl.ɵprov = ɵɵdefineInjectable({
  token: MatStepperIntl,
  factory: MatStepperIntl.ɵfac,
  providedIn: "root"
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatStepperIntl, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function MAT_STEPPER_INTL_PROVIDER_FACTORY(parentIntl) {
  return parentIntl || new MatStepperIntl();
}
var MAT_STEPPER_INTL_PROVIDER = {
  provide: MatStepperIntl,
  deps: [[new Optional(), new SkipSelf(), MatStepperIntl]],
  useFactory: MAT_STEPPER_INTL_PROVIDER_FACTORY
};
var _MatStepHeaderBase = mixinColor(class MatStepHeaderBase extends CdkStepHeader {
  constructor(elementRef) {
    super(elementRef);
  }
}, "primary");
var MatStepHeader = class extends _MatStepHeaderBase {
  constructor(_intl, _focusMonitor, _elementRef, changeDetectorRef) {
    super(_elementRef);
    this._intl = _intl;
    this._focusMonitor = _focusMonitor;
    this._intlSubscription = _intl.changes.subscribe(() => changeDetectorRef.markForCheck());
  }
  ngAfterViewInit() {
    this._focusMonitor.monitor(this._elementRef, true);
  }
  ngOnDestroy() {
    this._intlSubscription.unsubscribe();
    this._focusMonitor.stopMonitoring(this._elementRef);
  }
  /** Focuses the step header. */
  focus(origin, options) {
    if (origin) {
      this._focusMonitor.focusVia(this._elementRef, origin, options);
    } else {
      this._elementRef.nativeElement.focus(options);
    }
  }
  /** Returns string label of given step if it is a text label. */
  _stringLabel() {
    return this.label instanceof MatStepLabel ? null : this.label;
  }
  /** Returns MatStepLabel if the label of given step is a template label. */
  _templateLabel() {
    return this.label instanceof MatStepLabel ? this.label : null;
  }
  /** Returns the host HTML element. */
  _getHostElement() {
    return this._elementRef.nativeElement;
  }
  /** Template context variables that are exposed to the `matStepperIcon` instances. */
  _getIconContext() {
    return {
      index: this.index,
      active: this.active,
      optional: this.optional
    };
  }
  _getDefaultTextForState(state2) {
    if (state2 == "number") {
      return `${this.index + 1}`;
    }
    if (state2 == "edit") {
      return "create";
    }
    if (state2 == "error") {
      return "warning";
    }
    return state2;
  }
};
MatStepHeader.ɵfac = function MatStepHeader_Factory(ɵt) {
  return new (ɵt || MatStepHeader)(ɵɵdirectiveInject(MatStepperIntl), ɵɵdirectiveInject(FocusMonitor), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef));
};
MatStepHeader.ɵcmp = ɵɵdefineComponent({
  type: MatStepHeader,
  selectors: [["mat-step-header"]],
  hostAttrs: ["role", "tab", 1, "mat-step-header"],
  inputs: {
    color: "color",
    state: "state",
    label: "label",
    errorMessage: "errorMessage",
    iconOverrides: "iconOverrides",
    index: "index",
    selected: "selected",
    active: "active",
    optional: "optional",
    disableRipple: "disableRipple"
  },
  features: [ɵɵInheritDefinitionFeature],
  decls: 10,
  vars: 19,
  consts: [["matRipple", "", 1, "mat-step-header-ripple", "mat-focus-indicator", 3, "matRippleTrigger", "matRippleDisabled"], [1, "mat-step-icon-content", 3, "ngSwitch"], [3, "ngTemplateOutlet", "ngTemplateOutletContext", 4, "ngSwitchCase"], [3, "ngSwitch", 4, "ngSwitchDefault"], [1, "mat-step-label"], ["class", "mat-step-text-label", 4, "ngIf"], ["class", "mat-step-optional", 4, "ngIf"], ["class", "mat-step-sub-label-error", 4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "ngSwitch"], ["aria-hidden", "true", 4, "ngSwitchCase"], ["class", "cdk-visually-hidden", 4, "ngIf"], ["aria-hidden", "true", 4, "ngSwitchDefault"], ["aria-hidden", "true"], [1, "cdk-visually-hidden"], [1, "mat-step-text-label"], [3, "ngTemplateOutlet"], [1, "mat-step-optional"], [1, "mat-step-sub-label-error"]],
  template: function MatStepHeader_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelement(0, "div", 0);
      ɵɵelementStart(1, "div")(2, "div", 1);
      ɵɵtemplate(3, MatStepHeader_ng_container_3_Template, 1, 2, "ng-container", 2)(4, MatStepHeader_ng_container_4_Template, 5, 4, "ng-container", 3);
      ɵɵelementEnd()();
      ɵɵelementStart(5, "div", 4);
      ɵɵtemplate(6, MatStepHeader_div_6_Template, 2, 1, "div", 5)(7, MatStepHeader_div_7_Template, 2, 1, "div", 5)(8, MatStepHeader_div_8_Template, 2, 1, "div", 6)(9, MatStepHeader_div_9_Template, 2, 1, "div", 7);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("matRippleTrigger", ctx._getHostElement())("matRippleDisabled", ctx.disableRipple);
      ɵɵadvance();
      ɵɵclassMapInterpolate1("mat-step-icon-state-", ctx.state, " mat-step-icon");
      ɵɵclassProp("mat-step-icon-selected", ctx.selected);
      ɵɵadvance();
      ɵɵproperty("ngSwitch", !!(ctx.iconOverrides && ctx.iconOverrides[ctx.state]));
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", true);
      ɵɵadvance(2);
      ɵɵclassProp("mat-step-label-active", ctx.active)("mat-step-label-selected", ctx.selected)("mat-step-label-error", ctx.state == "error");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx._templateLabel());
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx._stringLabel());
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.optional && ctx.state != "error");
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.state == "error");
    }
  },
  dependencies: [MatIcon, MatRipple, NgSwitch, NgSwitchCase, NgTemplateOutlet, NgSwitchDefault, NgIf],
  styles: [".mat-step-header{overflow:hidden;outline:none;cursor:pointer;position:relative;box-sizing:content-box;-webkit-tap-highlight-color:transparent}.cdk-high-contrast-active .mat-step-header{outline:solid 1px}.cdk-high-contrast-active .mat-step-header.cdk-keyboard-focused,.cdk-high-contrast-active .mat-step-header.cdk-program-focused{outline:solid 3px}.cdk-high-contrast-active .mat-step-header[aria-selected=true] .mat-step-label{text-decoration:underline}.mat-step-optional,.mat-step-sub-label-error{font-size:12px}.mat-step-icon{border-radius:50%;height:24px;width:24px;flex-shrink:0;position:relative}.mat-step-icon-content{position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);display:flex}.mat-step-icon .mat-icon{font-size:16px;height:16px;width:16px}.mat-step-icon-state-error .mat-icon{font-size:24px;height:24px;width:24px}.mat-step-label{display:inline-block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;min-width:50px;vertical-align:middle}.mat-step-text-label{text-overflow:ellipsis;overflow:hidden}.mat-step-header .mat-step-header-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\n"],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatStepHeader, [{
    type: Component,
    args: [{
      selector: "mat-step-header",
      inputs: ["color"],
      host: {
        "class": "mat-step-header",
        "role": "tab"
      },
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<div class="mat-step-header-ripple mat-focus-indicator" matRipple
     [matRippleTrigger]="_getHostElement()"
     [matRippleDisabled]="disableRipple"></div>

<div class="mat-step-icon-state-{{state}} mat-step-icon" [class.mat-step-icon-selected]="selected">
  <div class="mat-step-icon-content" [ngSwitch]="!!(iconOverrides && iconOverrides[state])">
    <ng-container
      *ngSwitchCase="true"
      [ngTemplateOutlet]="iconOverrides[state]"
      [ngTemplateOutletContext]="_getIconContext()"></ng-container>
    <ng-container *ngSwitchDefault [ngSwitch]="state">
      <span aria-hidden="true" *ngSwitchCase="'number'">{{_getDefaultTextForState(state)}}</span>
      <span class="cdk-visually-hidden" *ngIf="state === 'done'">{{_intl.completedLabel}}</span>
      <span class="cdk-visually-hidden" *ngIf="state === 'edit'">{{_intl.editableLabel}}</span>
      <mat-icon aria-hidden="true" *ngSwitchDefault>{{_getDefaultTextForState(state)}}</mat-icon>
    </ng-container>
  </div>
</div>
<div class="mat-step-label"
     [class.mat-step-label-active]="active"
     [class.mat-step-label-selected]="selected"
     [class.mat-step-label-error]="state == 'error'">
  <!-- If there is a label template, use it. -->
  <div class="mat-step-text-label" *ngIf="_templateLabel()">
    <ng-container [ngTemplateOutlet]="_templateLabel()!.template"></ng-container>
  </div>
  <!-- If there is no label template, fall back to the text label. -->
  <div class="mat-step-text-label" *ngIf="_stringLabel()">{{label}}</div>

  <div class="mat-step-optional" *ngIf="optional && state != 'error'">{{_intl.optionalLabel}}</div>
  <div class="mat-step-sub-label-error" *ngIf="state == 'error'">{{errorMessage}}</div>
</div>

`,
      styles: [".mat-step-header{overflow:hidden;outline:none;cursor:pointer;position:relative;box-sizing:content-box;-webkit-tap-highlight-color:transparent}.cdk-high-contrast-active .mat-step-header{outline:solid 1px}.cdk-high-contrast-active .mat-step-header.cdk-keyboard-focused,.cdk-high-contrast-active .mat-step-header.cdk-program-focused{outline:solid 3px}.cdk-high-contrast-active .mat-step-header[aria-selected=true] .mat-step-label{text-decoration:underline}.mat-step-optional,.mat-step-sub-label-error{font-size:12px}.mat-step-icon{border-radius:50%;height:24px;width:24px;flex-shrink:0;position:relative}.mat-step-icon-content{position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);display:flex}.mat-step-icon .mat-icon{font-size:16px;height:16px;width:16px}.mat-step-icon-state-error .mat-icon{font-size:24px;height:24px;width:24px}.mat-step-label{display:inline-block;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;min-width:50px;vertical-align:middle}.mat-step-text-label{text-overflow:ellipsis;overflow:hidden}.mat-step-header .mat-step-header-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\n"]
    }]
  }], function() {
    return [{
      type: MatStepperIntl
    }, {
      type: FocusMonitor
    }, {
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    state: [{
      type: Input
    }],
    label: [{
      type: Input
    }],
    errorMessage: [{
      type: Input
    }],
    iconOverrides: [{
      type: Input
    }],
    index: [{
      type: Input
    }],
    selected: [{
      type: Input
    }],
    active: [{
      type: Input
    }],
    optional: [{
      type: Input
    }],
    disableRipple: [{
      type: Input
    }]
  });
})();
var matStepperAnimations = {
  /** Animation that transitions the step along the X axis in a horizontal stepper. */
  horizontalStepTransition: trigger("horizontalStepTransition", [
    state("previous", style({
      transform: "translate3d(-100%, 0, 0)",
      visibility: "hidden"
    })),
    // Transition to `inherit`, rather than `visible`,
    // because visibility on a child element the one from the parent,
    // making this element focusable inside of a `hidden` element.
    state("current", style({
      transform: "none",
      visibility: "inherit"
    })),
    state("next", style({
      transform: "translate3d(100%, 0, 0)",
      visibility: "hidden"
    })),
    transition("* => *", animate("500ms cubic-bezier(0.35, 0, 0.25, 1)"))
  ]),
  /** Animation that transitions the step along the Y axis in a vertical stepper. */
  verticalStepTransition: trigger("verticalStepTransition", [
    state("previous", style({
      height: "0px",
      visibility: "hidden"
    })),
    state("next", style({
      height: "0px",
      visibility: "hidden"
    })),
    // Transition to `inherit`, rather than `visible`,
    // because visibility on a child element the one from the parent,
    // making this element focusable inside of a `hidden` element.
    state("current", style({
      height: "*",
      visibility: "inherit"
    })),
    transition("* <=> current", animate("225ms cubic-bezier(0.4, 0.0, 0.2, 1)"))
  ])
};
var MatStepperIcon = class {
  constructor(templateRef) {
    this.templateRef = templateRef;
  }
};
MatStepperIcon.ɵfac = function MatStepperIcon_Factory(ɵt) {
  return new (ɵt || MatStepperIcon)(ɵɵdirectiveInject(TemplateRef));
};
MatStepperIcon.ɵdir = ɵɵdefineDirective({
  type: MatStepperIcon,
  selectors: [["ng-template", "matStepperIcon", ""]],
  inputs: {
    name: [0, "matStepperIcon", "name"]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatStepperIcon, [{
    type: Directive,
    args: [{
      selector: "ng-template[matStepperIcon]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, {
    name: [{
      type: Input,
      args: ["matStepperIcon"]
    }]
  });
})();
var MatStepContent = class {
  constructor(_template) {
    this._template = _template;
  }
};
MatStepContent.ɵfac = function MatStepContent_Factory(ɵt) {
  return new (ɵt || MatStepContent)(ɵɵdirectiveInject(TemplateRef));
};
MatStepContent.ɵdir = ɵɵdefineDirective({
  type: MatStepContent,
  selectors: [["ng-template", "matStepContent", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatStepContent, [{
    type: Directive,
    args: [{
      selector: "ng-template[matStepContent]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var MatStep = class extends CdkStep {
  constructor(stepper, _errorStateMatcher, _viewContainerRef, stepperOptions) {
    super(stepper, stepperOptions);
    this._errorStateMatcher = _errorStateMatcher;
    this._viewContainerRef = _viewContainerRef;
    this._isSelected = Subscription.EMPTY;
  }
  ngAfterContentInit() {
    this._isSelected = this._stepper.steps.changes.pipe(switchMap(() => {
      return this._stepper.selectionChange.pipe(map((event) => event.selectedStep === this), startWith(this._stepper.selected === this));
    })).subscribe((isSelected) => {
      if (isSelected && this._lazyContent && !this._portal) {
        this._portal = new TemplatePortal(this._lazyContent._template, this._viewContainerRef);
      }
    });
  }
  ngOnDestroy() {
    this._isSelected.unsubscribe();
  }
  /** Custom error state matcher that additionally checks for validity of interacted form. */
  isErrorState(control, form) {
    const originalErrorState = this._errorStateMatcher.isErrorState(control, form);
    const customErrorState = !!(control && control.invalid && this.interacted);
    return originalErrorState || customErrorState;
  }
};
MatStep.ɵfac = function MatStep_Factory(ɵt) {
  return new (ɵt || MatStep)(ɵɵdirectiveInject(forwardRef(() => MatStepper)), ɵɵdirectiveInject(ErrorStateMatcher, 4), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(STEPPER_GLOBAL_OPTIONS, 8));
};
MatStep.ɵcmp = ɵɵdefineComponent({
  type: MatStep,
  selectors: [["mat-step"]],
  contentQueries: function MatStep_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, MatStepLabel, 5);
      ɵɵcontentQuery(dirIndex, MatStepContent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.stepLabel = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._lazyContent = _t.first);
    }
  },
  inputs: {
    color: "color"
  },
  exportAs: ["matStep"],
  features: [ɵɵProvidersFeature([{
    provide: ErrorStateMatcher,
    useExisting: MatStep
  }, {
    provide: CdkStep,
    useExisting: MatStep
  }]), ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c06,
  decls: 1,
  vars: 0,
  consts: [[3, "cdkPortalOutlet"]],
  template: function MatStep_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, MatStep_ng_template_0_Template, 2, 1, "ng-template");
    }
  },
  dependencies: [CdkPortalOutlet],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatStep, [{
    type: Component,
    args: [{
      selector: "mat-step",
      providers: [{
        provide: ErrorStateMatcher,
        useExisting: MatStep
      }, {
        provide: CdkStep,
        useExisting: MatStep
      }],
      encapsulation: ViewEncapsulation$1.None,
      exportAs: "matStep",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<ng-template>\n  <ng-content></ng-content>\n  <ng-template [cdkPortalOutlet]="_portal"></ng-template>\n</ng-template>\n'
    }]
  }], function() {
    return [{
      type: MatStepper,
      decorators: [{
        type: Inject,
        args: [forwardRef(() => MatStepper)]
      }]
    }, {
      type: ErrorStateMatcher,
      decorators: [{
        type: SkipSelf
      }]
    }, {
      type: ViewContainerRef
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [STEPPER_GLOBAL_OPTIONS]
      }]
    }];
  }, {
    stepLabel: [{
      type: ContentChild,
      args: [MatStepLabel]
    }],
    color: [{
      type: Input
    }],
    _lazyContent: [{
      type: ContentChild,
      args: [MatStepContent, {
        static: false
      }]
    }]
  });
})();
var _MatProxyStepperBase = class extends CdkStepper {
};
_MatProxyStepperBase.ɵfac = /* @__PURE__ */ (() => {
  let ɵ_MatProxyStepperBase_BaseFactory;
  return function _MatProxyStepperBase_Factory(ɵt) {
    return (ɵ_MatProxyStepperBase_BaseFactory || (ɵ_MatProxyStepperBase_BaseFactory = ɵɵgetInheritedFactory(_MatProxyStepperBase)))(ɵt || _MatProxyStepperBase);
  };
})();
_MatProxyStepperBase.ɵdir = ɵɵdefineDirective({
  type: _MatProxyStepperBase,
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_MatProxyStepperBase, [{
    type: Directive
  }], null, null);
})();
var MatHorizontalStepper = class extends _MatProxyStepperBase {
};
MatHorizontalStepper.ɵfac = /* @__PURE__ */ (() => {
  let ɵMatHorizontalStepper_BaseFactory;
  return function MatHorizontalStepper_Factory(ɵt) {
    return (ɵMatHorizontalStepper_BaseFactory || (ɵMatHorizontalStepper_BaseFactory = ɵɵgetInheritedFactory(MatHorizontalStepper)))(ɵt || MatHorizontalStepper);
  };
})();
MatHorizontalStepper.ɵdir = ɵɵdefineDirective({
  type: MatHorizontalStepper,
  selectors: [["mat-horizontal-stepper"]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatHorizontalStepper, [{
    type: Directive,
    args: [{
      selector: "mat-horizontal-stepper"
    }]
  }], null, null);
})();
var MatVerticalStepper = class extends _MatProxyStepperBase {
};
MatVerticalStepper.ɵfac = /* @__PURE__ */ (() => {
  let ɵMatVerticalStepper_BaseFactory;
  return function MatVerticalStepper_Factory(ɵt) {
    return (ɵMatVerticalStepper_BaseFactory || (ɵMatVerticalStepper_BaseFactory = ɵɵgetInheritedFactory(MatVerticalStepper)))(ɵt || MatVerticalStepper);
  };
})();
MatVerticalStepper.ɵdir = ɵɵdefineDirective({
  type: MatVerticalStepper,
  selectors: [["mat-vertical-stepper"]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatVerticalStepper, [{
    type: Directive,
    args: [{
      selector: "mat-vertical-stepper"
    }]
  }], null, null);
})();
var MatStepper = class extends CdkStepper {
  constructor(dir, changeDetectorRef, elementRef, _document) {
    super(dir, changeDetectorRef, elementRef, _document);
    this.steps = new QueryList();
    this.animationDone = new EventEmitter();
    this.labelPosition = "end";
    this._iconOverrides = {};
    this._animationDone = new Subject();
    const nodeName = elementRef.nativeElement.nodeName.toLowerCase();
    this.orientation = nodeName === "mat-vertical-stepper" ? "vertical" : "horizontal";
  }
  ngAfterContentInit() {
    super.ngAfterContentInit();
    this._icons.forEach(({
      name,
      templateRef
    }) => this._iconOverrides[name] = templateRef);
    this.steps.changes.pipe(takeUntil(this._destroyed)).subscribe(() => {
      this._stateChanged();
    });
    this._animationDone.pipe(
      // This needs a `distinctUntilChanged` in order to avoid emitting the same event twice due
      // to a bug in animations where the `.done` callback gets invoked twice on some browsers.
      // See https://github.com/angular/angular/issues/24084
      distinctUntilChanged((x, y) => x.fromState === y.fromState && x.toState === y.toState),
      takeUntil(this._destroyed)
    ).subscribe((event) => {
      if (event.toState === "current") {
        this.animationDone.emit();
      }
    });
  }
  _stepIsNavigable(index, step) {
    return step.completed || this.selectedIndex === index || !this.linear;
  }
};
MatStepper.ɵfac = function MatStepper_Factory(ɵt) {
  return new (ɵt || MatStepper)(ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(DOCUMENT));
};
MatStepper.ɵcmp = ɵɵdefineComponent({
  type: MatStepper,
  selectors: [["mat-stepper"], ["mat-vertical-stepper"], ["mat-horizontal-stepper"], ["", "matStepper", ""]],
  contentQueries: function MatStepper_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, MatStep, 5);
      ɵɵcontentQuery(dirIndex, MatStepperIcon, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._steps = _t);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._icons = _t);
    }
  },
  viewQuery: function MatStepper_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(MatStepHeader, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._stepHeader = _t);
    }
  },
  hostAttrs: ["role", "tablist"],
  hostVars: 9,
  hostBindings: function MatStepper_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-orientation", ctx.orientation);
      ɵɵclassProp("mat-stepper-horizontal", ctx.orientation === "horizontal")("mat-stepper-vertical", ctx.orientation === "vertical")("mat-stepper-label-position-end", ctx.orientation === "horizontal" && ctx.labelPosition == "end")("mat-stepper-label-position-bottom", ctx.orientation === "horizontal" && ctx.labelPosition == "bottom");
    }
  },
  inputs: {
    selectedIndex: "selectedIndex",
    disableRipple: "disableRipple",
    color: "color",
    labelPosition: "labelPosition"
  },
  outputs: {
    animationDone: "animationDone"
  },
  exportAs: ["matStepper", "matVerticalStepper", "matHorizontalStepper"],
  features: [ɵɵProvidersFeature([{
    provide: CdkStepper,
    useExisting: MatStepper
  }, {
    provide: MatHorizontalStepper,
    useExisting: MatStepper
  }, {
    provide: MatVerticalStepper,
    useExisting: MatStepper
  }]), ɵɵInheritDefinitionFeature],
  decls: 5,
  vars: 3,
  consts: [["stepTemplate", ""], [3, "ngSwitch"], [4, "ngSwitchCase"], [1, "mat-horizontal-stepper-header-container"], [4, "ngFor", "ngForOf"], [1, "mat-horizontal-content-container"], ["class", "mat-horizontal-stepper-content", "role", "tabpanel", 3, "id", 4, "ngFor", "ngForOf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["class", "mat-stepper-horizontal-line", 4, "ngIf"], [1, "mat-stepper-horizontal-line"], ["role", "tabpanel", 1, "mat-horizontal-stepper-content", 3, "id"], [3, "ngTemplateOutlet"], ["class", "mat-step", 4, "ngFor", "ngForOf"], [1, "mat-step"], [1, "mat-vertical-content-container"], ["role", "tabpanel", 1, "mat-vertical-stepper-content", 3, "id"], [1, "mat-vertical-content"], [3, "click", "keydown", "tabIndex", "id", "index", "state", "label", "selected", "active", "optional", "errorMessage", "iconOverrides", "disableRipple", "color"]],
  template: function MatStepper_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainerStart(0, 1);
      ɵɵtemplate(1, MatStepper_ng_container_1_Template, 5, 2, "ng-container", 2)(2, MatStepper_ng_container_2_Template, 2, 1, "ng-container", 2);
      ɵɵelementContainerEnd();
      ɵɵtemplate(3, MatStepper_ng_template_3_Template, 1, 23, "ng-template", null, 0, ɵɵtemplateRefExtractor);
    }
    if (rf & 2) {
      ɵɵproperty("ngSwitch", ctx.orientation);
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", "horizontal");
      ɵɵadvance();
      ɵɵproperty("ngSwitchCase", "vertical");
    }
  },
  dependencies: [MatStepHeader, NgSwitch, NgSwitchCase, NgForOf, NgTemplateOutlet, NgIf],
  styles: ['.mat-stepper-vertical,.mat-stepper-horizontal{display:block}.mat-horizontal-stepper-header-container{white-space:nowrap;display:flex;align-items:center}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header-container{align-items:flex-start}.mat-stepper-horizontal-line{border-top-width:1px;border-top-style:solid;flex:auto;height:0;margin:0 -16px;min-width:32px}.mat-stepper-label-position-bottom .mat-stepper-horizontal-line{margin:0;min-width:0;position:relative}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after{border-top-width:1px;border-top-style:solid;content:"";display:inline-block;height:0;position:absolute;width:calc(50% - 20px)}.mat-horizontal-stepper-header{display:flex;height:72px;overflow:hidden;align-items:center;padding:0 24px}.mat-horizontal-stepper-header .mat-step-icon{margin-right:8px;flex:none}[dir=rtl] .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:8px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header{box-sizing:border-box;flex-direction:column;height:auto}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after{right:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{left:0}[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:last-child::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:first-child::after{display:none}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-label{padding:16px 0 0 0;text-align:center;width:100%}.mat-vertical-stepper-header{display:flex;align-items:center;height:24px}.mat-vertical-stepper-header .mat-step-icon{margin-right:12px}[dir=rtl] .mat-vertical-stepper-header .mat-step-icon{margin-right:0;margin-left:12px}.mat-horizontal-stepper-content{outline:0}.mat-horizontal-stepper-content[aria-expanded=false]{height:0;overflow:hidden}.mat-horizontal-content-container{overflow:hidden;padding:0 24px 24px 24px}.cdk-high-contrast-active .mat-horizontal-content-container{outline:solid 1px}.mat-vertical-content-container{margin-left:36px;border:0;position:relative}.cdk-high-contrast-active .mat-vertical-content-container{outline:solid 1px}[dir=rtl] .mat-vertical-content-container{margin-left:0;margin-right:36px}.mat-stepper-vertical-line::before{content:"";position:absolute;left:0;border-left-width:1px;border-left-style:solid}[dir=rtl] .mat-stepper-vertical-line::before{left:auto;right:0}.mat-vertical-stepper-content{overflow:hidden;outline:0}.mat-vertical-content{padding:0 24px 24px 24px}.mat-step:last-child .mat-vertical-content-container{border:none}\n'],
  encapsulation: 2,
  data: {
    animation: [matStepperAnimations.horizontalStepTransition, matStepperAnimations.verticalStepTransition]
  },
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatStepper, [{
    type: Component,
    args: [{
      selector: "mat-stepper, mat-vertical-stepper, mat-horizontal-stepper, [matStepper]",
      exportAs: "matStepper, matVerticalStepper, matHorizontalStepper",
      inputs: ["selectedIndex"],
      host: {
        "[class.mat-stepper-horizontal]": 'orientation === "horizontal"',
        "[class.mat-stepper-vertical]": 'orientation === "vertical"',
        "[class.mat-stepper-label-position-end]": 'orientation === "horizontal" && labelPosition == "end"',
        "[class.mat-stepper-label-position-bottom]": 'orientation === "horizontal" && labelPosition == "bottom"',
        "[attr.aria-orientation]": "orientation",
        "role": "tablist"
      },
      animations: [matStepperAnimations.horizontalStepTransition, matStepperAnimations.verticalStepTransition],
      providers: [{
        provide: CdkStepper,
        useExisting: MatStepper
      }, {
        provide: MatHorizontalStepper,
        useExisting: MatStepper
      }, {
        provide: MatVerticalStepper,
        useExisting: MatStepper
      }],
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<ng-container [ngSwitch]="orientation">
  <!-- Horizontal stepper -->
  <ng-container *ngSwitchCase="'horizontal'">
    <div class="mat-horizontal-stepper-header-container">
      <ng-container *ngFor="let step of steps; let i = index; let isLast = last">
        <ng-container
          [ngTemplateOutlet]="stepTemplate"
          [ngTemplateOutletContext]="{step: step, i: i}"></ng-container>
        <div *ngIf="!isLast" class="mat-stepper-horizontal-line"></div>
      </ng-container>
    </div>

    <div class="mat-horizontal-content-container">
      <div *ngFor="let step of steps; let i = index"
           class="mat-horizontal-stepper-content" role="tabpanel"
           [@horizontalStepTransition]="_getAnimationDirection(i)"
           (@horizontalStepTransition.done)="_animationDone.next($event)"
           [id]="_getStepContentId(i)"
           [attr.aria-labelledby]="_getStepLabelId(i)"
           [attr.aria-expanded]="selectedIndex === i">
        <ng-container [ngTemplateOutlet]="step.content"></ng-container>
      </div>
    </div>
  </ng-container>

  <!-- Vertical stepper -->
  <ng-container *ngSwitchCase="'vertical'">
    <div class="mat-step" *ngFor="let step of steps; let i = index; let isLast = last">
      <ng-container
        [ngTemplateOutlet]="stepTemplate"
        [ngTemplateOutletContext]="{step: step, i: i}"></ng-container>
      <div class="mat-vertical-content-container" [class.mat-stepper-vertical-line]="!isLast">
        <div class="mat-vertical-stepper-content" role="tabpanel"
             [@verticalStepTransition]="_getAnimationDirection(i)"
             (@verticalStepTransition.done)="_animationDone.next($event)"
             [id]="_getStepContentId(i)"
             [attr.aria-labelledby]="_getStepLabelId(i)"
             [attr.aria-expanded]="selectedIndex === i">
          <div class="mat-vertical-content">
            <ng-container [ngTemplateOutlet]="step.content"></ng-container>
          </div>
        </div>
      </div>
    </div>
  </ng-container>

</ng-container>

<!-- Common step templating -->
<ng-template let-step="step" let-i="i" #stepTemplate>
  <mat-step-header
    [class.mat-horizontal-stepper-header]="orientation === 'horizontal'"
    [class.mat-vertical-stepper-header]="orientation === 'vertical'"
    (click)="step.select()"
    (keydown)="_onKeydown($event)"
    [tabIndex]="_getFocusIndex() === i ? 0 : -1"
    [id]="_getStepLabelId(i)"
    [attr.aria-posinset]="i + 1"
    [attr.aria-setsize]="steps.length"
    [attr.aria-controls]="_getStepContentId(i)"
    [attr.aria-selected]="selectedIndex == i"
    [attr.aria-label]="step.ariaLabel || null"
    [attr.aria-labelledby]="(!step.ariaLabel && step.ariaLabelledby) ? step.ariaLabelledby : null"
    [attr.aria-disabled]="_stepIsNavigable(i, step) ? null : true"
    [index]="i"
    [state]="_getIndicatorType(i, step.state)"
    [label]="step.stepLabel || step.label"
    [selected]="selectedIndex === i"
    [active]="_stepIsNavigable(i, step)"
    [optional]="step.optional"
    [errorMessage]="step.errorMessage"
    [iconOverrides]="_iconOverrides"
    [disableRipple]="disableRipple || !_stepIsNavigable(i, step)"
    [color]="step.color || color"></mat-step-header>
</ng-template>
`,
      styles: ['.mat-stepper-vertical,.mat-stepper-horizontal{display:block}.mat-horizontal-stepper-header-container{white-space:nowrap;display:flex;align-items:center}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header-container{align-items:flex-start}.mat-stepper-horizontal-line{border-top-width:1px;border-top-style:solid;flex:auto;height:0;margin:0 -16px;min-width:32px}.mat-stepper-label-position-bottom .mat-stepper-horizontal-line{margin:0;min-width:0;position:relative}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before,.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after{border-top-width:1px;border-top-style:solid;content:"";display:inline-block;height:0;position:absolute;width:calc(50% - 20px)}.mat-horizontal-stepper-header{display:flex;height:72px;overflow:hidden;align-items:center;padding:0 24px}.mat-horizontal-stepper-header .mat-step-icon{margin-right:8px;flex:none}[dir=rtl] .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:8px}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header{box-sizing:border-box;flex-direction:column;height:auto}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::after,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::after{right:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:first-child)::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:not(:last-child)::before{left:0}[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:last-child::before,[dir=rtl] .mat-stepper-label-position-bottom .mat-horizontal-stepper-header:first-child::after{display:none}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-icon{margin-right:0;margin-left:0}.mat-stepper-label-position-bottom .mat-horizontal-stepper-header .mat-step-label{padding:16px 0 0 0;text-align:center;width:100%}.mat-vertical-stepper-header{display:flex;align-items:center;height:24px}.mat-vertical-stepper-header .mat-step-icon{margin-right:12px}[dir=rtl] .mat-vertical-stepper-header .mat-step-icon{margin-right:0;margin-left:12px}.mat-horizontal-stepper-content{outline:0}.mat-horizontal-stepper-content[aria-expanded=false]{height:0;overflow:hidden}.mat-horizontal-content-container{overflow:hidden;padding:0 24px 24px 24px}.cdk-high-contrast-active .mat-horizontal-content-container{outline:solid 1px}.mat-vertical-content-container{margin-left:36px;border:0;position:relative}.cdk-high-contrast-active .mat-vertical-content-container{outline:solid 1px}[dir=rtl] .mat-vertical-content-container{margin-left:0;margin-right:36px}.mat-stepper-vertical-line::before{content:"";position:absolute;left:0;border-left-width:1px;border-left-style:solid}[dir=rtl] .mat-stepper-vertical-line::before{left:auto;right:0}.mat-vertical-stepper-content{overflow:hidden;outline:0}.mat-vertical-content{padding:0 24px 24px 24px}.mat-step:last-child .mat-vertical-content-container{border:none}\n']
    }]
  }], function() {
    return [{
      type: Directionality,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ChangeDetectorRef
    }, {
      type: ElementRef
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, {
    _stepHeader: [{
      type: ViewChildren,
      args: [MatStepHeader]
    }],
    _steps: [{
      type: ContentChildren,
      args: [MatStep, {
        descendants: true
      }]
    }],
    _icons: [{
      type: ContentChildren,
      args: [MatStepperIcon, {
        descendants: true
      }]
    }],
    animationDone: [{
      type: Output
    }],
    disableRipple: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    labelPosition: [{
      type: Input
    }]
  });
})();
var MatStepperNext = class extends CdkStepperNext {
};
MatStepperNext.ɵfac = /* @__PURE__ */ (() => {
  let ɵMatStepperNext_BaseFactory;
  return function MatStepperNext_Factory(ɵt) {
    return (ɵMatStepperNext_BaseFactory || (ɵMatStepperNext_BaseFactory = ɵɵgetInheritedFactory(MatStepperNext)))(ɵt || MatStepperNext);
  };
})();
MatStepperNext.ɵdir = ɵɵdefineDirective({
  type: MatStepperNext,
  selectors: [["button", "matStepperNext", ""]],
  hostAttrs: [1, "mat-stepper-next"],
  hostVars: 1,
  hostBindings: function MatStepperNext_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵhostProperty("type", ctx.type);
    }
  },
  inputs: {
    type: "type"
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatStepperNext, [{
    type: Directive,
    args: [{
      selector: "button[matStepperNext]",
      host: {
        "class": "mat-stepper-next",
        "[type]": "type"
      },
      inputs: ["type"]
    }]
  }], null, null);
})();
var MatStepperPrevious = class extends CdkStepperPrevious {
};
MatStepperPrevious.ɵfac = /* @__PURE__ */ (() => {
  let ɵMatStepperPrevious_BaseFactory;
  return function MatStepperPrevious_Factory(ɵt) {
    return (ɵMatStepperPrevious_BaseFactory || (ɵMatStepperPrevious_BaseFactory = ɵɵgetInheritedFactory(MatStepperPrevious)))(ɵt || MatStepperPrevious);
  };
})();
MatStepperPrevious.ɵdir = ɵɵdefineDirective({
  type: MatStepperPrevious,
  selectors: [["button", "matStepperPrevious", ""]],
  hostAttrs: [1, "mat-stepper-previous"],
  hostVars: 1,
  hostBindings: function MatStepperPrevious_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵhostProperty("type", ctx.type);
    }
  },
  inputs: {
    type: "type"
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatStepperPrevious, [{
    type: Directive,
    args: [{
      selector: "button[matStepperPrevious]",
      host: {
        "class": "mat-stepper-previous",
        "[type]": "type"
      },
      inputs: ["type"]
    }]
  }], null, null);
})();
var MatStepperModule = class {
};
MatStepperModule.ɵfac = function MatStepperModule_Factory(ɵt) {
  return new (ɵt || MatStepperModule)();
};
MatStepperModule.ɵmod = ɵɵdefineNgModule({
  type: MatStepperModule,
  declarations: [MatHorizontalStepper, MatVerticalStepper, MatStep, MatStepLabel, MatStepper, MatStepperNext, MatStepperPrevious, MatStepHeader, MatStepperIcon, MatStepContent],
  imports: [MatCommonModule, CommonModule, PortalModule, MatButtonModule, CdkStepperModule, MatIconModule, MatRippleModule],
  exports: [MatCommonModule, MatStep, MatStepLabel, MatStepper, MatStepperNext, MatStepperPrevious, MatStepHeader, MatStepperIcon, MatStepContent]
});
MatStepperModule.ɵinj = ɵɵdefineInjector({
  providers: [MAT_STEPPER_INTL_PROVIDER, ErrorStateMatcher],
  imports: [[MatCommonModule, CommonModule, PortalModule, MatButtonModule, CdkStepperModule, MatIconModule, MatRippleModule], MatCommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatStepperModule, [{
    type: NgModule,
    args: [{
      imports: [MatCommonModule, CommonModule, PortalModule, MatButtonModule, CdkStepperModule, MatIconModule, MatRippleModule],
      exports: [MatCommonModule, MatStep, MatStepLabel, MatStepper, MatStepperNext, MatStepperPrevious, MatStepHeader, MatStepperIcon, MatStepContent],
      declarations: [MatHorizontalStepper, MatVerticalStepper, MatStep, MatStepLabel, MatStepper, MatStepperNext, MatStepperPrevious, MatStepHeader, MatStepperIcon, MatStepContent],
      providers: [MAT_STEPPER_INTL_PROVIDER, ErrorStateMatcher]
    }]
  }], null, null);
})();

// node_modules/@angular/material/fesm2020/expansion.mjs
var _c07 = ["body"];
var _c14 = [[["mat-expansion-panel-header"]], "*", [["mat-action-row"]]];
var _c22 = ["mat-expansion-panel-header", "*", "mat-action-row"];
function MatExpansionPanel_ng_template_5_Template(rf, ctx) {
}
var _c32 = [[["mat-panel-title"]], [["mat-panel-description"]], "*"];
var _c42 = ["mat-panel-title", "mat-panel-description", "*"];
function MatExpansionPanelHeader_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 2);
  }
  if (rf & 2) {
    const ctx_r0 = ɵɵnextContext();
    ɵɵproperty("@indicatorRotate", ctx_r0._getExpandedState());
  }
}
var MAT_ACCORDION = new InjectionToken("MAT_ACCORDION");
var EXPANSION_PANEL_ANIMATION_TIMING = "225ms cubic-bezier(0.4,0.0,0.2,1)";
var matExpansionAnimations = {
  /** Animation that rotates the indicator arrow. */
  indicatorRotate: trigger("indicatorRotate", [state("collapsed, void", style({
    transform: "rotate(0deg)"
  })), state("expanded", style({
    transform: "rotate(180deg)"
  })), transition("expanded <=> collapsed, void => collapsed", animate(EXPANSION_PANEL_ANIMATION_TIMING))]),
  /** Animation that expands and collapses the panel content. */
  bodyExpansion: trigger("bodyExpansion", [state("collapsed, void", style({
    height: "0px",
    visibility: "hidden"
  })), state("expanded", style({
    height: "*",
    visibility: "visible"
  })), transition("expanded <=> collapsed, void => collapsed", animate(EXPANSION_PANEL_ANIMATION_TIMING))])
};
var MatExpansionPanelContent = class {
  constructor(_template) {
    this._template = _template;
  }
};
MatExpansionPanelContent.ɵfac = function MatExpansionPanelContent_Factory(ɵt) {
  return new (ɵt || MatExpansionPanelContent)(ɵɵdirectiveInject(TemplateRef));
};
MatExpansionPanelContent.ɵdir = ɵɵdefineDirective({
  type: MatExpansionPanelContent,
  selectors: [["ng-template", "matExpansionPanelContent", ""]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatExpansionPanelContent, [{
    type: Directive,
    args: [{
      selector: "ng-template[matExpansionPanelContent]"
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var uniqueId = 0;
var MAT_EXPANSION_PANEL_DEFAULT_OPTIONS = new InjectionToken("MAT_EXPANSION_PANEL_DEFAULT_OPTIONS");
var MatExpansionPanel = class extends CdkAccordionItem {
  constructor(accordion, _changeDetectorRef, _uniqueSelectionDispatcher, _viewContainerRef, _document, _animationMode, defaultOptions) {
    super(accordion, _changeDetectorRef, _uniqueSelectionDispatcher);
    this._viewContainerRef = _viewContainerRef;
    this._animationMode = _animationMode;
    this._hideToggle = false;
    this.afterExpand = new EventEmitter();
    this.afterCollapse = new EventEmitter();
    this._inputChanges = new Subject();
    this._headerId = `mat-expansion-panel-header-${uniqueId++}`;
    this._bodyAnimationDone = new Subject();
    this.accordion = accordion;
    this._document = _document;
    this._bodyAnimationDone.pipe(distinctUntilChanged((x, y) => {
      return x.fromState === y.fromState && x.toState === y.toState;
    })).subscribe((event) => {
      if (event.fromState !== "void") {
        if (event.toState === "expanded") {
          this.afterExpand.emit();
        } else if (event.toState === "collapsed") {
          this.afterCollapse.emit();
        }
      }
    });
    if (defaultOptions) {
      this.hideToggle = defaultOptions.hideToggle;
    }
  }
  /** Whether the toggle indicator should be hidden. */
  get hideToggle() {
    return this._hideToggle || this.accordion && this.accordion.hideToggle;
  }
  set hideToggle(value) {
    this._hideToggle = coerceBooleanProperty(value);
  }
  /** The position of the expansion indicator. */
  get togglePosition() {
    return this._togglePosition || this.accordion && this.accordion.togglePosition;
  }
  set togglePosition(value) {
    this._togglePosition = value;
  }
  /** Determines whether the expansion panel should have spacing between it and its siblings. */
  _hasSpacing() {
    if (this.accordion) {
      return this.expanded && this.accordion.displayMode === "default";
    }
    return false;
  }
  /** Gets the expanded state string. */
  _getExpandedState() {
    return this.expanded ? "expanded" : "collapsed";
  }
  /** Toggles the expanded state of the expansion panel. */
  toggle() {
    this.expanded = !this.expanded;
  }
  /** Sets the expanded state of the expansion panel to false. */
  close() {
    this.expanded = false;
  }
  /** Sets the expanded state of the expansion panel to true. */
  open() {
    this.expanded = true;
  }
  ngAfterContentInit() {
    if (this._lazyContent) {
      this.opened.pipe(startWith(null), filter(() => this.expanded && !this._portal), take(1)).subscribe(() => {
        this._portal = new TemplatePortal(this._lazyContent._template, this._viewContainerRef);
      });
    }
  }
  ngOnChanges(changes) {
    this._inputChanges.next(changes);
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this._bodyAnimationDone.complete();
    this._inputChanges.complete();
  }
  /** Checks whether the expansion panel's content contains the currently-focused element. */
  _containsFocus() {
    if (this._body) {
      const focusedElement = this._document.activeElement;
      const bodyElement = this._body.nativeElement;
      return focusedElement === bodyElement || bodyElement.contains(focusedElement);
    }
    return false;
  }
};
MatExpansionPanel.ɵfac = function MatExpansionPanel_Factory(ɵt) {
  return new (ɵt || MatExpansionPanel)(ɵɵdirectiveInject(MAT_ACCORDION, 12), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(UniqueSelectionDispatcher), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8), ɵɵdirectiveInject(MAT_EXPANSION_PANEL_DEFAULT_OPTIONS, 8));
};
MatExpansionPanel.ɵcmp = ɵɵdefineComponent({
  type: MatExpansionPanel,
  selectors: [["mat-expansion-panel"]],
  contentQueries: function MatExpansionPanel_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, MatExpansionPanelContent, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._lazyContent = _t.first);
    }
  },
  viewQuery: function MatExpansionPanel_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c07, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._body = _t.first);
    }
  },
  hostAttrs: [1, "mat-expansion-panel"],
  hostVars: 6,
  hostBindings: function MatExpansionPanel_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("mat-expanded", ctx.expanded)("_mat-animation-noopable", ctx._animationMode === "NoopAnimations")("mat-expansion-panel-spacing", ctx._hasSpacing());
    }
  },
  inputs: {
    disabled: "disabled",
    expanded: "expanded",
    hideToggle: "hideToggle",
    togglePosition: "togglePosition"
  },
  outputs: {
    opened: "opened",
    closed: "closed",
    expandedChange: "expandedChange",
    afterExpand: "afterExpand",
    afterCollapse: "afterCollapse"
  },
  exportAs: ["matExpansionPanel"],
  features: [ɵɵProvidersFeature([
    // Provide MatAccordion as undefined to prevent nested expansion panels from registering
    // to the same accordion.
    {
      provide: MAT_ACCORDION,
      useValue: void 0
    }
  ]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
  ngContentSelectors: _c22,
  decls: 7,
  vars: 4,
  consts: [["body", ""], ["role", "region", 1, "mat-expansion-panel-content", 3, "id"], [1, "mat-expansion-panel-body"], [3, "cdkPortalOutlet"]],
  template: function MatExpansionPanel_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef(_c14);
      ɵɵprojection(0);
      ɵɵelementStart(1, "div", 1, 0);
      ɵɵlistener("@bodyExpansion.done", function MatExpansionPanel_Template_div_animation_bodyExpansion_done_1_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._bodyAnimationDone.next($event));
      });
      ɵɵelementStart(3, "div", 2);
      ɵɵprojection(4, 1);
      ɵɵtemplate(5, MatExpansionPanel_ng_template_5_Template, 0, 0, "ng-template", 3);
      ɵɵelementEnd();
      ɵɵprojection(6, 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("@bodyExpansion", ctx._getExpandedState())("id", ctx.id);
      ɵɵattribute("aria-labelledby", ctx._headerId);
      ɵɵadvance(4);
      ɵɵproperty("cdkPortalOutlet", ctx._portal);
    }
  },
  dependencies: [CdkPortalOutlet],
  styles: ['.mat-expansion-panel{box-sizing:content-box;display:block;margin:0;border-radius:4px;overflow:hidden;transition:margin 225ms cubic-bezier(0.4, 0, 0.2, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);position:relative}.mat-accordion .mat-expansion-panel:not(.mat-expanded),.mat-accordion .mat-expansion-panel:not(.mat-expansion-panel-spacing){border-radius:0}.mat-accordion .mat-expansion-panel:first-of-type{border-top-right-radius:4px;border-top-left-radius:4px}.mat-accordion .mat-expansion-panel:last-of-type{border-bottom-right-radius:4px;border-bottom-left-radius:4px}.cdk-high-contrast-active .mat-expansion-panel{outline:solid 1px}.mat-expansion-panel.ng-animate-disabled,.ng-animate-disabled .mat-expansion-panel,.mat-expansion-panel._mat-animation-noopable{transition:none}.mat-expansion-panel-content{display:flex;flex-direction:column;overflow:visible}.mat-expansion-panel-content[style*="visibility: hidden"] *{visibility:hidden !important}.mat-expansion-panel-body{padding:0 24px 16px}.mat-expansion-panel-spacing{margin:16px 0}.mat-accordion>.mat-expansion-panel-spacing:first-child,.mat-accordion>*:first-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-top:0}.mat-accordion>.mat-expansion-panel-spacing:last-child,.mat-accordion>*:last-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-bottom:0}.mat-action-row{border-top-style:solid;border-top-width:1px;display:flex;flex-direction:row;justify-content:flex-end;padding:16px 8px 16px 24px}.mat-action-row .mat-button-base,.mat-action-row .mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-action-row .mat-button-base,[dir=rtl] .mat-action-row .mat-mdc-button-base{margin-left:0;margin-right:8px}\n'],
  encapsulation: 2,
  data: {
    animation: [matExpansionAnimations.bodyExpansion]
  },
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatExpansionPanel, [{
    type: Component,
    args: [{
      selector: "mat-expansion-panel",
      exportAs: "matExpansionPanel",
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      inputs: ["disabled", "expanded"],
      outputs: ["opened", "closed", "expandedChange"],
      animations: [matExpansionAnimations.bodyExpansion],
      providers: [
        // Provide MatAccordion as undefined to prevent nested expansion panels from registering
        // to the same accordion.
        {
          provide: MAT_ACCORDION,
          useValue: void 0
        }
      ],
      host: {
        "class": "mat-expansion-panel",
        "[class.mat-expanded]": "expanded",
        "[class._mat-animation-noopable]": '_animationMode === "NoopAnimations"',
        "[class.mat-expansion-panel-spacing]": "_hasSpacing()"
      },
      template: '<ng-content select="mat-expansion-panel-header"></ng-content>\n<div class="mat-expansion-panel-content"\n     role="region"\n     [@bodyExpansion]="_getExpandedState()"\n     (@bodyExpansion.done)="_bodyAnimationDone.next($event)"\n     [attr.aria-labelledby]="_headerId"\n     [id]="id"\n     #body>\n  <div class="mat-expansion-panel-body">\n    <ng-content></ng-content>\n    <ng-template [cdkPortalOutlet]="_portal"></ng-template>\n  </div>\n  <ng-content select="mat-action-row"></ng-content>\n</div>\n',
      styles: ['.mat-expansion-panel{box-sizing:content-box;display:block;margin:0;border-radius:4px;overflow:hidden;transition:margin 225ms cubic-bezier(0.4, 0, 0.2, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);position:relative}.mat-accordion .mat-expansion-panel:not(.mat-expanded),.mat-accordion .mat-expansion-panel:not(.mat-expansion-panel-spacing){border-radius:0}.mat-accordion .mat-expansion-panel:first-of-type{border-top-right-radius:4px;border-top-left-radius:4px}.mat-accordion .mat-expansion-panel:last-of-type{border-bottom-right-radius:4px;border-bottom-left-radius:4px}.cdk-high-contrast-active .mat-expansion-panel{outline:solid 1px}.mat-expansion-panel.ng-animate-disabled,.ng-animate-disabled .mat-expansion-panel,.mat-expansion-panel._mat-animation-noopable{transition:none}.mat-expansion-panel-content{display:flex;flex-direction:column;overflow:visible}.mat-expansion-panel-content[style*="visibility: hidden"] *{visibility:hidden !important}.mat-expansion-panel-body{padding:0 24px 16px}.mat-expansion-panel-spacing{margin:16px 0}.mat-accordion>.mat-expansion-panel-spacing:first-child,.mat-accordion>*:first-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-top:0}.mat-accordion>.mat-expansion-panel-spacing:last-child,.mat-accordion>*:last-child:not(.mat-expansion-panel) .mat-expansion-panel-spacing{margin-bottom:0}.mat-action-row{border-top-style:solid;border-top-width:1px;display:flex;flex-direction:row;justify-content:flex-end;padding:16px 8px 16px 24px}.mat-action-row .mat-button-base,.mat-action-row .mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-action-row .mat-button-base,[dir=rtl] .mat-action-row .mat-mdc-button-base{margin-left:0;margin-right:8px}\n']
    }]
  }], function() {
    return [{
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: SkipSelf
      }, {
        type: Inject,
        args: [MAT_ACCORDION]
      }]
    }, {
      type: ChangeDetectorRef
    }, {
      type: UniqueSelectionDispatcher
    }, {
      type: ViewContainerRef
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [ANIMATION_MODULE_TYPE]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [MAT_EXPANSION_PANEL_DEFAULT_OPTIONS]
      }, {
        type: Optional
      }]
    }];
  }, {
    hideToggle: [{
      type: Input
    }],
    togglePosition: [{
      type: Input
    }],
    afterExpand: [{
      type: Output
    }],
    afterCollapse: [{
      type: Output
    }],
    _lazyContent: [{
      type: ContentChild,
      args: [MatExpansionPanelContent]
    }],
    _body: [{
      type: ViewChild,
      args: ["body"]
    }]
  });
})();
var MatExpansionPanelActionRow = class {
};
MatExpansionPanelActionRow.ɵfac = function MatExpansionPanelActionRow_Factory(ɵt) {
  return new (ɵt || MatExpansionPanelActionRow)();
};
MatExpansionPanelActionRow.ɵdir = ɵɵdefineDirective({
  type: MatExpansionPanelActionRow,
  selectors: [["mat-action-row"]],
  hostAttrs: [1, "mat-action-row"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatExpansionPanelActionRow, [{
    type: Directive,
    args: [{
      selector: "mat-action-row",
      host: {
        class: "mat-action-row"
      }
    }]
  }], null, null);
})();
var MatExpansionPanelHeaderBase = class {
};
var _MatExpansionPanelHeaderMixinBase = mixinTabIndex(MatExpansionPanelHeaderBase);
var MatExpansionPanelHeader = class extends _MatExpansionPanelHeaderMixinBase {
  constructor(panel, _element, _focusMonitor, _changeDetectorRef, defaultOptions, _animationMode, tabIndex) {
    super();
    this.panel = panel;
    this._element = _element;
    this._focusMonitor = _focusMonitor;
    this._changeDetectorRef = _changeDetectorRef;
    this._animationMode = _animationMode;
    this._parentChangeSubscription = Subscription.EMPTY;
    const accordionHideToggleChange = panel.accordion ? panel.accordion._stateChanges.pipe(filter((changes) => !!(changes["hideToggle"] || changes["togglePosition"]))) : EMPTY;
    this.tabIndex = parseInt(tabIndex || "") || 0;
    this._parentChangeSubscription = merge(panel.opened, panel.closed, accordionHideToggleChange, panel._inputChanges.pipe(filter((changes) => {
      return !!(changes["hideToggle"] || changes["disabled"] || changes["togglePosition"]);
    }))).subscribe(() => this._changeDetectorRef.markForCheck());
    panel.closed.pipe(filter(() => panel._containsFocus())).subscribe(() => _focusMonitor.focusVia(_element, "program"));
    if (defaultOptions) {
      this.expandedHeight = defaultOptions.expandedHeight;
      this.collapsedHeight = defaultOptions.collapsedHeight;
    }
  }
  /**
   * Whether the associated panel is disabled. Implemented as a part of `FocusableOption`.
   * @docs-private
   */
  get disabled() {
    return this.panel.disabled;
  }
  /** Toggles the expanded state of the panel. */
  _toggle() {
    if (!this.disabled) {
      this.panel.toggle();
    }
  }
  /** Gets whether the panel is expanded. */
  _isExpanded() {
    return this.panel.expanded;
  }
  /** Gets the expanded state string of the panel. */
  _getExpandedState() {
    return this.panel._getExpandedState();
  }
  /** Gets the panel id. */
  _getPanelId() {
    return this.panel.id;
  }
  /** Gets the toggle position for the header. */
  _getTogglePosition() {
    return this.panel.togglePosition;
  }
  /** Gets whether the expand indicator should be shown. */
  _showToggle() {
    return !this.panel.hideToggle && !this.panel.disabled;
  }
  /**
   * Gets the current height of the header. Null if no custom height has been
   * specified, and if the default height from the stylesheet should be used.
   */
  _getHeaderHeight() {
    const isExpanded = this._isExpanded();
    if (isExpanded && this.expandedHeight) {
      return this.expandedHeight;
    } else if (!isExpanded && this.collapsedHeight) {
      return this.collapsedHeight;
    }
    return null;
  }
  /** Handle keydown event calling to toggle() if appropriate. */
  _keydown(event) {
    switch (event.keyCode) {
      case SPACE:
      case ENTER:
        if (!hasModifierKey(event)) {
          event.preventDefault();
          this._toggle();
        }
        break;
      default:
        if (this.panel.accordion) {
          this.panel.accordion._handleHeaderKeydown(event);
        }
        return;
    }
  }
  /**
   * Focuses the panel header. Implemented as a part of `FocusableOption`.
   * @param origin Origin of the action that triggered the focus.
   * @docs-private
   */
  focus(origin, options) {
    if (origin) {
      this._focusMonitor.focusVia(this._element, origin, options);
    } else {
      this._element.nativeElement.focus(options);
    }
  }
  ngAfterViewInit() {
    this._focusMonitor.monitor(this._element).subscribe((origin) => {
      if (origin && this.panel.accordion) {
        this.panel.accordion._handleHeaderFocus(this);
      }
    });
  }
  ngOnDestroy() {
    this._parentChangeSubscription.unsubscribe();
    this._focusMonitor.stopMonitoring(this._element);
  }
};
MatExpansionPanelHeader.ɵfac = function MatExpansionPanelHeader_Factory(ɵt) {
  return new (ɵt || MatExpansionPanelHeader)(ɵɵdirectiveInject(MatExpansionPanel, 1), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(FocusMonitor), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(MAT_EXPANSION_PANEL_DEFAULT_OPTIONS, 8), ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8), ɵɵinjectAttribute("tabindex"));
};
MatExpansionPanelHeader.ɵcmp = ɵɵdefineComponent({
  type: MatExpansionPanelHeader,
  selectors: [["mat-expansion-panel-header"]],
  hostAttrs: ["role", "button", 1, "mat-expansion-panel-header", "mat-focus-indicator"],
  hostVars: 15,
  hostBindings: function MatExpansionPanelHeader_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("click", function MatExpansionPanelHeader_click_HostBindingHandler() {
        return ctx._toggle();
      })("keydown", function MatExpansionPanelHeader_keydown_HostBindingHandler($event) {
        return ctx._keydown($event);
      });
    }
    if (rf & 2) {
      ɵɵattribute("id", ctx.panel._headerId)("tabindex", ctx.tabIndex)("aria-controls", ctx._getPanelId())("aria-expanded", ctx._isExpanded())("aria-disabled", ctx.panel.disabled);
      ɵɵstyleProp("height", ctx._getHeaderHeight());
      ɵɵclassProp("mat-expanded", ctx._isExpanded())("mat-expansion-toggle-indicator-after", ctx._getTogglePosition() === "after")("mat-expansion-toggle-indicator-before", ctx._getTogglePosition() === "before")("_mat-animation-noopable", ctx._animationMode === "NoopAnimations");
    }
  },
  inputs: {
    tabIndex: "tabIndex",
    expandedHeight: "expandedHeight",
    collapsedHeight: "collapsedHeight"
  },
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c42,
  decls: 5,
  vars: 1,
  consts: [[1, "mat-content"], ["class", "mat-expansion-indicator", 4, "ngIf"], [1, "mat-expansion-indicator"]],
  template: function MatExpansionPanelHeader_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c32);
      ɵɵelementStart(0, "span", 0);
      ɵɵprojection(1);
      ɵɵprojection(2, 1);
      ɵɵprojection(3, 2);
      ɵɵelementEnd();
      ɵɵtemplate(4, MatExpansionPanelHeader_span_4_Template, 1, 1, "span", 1);
    }
    if (rf & 2) {
      ɵɵadvance(4);
      ɵɵproperty("ngIf", ctx._showToggle());
    }
  },
  dependencies: [NgIf],
  styles: ['.mat-expansion-panel-header{display:flex;flex-direction:row;align-items:center;padding:0 24px;border-radius:inherit;transition:height 225ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-expansion-panel-header._mat-animation-noopable{transition:none}.mat-expansion-panel-header:focus,.mat-expansion-panel-header:hover{outline:none}.mat-expansion-panel-header.mat-expanded:focus,.mat-expansion-panel-header.mat-expanded:hover{background:inherit}.mat-expansion-panel-header:not([aria-disabled=true]){cursor:pointer}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before{flex-direction:row-reverse}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 16px 0 0}[dir=rtl] .mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 0 0 16px}.mat-content{display:flex;flex:1;flex-direction:row;overflow:hidden}.mat-expansion-panel-header-title,.mat-expansion-panel-header-description{display:flex;flex-grow:1;margin-right:16px;align-items:center}[dir=rtl] .mat-expansion-panel-header-title,[dir=rtl] .mat-expansion-panel-header-description{margin-right:0;margin-left:16px}.mat-expansion-panel-header-description{flex-grow:2}.mat-expansion-indicator::after{border-style:solid;border-width:0 2px 2px 0;content:"";display:inline-block;padding:3px;transform:rotate(45deg);vertical-align:middle}.cdk-high-contrast-active .mat-expansion-panel .mat-expansion-panel-header.cdk-keyboard-focused:not([aria-disabled=true])::before,.cdk-high-contrast-active .mat-expansion-panel .mat-expansion-panel-header.cdk-program-focused:not([aria-disabled=true])::before,.cdk-high-contrast-active .mat-expansion-panel:not(.mat-expanded) .mat-expansion-panel-header:hover:not([aria-disabled=true])::before{top:0;left:0;right:0;bottom:0;position:absolute;box-sizing:border-box;pointer-events:none;border:3px solid;border-radius:4px;content:""}.cdk-high-contrast-active .mat-expansion-panel-content{border-top:1px solid;border-top-left-radius:0;border-top-right-radius:0}\n'],
  encapsulation: 2,
  data: {
    animation: [matExpansionAnimations.indicatorRotate]
  },
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatExpansionPanelHeader, [{
    type: Component,
    args: [{
      selector: "mat-expansion-panel-header",
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      inputs: ["tabIndex"],
      animations: [matExpansionAnimations.indicatorRotate],
      host: {
        "class": "mat-expansion-panel-header mat-focus-indicator",
        "role": "button",
        "[attr.id]": "panel._headerId",
        "[attr.tabindex]": "tabIndex",
        "[attr.aria-controls]": "_getPanelId()",
        "[attr.aria-expanded]": "_isExpanded()",
        "[attr.aria-disabled]": "panel.disabled",
        "[class.mat-expanded]": "_isExpanded()",
        "[class.mat-expansion-toggle-indicator-after]": `_getTogglePosition() === 'after'`,
        "[class.mat-expansion-toggle-indicator-before]": `_getTogglePosition() === 'before'`,
        "[class._mat-animation-noopable]": '_animationMode === "NoopAnimations"',
        "[style.height]": "_getHeaderHeight()",
        "(click)": "_toggle()",
        "(keydown)": "_keydown($event)"
      },
      template: '<span class="mat-content">\n  <ng-content select="mat-panel-title"></ng-content>\n  <ng-content select="mat-panel-description"></ng-content>\n  <ng-content></ng-content>\n</span>\n<span [@indicatorRotate]="_getExpandedState()" *ngIf="_showToggle()"\n      class="mat-expansion-indicator"></span>\n',
      styles: ['.mat-expansion-panel-header{display:flex;flex-direction:row;align-items:center;padding:0 24px;border-radius:inherit;transition:height 225ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-expansion-panel-header._mat-animation-noopable{transition:none}.mat-expansion-panel-header:focus,.mat-expansion-panel-header:hover{outline:none}.mat-expansion-panel-header.mat-expanded:focus,.mat-expansion-panel-header.mat-expanded:hover{background:inherit}.mat-expansion-panel-header:not([aria-disabled=true]){cursor:pointer}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before{flex-direction:row-reverse}.mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 16px 0 0}[dir=rtl] .mat-expansion-panel-header.mat-expansion-toggle-indicator-before .mat-expansion-indicator{margin:0 0 0 16px}.mat-content{display:flex;flex:1;flex-direction:row;overflow:hidden}.mat-expansion-panel-header-title,.mat-expansion-panel-header-description{display:flex;flex-grow:1;margin-right:16px;align-items:center}[dir=rtl] .mat-expansion-panel-header-title,[dir=rtl] .mat-expansion-panel-header-description{margin-right:0;margin-left:16px}.mat-expansion-panel-header-description{flex-grow:2}.mat-expansion-indicator::after{border-style:solid;border-width:0 2px 2px 0;content:"";display:inline-block;padding:3px;transform:rotate(45deg);vertical-align:middle}.cdk-high-contrast-active .mat-expansion-panel .mat-expansion-panel-header.cdk-keyboard-focused:not([aria-disabled=true])::before,.cdk-high-contrast-active .mat-expansion-panel .mat-expansion-panel-header.cdk-program-focused:not([aria-disabled=true])::before,.cdk-high-contrast-active .mat-expansion-panel:not(.mat-expanded) .mat-expansion-panel-header:hover:not([aria-disabled=true])::before{top:0;left:0;right:0;bottom:0;position:absolute;box-sizing:border-box;pointer-events:none;border:3px solid;border-radius:4px;content:""}.cdk-high-contrast-active .mat-expansion-panel-content{border-top:1px solid;border-top-left-radius:0;border-top-right-radius:0}\n']
    }]
  }], function() {
    return [{
      type: MatExpansionPanel,
      decorators: [{
        type: Host
      }]
    }, {
      type: ElementRef
    }, {
      type: FocusMonitor
    }, {
      type: ChangeDetectorRef
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [MAT_EXPANSION_PANEL_DEFAULT_OPTIONS]
      }, {
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [ANIMATION_MODULE_TYPE]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Attribute,
        args: ["tabindex"]
      }]
    }];
  }, {
    expandedHeight: [{
      type: Input
    }],
    collapsedHeight: [{
      type: Input
    }]
  });
})();
var MatExpansionPanelDescription = class {
};
MatExpansionPanelDescription.ɵfac = function MatExpansionPanelDescription_Factory(ɵt) {
  return new (ɵt || MatExpansionPanelDescription)();
};
MatExpansionPanelDescription.ɵdir = ɵɵdefineDirective({
  type: MatExpansionPanelDescription,
  selectors: [["mat-panel-description"]],
  hostAttrs: [1, "mat-expansion-panel-header-description"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatExpansionPanelDescription, [{
    type: Directive,
    args: [{
      selector: "mat-panel-description",
      host: {
        class: "mat-expansion-panel-header-description"
      }
    }]
  }], null, null);
})();
var MatExpansionPanelTitle = class {
};
MatExpansionPanelTitle.ɵfac = function MatExpansionPanelTitle_Factory(ɵt) {
  return new (ɵt || MatExpansionPanelTitle)();
};
MatExpansionPanelTitle.ɵdir = ɵɵdefineDirective({
  type: MatExpansionPanelTitle,
  selectors: [["mat-panel-title"]],
  hostAttrs: [1, "mat-expansion-panel-header-title"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatExpansionPanelTitle, [{
    type: Directive,
    args: [{
      selector: "mat-panel-title",
      host: {
        class: "mat-expansion-panel-header-title"
      }
    }]
  }], null, null);
})();
var MatAccordion = class extends CdkAccordion {
  constructor() {
    super(...arguments);
    this._ownHeaders = new QueryList();
    this._hideToggle = false;
    this.displayMode = "default";
    this.togglePosition = "after";
  }
  /** Whether the expansion indicator should be hidden. */
  get hideToggle() {
    return this._hideToggle;
  }
  set hideToggle(show) {
    this._hideToggle = coerceBooleanProperty(show);
  }
  ngAfterContentInit() {
    this._headers.changes.pipe(startWith(this._headers)).subscribe((headers) => {
      this._ownHeaders.reset(headers.filter((header) => header.panel.accordion === this));
      this._ownHeaders.notifyOnChanges();
    });
    this._keyManager = new FocusKeyManager(this._ownHeaders).withWrap().withHomeAndEnd();
  }
  /** Handles keyboard events coming in from the panel headers. */
  _handleHeaderKeydown(event) {
    this._keyManager.onKeydown(event);
  }
  _handleHeaderFocus(header) {
    this._keyManager.updateActiveItem(header);
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this._ownHeaders.destroy();
  }
};
MatAccordion.ɵfac = /* @__PURE__ */ (() => {
  let ɵMatAccordion_BaseFactory;
  return function MatAccordion_Factory(ɵt) {
    return (ɵMatAccordion_BaseFactory || (ɵMatAccordion_BaseFactory = ɵɵgetInheritedFactory(MatAccordion)))(ɵt || MatAccordion);
  };
})();
MatAccordion.ɵdir = ɵɵdefineDirective({
  type: MatAccordion,
  selectors: [["mat-accordion"]],
  contentQueries: function MatAccordion_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, MatExpansionPanelHeader, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._headers = _t);
    }
  },
  hostAttrs: [1, "mat-accordion"],
  hostVars: 2,
  hostBindings: function MatAccordion_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("mat-accordion-multi", ctx.multi);
    }
  },
  inputs: {
    multi: "multi",
    hideToggle: "hideToggle",
    displayMode: "displayMode",
    togglePosition: "togglePosition"
  },
  exportAs: ["matAccordion"],
  features: [ɵɵProvidersFeature([{
    provide: MAT_ACCORDION,
    useExisting: MatAccordion
  }]), ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatAccordion, [{
    type: Directive,
    args: [{
      selector: "mat-accordion",
      exportAs: "matAccordion",
      inputs: ["multi"],
      providers: [{
        provide: MAT_ACCORDION,
        useExisting: MatAccordion
      }],
      host: {
        class: "mat-accordion",
        // Class binding which is only used by the test harness as there is no other
        // way for the harness to detect if multiple panel support is enabled.
        "[class.mat-accordion-multi]": "this.multi"
      }
    }]
  }], null, {
    _headers: [{
      type: ContentChildren,
      args: [MatExpansionPanelHeader, {
        descendants: true
      }]
    }],
    hideToggle: [{
      type: Input
    }],
    displayMode: [{
      type: Input
    }],
    togglePosition: [{
      type: Input
    }]
  });
})();
var MatExpansionModule = class {
};
MatExpansionModule.ɵfac = function MatExpansionModule_Factory(ɵt) {
  return new (ɵt || MatExpansionModule)();
};
MatExpansionModule.ɵmod = ɵɵdefineNgModule({
  type: MatExpansionModule,
  declarations: [MatAccordion, MatExpansionPanel, MatExpansionPanelActionRow, MatExpansionPanelHeader, MatExpansionPanelTitle, MatExpansionPanelDescription, MatExpansionPanelContent],
  imports: [CommonModule, MatCommonModule, CdkAccordionModule, PortalModule],
  exports: [MatAccordion, MatExpansionPanel, MatExpansionPanelActionRow, MatExpansionPanelHeader, MatExpansionPanelTitle, MatExpansionPanelDescription, MatExpansionPanelContent]
});
MatExpansionModule.ɵinj = ɵɵdefineInjector({
  imports: [[CommonModule, MatCommonModule, CdkAccordionModule, PortalModule]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatExpansionModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, MatCommonModule, CdkAccordionModule, PortalModule],
      exports: [MatAccordion, MatExpansionPanel, MatExpansionPanelActionRow, MatExpansionPanelHeader, MatExpansionPanelTitle, MatExpansionPanelDescription, MatExpansionPanelContent],
      declarations: [MatAccordion, MatExpansionPanel, MatExpansionPanelActionRow, MatExpansionPanelHeader, MatExpansionPanelTitle, MatExpansionPanelDescription, MatExpansionPanelContent]
    }]
  }], null, null);
})();

// node_modules/@angular/material/fesm2020/grid-list.mjs
var _c08 = ["*"];
var _c15 = [[["", "mat-grid-avatar", ""], ["", "matGridAvatar", ""]], [["", "mat-line", ""], ["", "matLine", ""]], "*"];
var _c23 = ["[mat-grid-avatar], [matGridAvatar]", "[mat-line], [matLine]", "*"];
var _c33 = ".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-grid-tile-header,.mat-grid-tile .mat-grid-tile-footer{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-header>*,.mat-grid-tile .mat-grid-tile-footer>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-tile-header.mat-2-line,.mat-grid-tile .mat-grid-tile-footer.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}.mat-grid-tile-content{top:0;left:0;right:0;bottom:0;position:absolute;display:flex;align-items:center;justify-content:center;height:100%;padding:0;margin:0}\n";
var TileCoordinator = class {
  constructor() {
    this.columnIndex = 0;
    this.rowIndex = 0;
  }
  /** Gets the total number of rows occupied by tiles */
  get rowCount() {
    return this.rowIndex + 1;
  }
  /**
   * Gets the total span of rows occupied by tiles.
   * Ex: A list with 1 row that contains a tile with rowspan 2 will have a total rowspan of 2.
   */
  get rowspan() {
    const lastRowMax = Math.max(...this.tracker);
    return lastRowMax > 1 ? this.rowCount + lastRowMax - 1 : this.rowCount;
  }
  /**
   * Updates the tile positions.
   * @param numColumns Amount of columns in the grid.
   * @param tiles Tiles to be positioned.
   */
  update(numColumns, tiles) {
    this.columnIndex = 0;
    this.rowIndex = 0;
    this.tracker = new Array(numColumns);
    this.tracker.fill(0, 0, this.tracker.length);
    this.positions = tiles.map((tile) => this._trackTile(tile));
  }
  /** Calculates the row and col position of a tile. */
  _trackTile(tile) {
    const gapStartIndex = this._findMatchingGap(tile.colspan);
    this._markTilePosition(gapStartIndex, tile);
    this.columnIndex = gapStartIndex + tile.colspan;
    return new TilePosition(this.rowIndex, gapStartIndex);
  }
  /** Finds the next available space large enough to fit the tile. */
  _findMatchingGap(tileCols) {
    if (tileCols > this.tracker.length && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error(`mat-grid-list: tile with colspan ${tileCols} is wider than grid with cols="${this.tracker.length}".`);
    }
    let gapStartIndex = -1;
    let gapEndIndex = -1;
    do {
      if (this.columnIndex + tileCols > this.tracker.length) {
        this._nextRow();
        gapStartIndex = this.tracker.indexOf(0, this.columnIndex);
        gapEndIndex = this._findGapEndIndex(gapStartIndex);
        continue;
      }
      gapStartIndex = this.tracker.indexOf(0, this.columnIndex);
      if (gapStartIndex == -1) {
        this._nextRow();
        gapStartIndex = this.tracker.indexOf(0, this.columnIndex);
        gapEndIndex = this._findGapEndIndex(gapStartIndex);
        continue;
      }
      gapEndIndex = this._findGapEndIndex(gapStartIndex);
      this.columnIndex = gapStartIndex + 1;
    } while (gapEndIndex - gapStartIndex < tileCols || gapEndIndex == 0);
    return Math.max(gapStartIndex, 0);
  }
  /** Move "down" to the next row. */
  _nextRow() {
    this.columnIndex = 0;
    this.rowIndex++;
    for (let i = 0; i < this.tracker.length; i++) {
      this.tracker[i] = Math.max(0, this.tracker[i] - 1);
    }
  }
  /**
   * Finds the end index (exclusive) of a gap given the index from which to start looking.
   * The gap ends when a non-zero value is found.
   */
  _findGapEndIndex(gapStartIndex) {
    for (let i = gapStartIndex + 1; i < this.tracker.length; i++) {
      if (this.tracker[i] != 0) {
        return i;
      }
    }
    return this.tracker.length;
  }
  /** Update the tile tracker to account for the given tile in the given space. */
  _markTilePosition(start, tile) {
    for (let i = 0; i < tile.colspan; i++) {
      this.tracker[start + i] = tile.rowspan;
    }
  }
};
var TilePosition = class {
  constructor(row, col) {
    this.row = row;
    this.col = col;
  }
};
var MAT_GRID_LIST = new InjectionToken("MAT_GRID_LIST");
var MatGridTile = class {
  constructor(_element, _gridList) {
    this._element = _element;
    this._gridList = _gridList;
    this._rowspan = 1;
    this._colspan = 1;
  }
  /** Amount of rows that the grid tile takes up. */
  get rowspan() {
    return this._rowspan;
  }
  set rowspan(value) {
    this._rowspan = Math.round(coerceNumberProperty(value));
  }
  /** Amount of columns that the grid tile takes up. */
  get colspan() {
    return this._colspan;
  }
  set colspan(value) {
    this._colspan = Math.round(coerceNumberProperty(value));
  }
  /**
   * Sets the style of the grid-tile element.  Needs to be set manually to avoid
   * "Changed after checked" errors that would occur with HostBinding.
   */
  _setStyle(property, value) {
    this._element.nativeElement.style[property] = value;
  }
};
MatGridTile.ɵfac = function MatGridTile_Factory(ɵt) {
  return new (ɵt || MatGridTile)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(MAT_GRID_LIST, 8));
};
MatGridTile.ɵcmp = ɵɵdefineComponent({
  type: MatGridTile,
  selectors: [["mat-grid-tile"]],
  hostAttrs: [1, "mat-grid-tile"],
  hostVars: 2,
  hostBindings: function MatGridTile_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("rowspan", ctx.rowspan)("colspan", ctx.colspan);
    }
  },
  inputs: {
    rowspan: "rowspan",
    colspan: "colspan"
  },
  exportAs: ["matGridTile"],
  ngContentSelectors: _c08,
  decls: 2,
  vars: 0,
  consts: [[1, "mat-grid-tile-content"]],
  template: function MatGridTile_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div", 0);
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
  },
  styles: [".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-grid-tile-header,.mat-grid-tile .mat-grid-tile-footer{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-header>*,.mat-grid-tile .mat-grid-tile-footer>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-tile-header.mat-2-line,.mat-grid-tile .mat-grid-tile-footer.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}.mat-grid-tile-content{top:0;left:0;right:0;bottom:0;position:absolute;display:flex;align-items:center;justify-content:center;height:100%;padding:0;margin:0}\n"],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatGridTile, [{
    type: Component,
    args: [{
      selector: "mat-grid-tile",
      exportAs: "matGridTile",
      host: {
        "class": "mat-grid-tile",
        // Ensures that the "rowspan" and "colspan" input value is reflected in
        // the DOM. This is needed for the grid-tile harness.
        "[attr.rowspan]": "rowspan",
        "[attr.colspan]": "colspan"
      },
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<div class="mat-grid-tile-content">\n  <ng-content></ng-content>\n</div>\n',
      styles: [".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-grid-tile-header,.mat-grid-tile .mat-grid-tile-footer{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-header>*,.mat-grid-tile .mat-grid-tile-footer>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-tile-header.mat-2-line,.mat-grid-tile .mat-grid-tile-footer.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}.mat-grid-tile-content{top:0;left:0;right:0;bottom:0;position:absolute;display:flex;align-items:center;justify-content:center;height:100%;padding:0;margin:0}\n"]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [MAT_GRID_LIST]
      }]
    }];
  }, {
    rowspan: [{
      type: Input
    }],
    colspan: [{
      type: Input
    }]
  });
})();
var MatGridTileText = class {
  constructor(_element) {
    this._element = _element;
  }
  ngAfterContentInit() {
    setLines(this._lines, this._element);
  }
};
MatGridTileText.ɵfac = function MatGridTileText_Factory(ɵt) {
  return new (ɵt || MatGridTileText)(ɵɵdirectiveInject(ElementRef));
};
MatGridTileText.ɵcmp = ɵɵdefineComponent({
  type: MatGridTileText,
  selectors: [["mat-grid-tile-header"], ["mat-grid-tile-footer"]],
  contentQueries: function MatGridTileText_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, MatLine, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._lines = _t);
    }
  },
  ngContentSelectors: _c23,
  decls: 4,
  vars: 0,
  consts: [[1, "mat-grid-list-text"]],
  template: function MatGridTileText_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef(_c15);
      ɵɵprojection(0);
      ɵɵelementStart(1, "div", 0);
      ɵɵprojection(2, 1);
      ɵɵelementEnd();
      ɵɵprojection(3, 2);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatGridTileText, [{
    type: Component,
    args: [{
      selector: "mat-grid-tile-header, mat-grid-tile-footer",
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: '<ng-content select="[mat-grid-avatar], [matGridAvatar]"></ng-content>\n<div class="mat-grid-list-text"><ng-content select="[mat-line], [matLine]"></ng-content></div>\n<ng-content></ng-content>\n'
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, {
    _lines: [{
      type: ContentChildren,
      args: [MatLine, {
        descendants: true
      }]
    }]
  });
})();
var MatGridAvatarCssMatStyler = class {
};
MatGridAvatarCssMatStyler.ɵfac = function MatGridAvatarCssMatStyler_Factory(ɵt) {
  return new (ɵt || MatGridAvatarCssMatStyler)();
};
MatGridAvatarCssMatStyler.ɵdir = ɵɵdefineDirective({
  type: MatGridAvatarCssMatStyler,
  selectors: [["", "mat-grid-avatar", ""], ["", "matGridAvatar", ""]],
  hostAttrs: [1, "mat-grid-avatar"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatGridAvatarCssMatStyler, [{
    type: Directive,
    args: [{
      selector: "[mat-grid-avatar], [matGridAvatar]",
      host: {
        "class": "mat-grid-avatar"
      }
    }]
  }], null, null);
})();
var MatGridTileHeaderCssMatStyler = class {
};
MatGridTileHeaderCssMatStyler.ɵfac = function MatGridTileHeaderCssMatStyler_Factory(ɵt) {
  return new (ɵt || MatGridTileHeaderCssMatStyler)();
};
MatGridTileHeaderCssMatStyler.ɵdir = ɵɵdefineDirective({
  type: MatGridTileHeaderCssMatStyler,
  selectors: [["mat-grid-tile-header"]],
  hostAttrs: [1, "mat-grid-tile-header"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatGridTileHeaderCssMatStyler, [{
    type: Directive,
    args: [{
      selector: "mat-grid-tile-header",
      host: {
        "class": "mat-grid-tile-header"
      }
    }]
  }], null, null);
})();
var MatGridTileFooterCssMatStyler = class {
};
MatGridTileFooterCssMatStyler.ɵfac = function MatGridTileFooterCssMatStyler_Factory(ɵt) {
  return new (ɵt || MatGridTileFooterCssMatStyler)();
};
MatGridTileFooterCssMatStyler.ɵdir = ɵɵdefineDirective({
  type: MatGridTileFooterCssMatStyler,
  selectors: [["mat-grid-tile-footer"]],
  hostAttrs: [1, "mat-grid-tile-footer"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatGridTileFooterCssMatStyler, [{
    type: Directive,
    args: [{
      selector: "mat-grid-tile-footer",
      host: {
        "class": "mat-grid-tile-footer"
      }
    }]
  }], null, null);
})();
var cssCalcAllowedValue = /^-?\d+((\.\d+)?[A-Za-z%$]?)+$/;
var TileStyler = class {
  constructor() {
    this._rows = 0;
    this._rowspan = 0;
  }
  /**
   * Adds grid-list layout info once it is available. Cannot be processed in the constructor
   * because these properties haven't been calculated by that point.
   *
   * @param gutterSize Size of the grid's gutter.
   * @param tracker Instance of the TileCoordinator.
   * @param cols Amount of columns in the grid.
   * @param direction Layout direction of the grid.
   */
  init(gutterSize, tracker, cols, direction) {
    this._gutterSize = normalizeUnits(gutterSize);
    this._rows = tracker.rowCount;
    this._rowspan = tracker.rowspan;
    this._cols = cols;
    this._direction = direction;
  }
  /**
   * Computes the amount of space a single 1x1 tile would take up (width or height).
   * Used as a basis for other calculations.
   * @param sizePercent Percent of the total grid-list space that one 1x1 tile would take up.
   * @param gutterFraction Fraction of the gutter size taken up by one 1x1 tile.
   * @return The size of a 1x1 tile as an expression that can be evaluated via CSS calc().
   */
  getBaseTileSize(sizePercent, gutterFraction) {
    return `(${sizePercent}% - (${this._gutterSize} * ${gutterFraction}))`;
  }
  /**
   * Gets The horizontal or vertical position of a tile, e.g., the 'top' or 'left' property value.
   * @param offset Number of tiles that have already been rendered in the row/column.
   * @param baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).
   * @return Position of the tile as a CSS calc() expression.
   */
  getTilePosition(baseSize, offset) {
    return offset === 0 ? "0" : calc(`(${baseSize} + ${this._gutterSize}) * ${offset}`);
  }
  /**
   * Gets the actual size of a tile, e.g., width or height, taking rowspan or colspan into account.
   * @param baseSize Base size of a 1x1 tile (as computed in getBaseTileSize).
   * @param span The tile's rowspan or colspan.
   * @return Size of the tile as a CSS calc() expression.
   */
  getTileSize(baseSize, span) {
    return `(${baseSize} * ${span}) + (${span - 1} * ${this._gutterSize})`;
  }
  /**
   * Sets the style properties to be applied to a tile for the given row and column index.
   * @param tile Tile to which to apply the styling.
   * @param rowIndex Index of the tile's row.
   * @param colIndex Index of the tile's column.
   */
  setStyle(tile, rowIndex, colIndex) {
    let percentWidthPerTile = 100 / this._cols;
    let gutterWidthFractionPerTile = (this._cols - 1) / this._cols;
    this.setColStyles(tile, colIndex, percentWidthPerTile, gutterWidthFractionPerTile);
    this.setRowStyles(tile, rowIndex, percentWidthPerTile, gutterWidthFractionPerTile);
  }
  /** Sets the horizontal placement of the tile in the list. */
  setColStyles(tile, colIndex, percentWidth, gutterWidth) {
    let baseTileWidth = this.getBaseTileSize(percentWidth, gutterWidth);
    let side = this._direction === "rtl" ? "right" : "left";
    tile._setStyle(side, this.getTilePosition(baseTileWidth, colIndex));
    tile._setStyle("width", calc(this.getTileSize(baseTileWidth, tile.colspan)));
  }
  /**
   * Calculates the total size taken up by gutters across one axis of a list.
   */
  getGutterSpan() {
    return `${this._gutterSize} * (${this._rowspan} - 1)`;
  }
  /**
   * Calculates the total size taken up by tiles across one axis of a list.
   * @param tileHeight Height of the tile.
   */
  getTileSpan(tileHeight) {
    return `${this._rowspan} * ${this.getTileSize(tileHeight, 1)}`;
  }
  /**
   * Calculates the computed height and returns the correct style property to set.
   * This method can be implemented by each type of TileStyler.
   * @docs-private
   */
  getComputedHeight() {
    return null;
  }
};
var FixedTileStyler = class extends TileStyler {
  constructor(fixedRowHeight) {
    super();
    this.fixedRowHeight = fixedRowHeight;
  }
  init(gutterSize, tracker, cols, direction) {
    super.init(gutterSize, tracker, cols, direction);
    this.fixedRowHeight = normalizeUnits(this.fixedRowHeight);
    if (!cssCalcAllowedValue.test(this.fixedRowHeight) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error(`Invalid value "${this.fixedRowHeight}" set as rowHeight.`);
    }
  }
  setRowStyles(tile, rowIndex) {
    tile._setStyle("top", this.getTilePosition(this.fixedRowHeight, rowIndex));
    tile._setStyle("height", calc(this.getTileSize(this.fixedRowHeight, tile.rowspan)));
  }
  getComputedHeight() {
    return ["height", calc(`${this.getTileSpan(this.fixedRowHeight)} + ${this.getGutterSpan()}`)];
  }
  reset(list) {
    list._setListStyle(["height", null]);
    if (list._tiles) {
      list._tiles.forEach((tile) => {
        tile._setStyle("top", null);
        tile._setStyle("height", null);
      });
    }
  }
};
var RatioTileStyler = class extends TileStyler {
  constructor(value) {
    super();
    this._parseRatio(value);
  }
  setRowStyles(tile, rowIndex, percentWidth, gutterWidth) {
    let percentHeightPerTile = percentWidth / this.rowHeightRatio;
    this.baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterWidth);
    tile._setStyle("marginTop", this.getTilePosition(this.baseTileHeight, rowIndex));
    tile._setStyle("paddingTop", calc(this.getTileSize(this.baseTileHeight, tile.rowspan)));
  }
  getComputedHeight() {
    return ["paddingBottom", calc(`${this.getTileSpan(this.baseTileHeight)} + ${this.getGutterSpan()}`)];
  }
  reset(list) {
    list._setListStyle(["paddingBottom", null]);
    list._tiles.forEach((tile) => {
      tile._setStyle("marginTop", null);
      tile._setStyle("paddingTop", null);
    });
  }
  _parseRatio(value) {
    const ratioParts = value.split(":");
    if (ratioParts.length !== 2 && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error(`mat-grid-list: invalid ratio given for row-height: "${value}"`);
    }
    this.rowHeightRatio = parseFloat(ratioParts[0]) / parseFloat(ratioParts[1]);
  }
};
var FitTileStyler = class extends TileStyler {
  setRowStyles(tile, rowIndex) {
    let percentHeightPerTile = 100 / this._rowspan;
    let gutterHeightPerTile = (this._rows - 1) / this._rows;
    let baseTileHeight = this.getBaseTileSize(percentHeightPerTile, gutterHeightPerTile);
    tile._setStyle("top", this.getTilePosition(baseTileHeight, rowIndex));
    tile._setStyle("height", calc(this.getTileSize(baseTileHeight, tile.rowspan)));
  }
  reset(list) {
    if (list._tiles) {
      list._tiles.forEach((tile) => {
        tile._setStyle("top", null);
        tile._setStyle("height", null);
      });
    }
  }
};
function calc(exp) {
  return `calc(${exp})`;
}
function normalizeUnits(value) {
  return value.match(/([A-Za-z%]+)$/) ? value : `${value}px`;
}
var MAT_FIT_MODE = "fit";
var MatGridList = class {
  constructor(_element, _dir) {
    this._element = _element;
    this._dir = _dir;
    this._gutter = "1px";
  }
  /** Amount of columns in the grid list. */
  get cols() {
    return this._cols;
  }
  set cols(value) {
    this._cols = Math.max(1, Math.round(coerceNumberProperty(value)));
  }
  /** Size of the grid list's gutter in pixels. */
  get gutterSize() {
    return this._gutter;
  }
  set gutterSize(value) {
    this._gutter = `${value == null ? "" : value}`;
  }
  /** Set internal representation of row height from the user-provided value. */
  get rowHeight() {
    return this._rowHeight;
  }
  set rowHeight(value) {
    const newValue = `${value == null ? "" : value}`;
    if (newValue !== this._rowHeight) {
      this._rowHeight = newValue;
      this._setTileStyler(this._rowHeight);
    }
  }
  ngOnInit() {
    this._checkCols();
    this._checkRowHeight();
  }
  /**
   * The layout calculation is fairly cheap if nothing changes, so there's little cost
   * to run it frequently.
   */
  ngAfterContentChecked() {
    this._layoutTiles();
  }
  /** Throw a friendly error if cols property is missing */
  _checkCols() {
    if (!this.cols && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error(`mat-grid-list: must pass in number of columns. Example: <mat-grid-list cols="3">`);
    }
  }
  /** Default to equal width:height if rowHeight property is missing */
  _checkRowHeight() {
    if (!this._rowHeight) {
      this._setTileStyler("1:1");
    }
  }
  /** Creates correct Tile Styler subtype based on rowHeight passed in by user */
  _setTileStyler(rowHeight) {
    if (this._tileStyler) {
      this._tileStyler.reset(this);
    }
    if (rowHeight === MAT_FIT_MODE) {
      this._tileStyler = new FitTileStyler();
    } else if (rowHeight && rowHeight.indexOf(":") > -1) {
      this._tileStyler = new RatioTileStyler(rowHeight);
    } else {
      this._tileStyler = new FixedTileStyler(rowHeight);
    }
  }
  /** Computes and applies the size and position for all children grid tiles. */
  _layoutTiles() {
    if (!this._tileCoordinator) {
      this._tileCoordinator = new TileCoordinator();
    }
    const tracker = this._tileCoordinator;
    const tiles = this._tiles.filter((tile) => !tile._gridList || tile._gridList === this);
    const direction = this._dir ? this._dir.value : "ltr";
    this._tileCoordinator.update(this.cols, tiles);
    this._tileStyler.init(this.gutterSize, tracker, this.cols, direction);
    tiles.forEach((tile, index) => {
      const pos = tracker.positions[index];
      this._tileStyler.setStyle(tile, pos.row, pos.col);
    });
    this._setListStyle(this._tileStyler.getComputedHeight());
  }
  /** Sets style on the main grid-list element, given the style name and value. */
  _setListStyle(style2) {
    if (style2) {
      this._element.nativeElement.style[style2[0]] = style2[1];
    }
  }
};
MatGridList.ɵfac = function MatGridList_Factory(ɵt) {
  return new (ɵt || MatGridList)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Directionality, 8));
};
MatGridList.ɵcmp = ɵɵdefineComponent({
  type: MatGridList,
  selectors: [["mat-grid-list"]],
  contentQueries: function MatGridList_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, MatGridTile, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._tiles = _t);
    }
  },
  hostAttrs: [1, "mat-grid-list"],
  hostVars: 1,
  hostBindings: function MatGridList_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("cols", ctx.cols);
    }
  },
  inputs: {
    cols: "cols",
    gutterSize: "gutterSize",
    rowHeight: "rowHeight"
  },
  exportAs: ["matGridList"],
  features: [ɵɵProvidersFeature([{
    provide: MAT_GRID_LIST,
    useExisting: MatGridList
  }])],
  ngContentSelectors: _c08,
  decls: 2,
  vars: 0,
  template: function MatGridList_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵelementStart(0, "div");
      ɵɵprojection(1);
      ɵɵelementEnd();
    }
  },
  styles: [_c33],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatGridList, [{
    type: Component,
    args: [{
      selector: "mat-grid-list",
      exportAs: "matGridList",
      host: {
        "class": "mat-grid-list",
        // Ensures that the "cols" input value is reflected in the DOM. This is
        // needed for the grid-list harness.
        "[attr.cols]": "cols"
      },
      providers: [{
        provide: MAT_GRID_LIST,
        useExisting: MatGridList
      }],
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation$1.None,
      template: "<div>\n  <ng-content></ng-content>\n</div>",
      styles: [".mat-grid-list{display:block;position:relative}.mat-grid-tile{display:block;position:absolute;overflow:hidden}.mat-grid-tile .mat-grid-tile-header,.mat-grid-tile .mat-grid-tile-footer{display:flex;align-items:center;height:48px;color:#fff;background:rgba(0,0,0,.38);overflow:hidden;padding:0 16px;position:absolute;left:0;right:0}.mat-grid-tile .mat-grid-tile-header>*,.mat-grid-tile .mat-grid-tile-footer>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-tile-header.mat-2-line,.mat-grid-tile .mat-grid-tile-footer.mat-2-line{height:68px}.mat-grid-tile .mat-grid-list-text{display:flex;flex-direction:column;flex:auto;box-sizing:border-box;overflow:hidden}.mat-grid-tile .mat-grid-list-text>*{margin:0;padding:0;font-weight:normal;font-size:inherit}.mat-grid-tile .mat-grid-list-text:empty{display:none}.mat-grid-tile .mat-grid-tile-header{top:0}.mat-grid-tile .mat-grid-tile-footer{bottom:0}.mat-grid-tile .mat-grid-avatar{padding-right:16px}[dir=rtl] .mat-grid-tile .mat-grid-avatar{padding-right:0;padding-left:16px}.mat-grid-tile .mat-grid-avatar:empty{display:none}.mat-grid-tile-content{top:0;left:0;right:0;bottom:0;position:absolute;display:flex;align-items:center;justify-content:center;height:100%;padding:0;margin:0}\n"]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Directionality,
      decorators: [{
        type: Optional
      }]
    }];
  }, {
    _tiles: [{
      type: ContentChildren,
      args: [MatGridTile, {
        descendants: true
      }]
    }],
    cols: [{
      type: Input
    }],
    gutterSize: [{
      type: Input
    }],
    rowHeight: [{
      type: Input
    }]
  });
})();
var MatGridListModule = class {
};
MatGridListModule.ɵfac = function MatGridListModule_Factory(ɵt) {
  return new (ɵt || MatGridListModule)();
};
MatGridListModule.ɵmod = ɵɵdefineNgModule({
  type: MatGridListModule,
  declarations: [MatGridList, MatGridTile, MatGridTileText, MatGridTileHeaderCssMatStyler, MatGridTileFooterCssMatStyler, MatGridAvatarCssMatStyler],
  imports: [MatLineModule, MatCommonModule],
  exports: [MatGridList, MatGridTile, MatGridTileText, MatLineModule, MatCommonModule, MatGridTileHeaderCssMatStyler, MatGridTileFooterCssMatStyler, MatGridAvatarCssMatStyler]
});
MatGridListModule.ɵinj = ɵɵdefineInjector({
  imports: [[MatLineModule, MatCommonModule], MatLineModule, MatCommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatGridListModule, [{
    type: NgModule,
    args: [{
      imports: [MatLineModule, MatCommonModule],
      exports: [MatGridList, MatGridTile, MatGridTileText, MatLineModule, MatCommonModule, MatGridTileHeaderCssMatStyler, MatGridTileFooterCssMatStyler, MatGridAvatarCssMatStyler],
      declarations: [MatGridList, MatGridTile, MatGridTileText, MatGridTileHeaderCssMatStyler, MatGridTileFooterCssMatStyler, MatGridAvatarCssMatStyler]
    }]
  }], null, null);
})();

// node_modules/@angular/material/fesm2020/slider.mjs
var _c09 = ["sliderWrapper"];
var activeEventOptions = normalizePassiveListenerOptions({
  passive: false
});
var MIN_AUTO_TICK_SEPARATION = 30;
var DISABLED_THUMB_GAP = 7;
var MIN_VALUE_NONACTIVE_THUMB_GAP = 7;
var MIN_VALUE_ACTIVE_THUMB_GAP = 10;
var MAT_SLIDER_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => MatSlider),
  multi: true
};
var MatSliderChange = class {
};
var _MatSliderBase = mixinTabIndex(mixinColor(mixinDisabled(class {
  constructor(_elementRef) {
    this._elementRef = _elementRef;
  }
}), "accent"));
var MatSlider = class extends _MatSliderBase {
  constructor(elementRef, _focusMonitor, _changeDetectorRef, _dir, tabIndex, _ngZone, _document, _animationMode) {
    super(elementRef);
    this._focusMonitor = _focusMonitor;
    this._changeDetectorRef = _changeDetectorRef;
    this._dir = _dir;
    this._ngZone = _ngZone;
    this._animationMode = _animationMode;
    this._invert = false;
    this._max = 100;
    this._min = 0;
    this._step = 1;
    this._thumbLabel = false;
    this._tickInterval = 0;
    this._value = null;
    this._vertical = false;
    this.change = new EventEmitter();
    this.input = new EventEmitter();
    this.valueChange = new EventEmitter();
    this.onTouched = () => {
    };
    this._percent = 0;
    this._isSliding = null;
    this._isActive = false;
    this._tickIntervalPercent = 0;
    this._sliderDimensions = null;
    this._controlValueAccessorChangeFn = () => {
    };
    this._dirChangeSubscription = Subscription.EMPTY;
    this._pointerDown = (event) => {
      if (this.disabled || this._isSliding || !isTouchEvent(event) && event.button !== 0) {
        return;
      }
      this._ngZone.run(() => {
        this._touchId = isTouchEvent(event) ? getTouchIdForSlider(event, this._elementRef.nativeElement) : void 0;
        const pointerPosition = getPointerPositionOnPage(event, this._touchId);
        if (pointerPosition) {
          const oldValue = this.value;
          this._isSliding = "pointer";
          this._lastPointerEvent = event;
          this._focusHostElement();
          this._onMouseenter();
          this._bindGlobalEvents(event);
          this._focusHostElement();
          this._updateValueFromPosition(pointerPosition);
          this._valueOnSlideStart = oldValue;
          if (event.cancelable) {
            event.preventDefault();
          }
          if (oldValue != this.value) {
            this._emitInputEvent();
          }
        }
      });
    };
    this._pointerMove = (event) => {
      if (this._isSliding === "pointer") {
        const pointerPosition = getPointerPositionOnPage(event, this._touchId);
        if (pointerPosition) {
          event.preventDefault();
          const oldValue = this.value;
          this._lastPointerEvent = event;
          this._updateValueFromPosition(pointerPosition);
          if (oldValue != this.value) {
            this._emitInputEvent();
          }
        }
      }
    };
    this._pointerUp = (event) => {
      if (this._isSliding === "pointer") {
        if (!isTouchEvent(event) || typeof this._touchId !== "number" || // Note that we use `changedTouches`, rather than `touches` because it
        // seems like in most cases `touches` is empty for `touchend` events.
        findMatchingTouch(event.changedTouches, this._touchId)) {
          event.preventDefault();
          this._removeGlobalEvents();
          this._isSliding = null;
          this._touchId = void 0;
          if (this._valueOnSlideStart != this.value && !this.disabled) {
            this._emitChangeEvent();
          }
          this._valueOnSlideStart = this._lastPointerEvent = null;
        }
      }
    };
    this._windowBlur = () => {
      if (this._lastPointerEvent) {
        this._pointerUp(this._lastPointerEvent);
      }
    };
    this._document = _document;
    this.tabIndex = parseInt(tabIndex) || 0;
    _ngZone.runOutsideAngular(() => {
      const element = elementRef.nativeElement;
      element.addEventListener("mousedown", this._pointerDown, activeEventOptions);
      element.addEventListener("touchstart", this._pointerDown, activeEventOptions);
    });
  }
  /** Whether the slider is inverted. */
  get invert() {
    return this._invert;
  }
  set invert(value) {
    this._invert = coerceBooleanProperty(value);
  }
  /** The maximum value that the slider can have. */
  get max() {
    return this._max;
  }
  set max(v) {
    this._max = coerceNumberProperty(v, this._max);
    this._percent = this._calculatePercentage(this._value);
    this._changeDetectorRef.markForCheck();
  }
  /** The minimum value that the slider can have. */
  get min() {
    return this._min;
  }
  set min(v) {
    this._min = coerceNumberProperty(v, this._min);
    this._percent = this._calculatePercentage(this._value);
    this._changeDetectorRef.markForCheck();
  }
  /** The values at which the thumb will snap. */
  get step() {
    return this._step;
  }
  set step(v) {
    this._step = coerceNumberProperty(v, this._step);
    if (this._step % 1 !== 0) {
      this._roundToDecimal = this._step.toString().split(".").pop().length;
    }
    this._changeDetectorRef.markForCheck();
  }
  /** Whether or not to show the thumb label. */
  get thumbLabel() {
    return this._thumbLabel;
  }
  set thumbLabel(value) {
    this._thumbLabel = coerceBooleanProperty(value);
  }
  /**
   * How often to show ticks. Relative to the step so that a tick always appears on a step.
   * Ex: Tick interval of 4 with a step of 3 will draw a tick every 4 steps (every 12 values).
   */
  get tickInterval() {
    return this._tickInterval;
  }
  set tickInterval(value) {
    if (value === "auto") {
      this._tickInterval = "auto";
    } else if (typeof value === "number" || typeof value === "string") {
      this._tickInterval = coerceNumberProperty(value, this._tickInterval);
    } else {
      this._tickInterval = 0;
    }
  }
  /** Value of the slider. */
  get value() {
    if (this._value === null) {
      this.value = this._min;
    }
    return this._value;
  }
  set value(v) {
    if (v !== this._value) {
      let value = coerceNumberProperty(v, 0);
      if (this._roundToDecimal && value !== this.min && value !== this.max) {
        value = parseFloat(value.toFixed(this._roundToDecimal));
      }
      this._value = value;
      this._percent = this._calculatePercentage(this._value);
      this._changeDetectorRef.markForCheck();
    }
  }
  /** Whether the slider is vertical. */
  get vertical() {
    return this._vertical;
  }
  set vertical(value) {
    this._vertical = coerceBooleanProperty(value);
  }
  /** The value to be used for display purposes. */
  get displayValue() {
    if (this.displayWith) {
      return this.displayWith(this.value);
    }
    if (this._roundToDecimal && this.value && this.value % 1 !== 0) {
      return this.value.toFixed(this._roundToDecimal);
    }
    return this.value || 0;
  }
  /** set focus to the host element */
  focus(options) {
    this._focusHostElement(options);
  }
  /** blur the host element */
  blur() {
    this._blurHostElement();
  }
  /** The percentage of the slider that coincides with the value. */
  get percent() {
    return this._clamp(this._percent);
  }
  /**
   * Whether the axis of the slider is inverted.
   * (i.e. whether moving the thumb in the positive x or y direction decreases the slider's value).
   */
  _shouldInvertAxis() {
    return this.vertical ? !this.invert : this.invert;
  }
  /** Whether the slider is at its minimum value. */
  _isMinValue() {
    return this.percent === 0;
  }
  /**
   * The amount of space to leave between the slider thumb and the track fill & track background
   * elements.
   */
  _getThumbGap() {
    if (this.disabled) {
      return DISABLED_THUMB_GAP;
    }
    if (this._isMinValue() && !this.thumbLabel) {
      return this._isActive ? MIN_VALUE_ACTIVE_THUMB_GAP : MIN_VALUE_NONACTIVE_THUMB_GAP;
    }
    return 0;
  }
  /** CSS styles for the track background element. */
  _getTrackBackgroundStyles() {
    const axis = this.vertical ? "Y" : "X";
    const scale = this.vertical ? `1, ${1 - this.percent}, 1` : `${1 - this.percent}, 1, 1`;
    const sign = this._shouldInvertMouseCoords() ? "-" : "";
    return {
      // scale3d avoids some rendering issues in Chrome. See #12071.
      transform: `translate${axis}(${sign}${this._getThumbGap()}px) scale3d(${scale})`
    };
  }
  /** CSS styles for the track fill element. */
  _getTrackFillStyles() {
    const percent = this.percent;
    const axis = this.vertical ? "Y" : "X";
    const scale = this.vertical ? `1, ${percent}, 1` : `${percent}, 1, 1`;
    const sign = this._shouldInvertMouseCoords() ? "" : "-";
    return {
      // scale3d avoids some rendering issues in Chrome. See #12071.
      transform: `translate${axis}(${sign}${this._getThumbGap()}px) scale3d(${scale})`,
      // iOS Safari has a bug where it won't re-render elements which start of as `scale(0)` until
      // something forces a style recalculation on it. Since we'll end up with `scale(0)` when
      // the value of the slider is 0, we can easily get into this situation. We force a
      // recalculation by changing the element's `display` when it goes from 0 to any other value.
      display: percent === 0 ? "none" : ""
    };
  }
  /** CSS styles for the ticks container element. */
  _getTicksContainerStyles() {
    let axis = this.vertical ? "Y" : "X";
    let sign = !this.vertical && this._getDirection() == "rtl" ? "" : "-";
    let offset = this._tickIntervalPercent / 2 * 100;
    return {
      "transform": `translate${axis}(${sign}${offset}%)`
    };
  }
  /** CSS styles for the ticks element. */
  _getTicksStyles() {
    let tickSize = this._tickIntervalPercent * 100;
    let backgroundSize = this.vertical ? `2px ${tickSize}%` : `${tickSize}% 2px`;
    let axis = this.vertical ? "Y" : "X";
    let sign = !this.vertical && this._getDirection() == "rtl" ? "-" : "";
    let rotate = !this.vertical && this._getDirection() == "rtl" ? " rotate(180deg)" : "";
    let styles = {
      "backgroundSize": backgroundSize,
      // Without translateZ ticks sometimes jitter as the slider moves on Chrome & Firefox.
      "transform": `translateZ(0) translate${axis}(${sign}${tickSize / 2}%)${rotate}`
    };
    if (this._isMinValue() && this._getThumbGap()) {
      const shouldInvertAxis = this._shouldInvertAxis();
      let side;
      if (this.vertical) {
        side = shouldInvertAxis ? "Bottom" : "Top";
      } else {
        side = shouldInvertAxis ? "Right" : "Left";
      }
      styles[`padding${side}`] = `${this._getThumbGap()}px`;
    }
    return styles;
  }
  _getThumbContainerStyles() {
    const shouldInvertAxis = this._shouldInvertAxis();
    let axis = this.vertical ? "Y" : "X";
    let invertOffset = this._getDirection() == "rtl" && !this.vertical ? !shouldInvertAxis : shouldInvertAxis;
    let offset = (invertOffset ? this.percent : 1 - this.percent) * 100;
    return {
      "transform": `translate${axis}(-${offset}%)`
    };
  }
  /**
   * Whether mouse events should be converted to a slider position by calculating their distance
   * from the right or bottom edge of the slider as opposed to the top or left.
   */
  _shouldInvertMouseCoords() {
    const shouldInvertAxis = this._shouldInvertAxis();
    return this._getDirection() == "rtl" && !this.vertical ? !shouldInvertAxis : shouldInvertAxis;
  }
  /** The language direction for this slider element. */
  _getDirection() {
    return this._dir && this._dir.value == "rtl" ? "rtl" : "ltr";
  }
  ngAfterViewInit() {
    this._focusMonitor.monitor(this._elementRef, true).subscribe((origin) => {
      this._isActive = !!origin && origin !== "keyboard";
      this._changeDetectorRef.detectChanges();
    });
    if (this._dir) {
      this._dirChangeSubscription = this._dir.change.subscribe(() => {
        this._changeDetectorRef.markForCheck();
      });
    }
  }
  ngOnDestroy() {
    const element = this._elementRef.nativeElement;
    element.removeEventListener("mousedown", this._pointerDown, activeEventOptions);
    element.removeEventListener("touchstart", this._pointerDown, activeEventOptions);
    this._lastPointerEvent = null;
    this._removeGlobalEvents();
    this._focusMonitor.stopMonitoring(this._elementRef);
    this._dirChangeSubscription.unsubscribe();
  }
  _onMouseenter() {
    if (this.disabled) {
      return;
    }
    this._sliderDimensions = this._getSliderDimensions();
    this._updateTickIntervalPercent();
  }
  _onFocus() {
    this._sliderDimensions = this._getSliderDimensions();
    this._updateTickIntervalPercent();
  }
  _onBlur() {
    this.onTouched();
  }
  _onKeydown(event) {
    if (this.disabled || hasModifierKey(event) || this._isSliding && this._isSliding !== "keyboard") {
      return;
    }
    const oldValue = this.value;
    switch (event.keyCode) {
      case PAGE_UP:
        this._increment(10);
        break;
      case PAGE_DOWN:
        this._increment(-10);
        break;
      case END:
        this.value = this.max;
        break;
      case HOME:
        this.value = this.min;
        break;
      case LEFT_ARROW:
        this._increment(this._getDirection() == "rtl" ? 1 : -1);
        break;
      case UP_ARROW:
        this._increment(1);
        break;
      case RIGHT_ARROW:
        this._increment(this._getDirection() == "rtl" ? -1 : 1);
        break;
      case DOWN_ARROW:
        this._increment(-1);
        break;
      default:
        return;
    }
    if (oldValue != this.value) {
      this._emitInputEvent();
      this._emitChangeEvent();
    }
    this._isSliding = "keyboard";
    event.preventDefault();
  }
  _onKeyup() {
    if (this._isSliding === "keyboard") {
      this._isSliding = null;
    }
  }
  /** Use defaultView of injected document if available or fallback to global window reference */
  _getWindow() {
    return this._document.defaultView || window;
  }
  /**
   * Binds our global move and end events. They're bound at the document level and only while
   * dragging so that the user doesn't have to keep their pointer exactly over the slider
   * as they're swiping across the screen.
   */
  _bindGlobalEvents(triggerEvent) {
    const document2 = this._document;
    const isTouch = isTouchEvent(triggerEvent);
    const moveEventName = isTouch ? "touchmove" : "mousemove";
    const endEventName = isTouch ? "touchend" : "mouseup";
    document2.addEventListener(moveEventName, this._pointerMove, activeEventOptions);
    document2.addEventListener(endEventName, this._pointerUp, activeEventOptions);
    if (isTouch) {
      document2.addEventListener("touchcancel", this._pointerUp, activeEventOptions);
    }
    const window2 = this._getWindow();
    if (typeof window2 !== "undefined" && window2) {
      window2.addEventListener("blur", this._windowBlur);
    }
  }
  /** Removes any global event listeners that we may have added. */
  _removeGlobalEvents() {
    const document2 = this._document;
    document2.removeEventListener("mousemove", this._pointerMove, activeEventOptions);
    document2.removeEventListener("mouseup", this._pointerUp, activeEventOptions);
    document2.removeEventListener("touchmove", this._pointerMove, activeEventOptions);
    document2.removeEventListener("touchend", this._pointerUp, activeEventOptions);
    document2.removeEventListener("touchcancel", this._pointerUp, activeEventOptions);
    const window2 = this._getWindow();
    if (typeof window2 !== "undefined" && window2) {
      window2.removeEventListener("blur", this._windowBlur);
    }
  }
  /** Increments the slider by the given number of steps (negative number decrements). */
  _increment(numSteps) {
    const clampedValue = this._clamp(this.value || 0, this.min, this.max);
    this.value = this._clamp(clampedValue + this.step * numSteps, this.min, this.max);
  }
  /** Calculate the new value from the new physical location. The value will always be snapped. */
  _updateValueFromPosition(pos) {
    if (!this._sliderDimensions) {
      return;
    }
    let offset = this.vertical ? this._sliderDimensions.top : this._sliderDimensions.left;
    let size = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;
    let posComponent = this.vertical ? pos.y : pos.x;
    let percent = this._clamp((posComponent - offset) / size);
    if (this._shouldInvertMouseCoords()) {
      percent = 1 - percent;
    }
    if (percent === 0) {
      this.value = this.min;
    } else if (percent === 1) {
      this.value = this.max;
    } else {
      const exactValue = this._calculateValue(percent);
      const closestValue = Math.round((exactValue - this.min) / this.step) * this.step + this.min;
      this.value = this._clamp(closestValue, this.min, this.max);
    }
  }
  /** Emits a change event if the current value is different from the last emitted value. */
  _emitChangeEvent() {
    this._controlValueAccessorChangeFn(this.value);
    this.valueChange.emit(this.value);
    this.change.emit(this._createChangeEvent());
  }
  /** Emits an input event when the current value is different from the last emitted value. */
  _emitInputEvent() {
    this.input.emit(this._createChangeEvent());
  }
  /** Updates the amount of space between ticks as a percentage of the width of the slider. */
  _updateTickIntervalPercent() {
    if (!this.tickInterval || !this._sliderDimensions) {
      return;
    }
    let tickIntervalPercent;
    if (this.tickInterval == "auto") {
      let trackSize = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;
      let pixelsPerStep = trackSize * this.step / (this.max - this.min);
      let stepsPerTick = Math.ceil(MIN_AUTO_TICK_SEPARATION / pixelsPerStep);
      let pixelsPerTick = stepsPerTick * this.step;
      tickIntervalPercent = pixelsPerTick / trackSize;
    } else {
      tickIntervalPercent = this.tickInterval * this.step / (this.max - this.min);
    }
    this._tickIntervalPercent = isSafeNumber(tickIntervalPercent) ? tickIntervalPercent : 0;
  }
  /** Creates a slider change object from the specified value. */
  _createChangeEvent(value = this.value) {
    let event = new MatSliderChange();
    event.source = this;
    event.value = value;
    return event;
  }
  /** Calculates the percentage of the slider that a value is. */
  _calculatePercentage(value) {
    const percentage = ((value || 0) - this.min) / (this.max - this.min);
    return isSafeNumber(percentage) ? percentage : 0;
  }
  /** Calculates the value a percentage of the slider corresponds to. */
  _calculateValue(percentage) {
    return this.min + percentage * (this.max - this.min);
  }
  /** Return a number between two numbers. */
  _clamp(value, min = 0, max = 1) {
    return Math.max(min, Math.min(value, max));
  }
  /**
   * Get the bounding client rect of the slider track element.
   * The track is used rather than the native element to ignore the extra space that the thumb can
   * take up.
   */
  _getSliderDimensions() {
    return this._sliderWrapper ? this._sliderWrapper.nativeElement.getBoundingClientRect() : null;
  }
  /**
   * Focuses the native element.
   * Currently only used to allow a blur event to fire but will be used with keyboard input later.
   */
  _focusHostElement(options) {
    this._elementRef.nativeElement.focus(options);
  }
  /** Blurs the native element. */
  _blurHostElement() {
    this._elementRef.nativeElement.blur();
  }
  /**
   * Sets the model value. Implemented as part of ControlValueAccessor.
   * @param value
   */
  writeValue(value) {
    this.value = value;
  }
  /**
   * Registers a callback to be triggered when the value has changed.
   * Implemented as part of ControlValueAccessor.
   * @param fn Callback to be registered.
   */
  registerOnChange(fn) {
    this._controlValueAccessorChangeFn = fn;
  }
  /**
   * Registers a callback to be triggered when the component is touched.
   * Implemented as part of ControlValueAccessor.
   * @param fn Callback to be registered.
   */
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  /**
   * Sets whether the component should be disabled.
   * Implemented as part of ControlValueAccessor.
   * @param isDisabled
   */
  setDisabledState(isDisabled) {
    this.disabled = isDisabled;
  }
};
MatSlider.ɵfac = function MatSlider_Factory(ɵt) {
  return new (ɵt || MatSlider)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(FocusMonitor), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(Directionality, 8), ɵɵinjectAttribute("tabindex"), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(DOCUMENT), ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8));
};
MatSlider.ɵcmp = ɵɵdefineComponent({
  type: MatSlider,
  selectors: [["mat-slider"]],
  viewQuery: function MatSlider_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c09, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._sliderWrapper = _t.first);
    }
  },
  hostAttrs: ["role", "slider", 1, "mat-slider", "mat-focus-indicator"],
  hostVars: 29,
  hostBindings: function MatSlider_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focus", function MatSlider_focus_HostBindingHandler() {
        return ctx._onFocus();
      })("blur", function MatSlider_blur_HostBindingHandler() {
        return ctx._onBlur();
      })("keydown", function MatSlider_keydown_HostBindingHandler($event) {
        return ctx._onKeydown($event);
      })("keyup", function MatSlider_keyup_HostBindingHandler() {
        return ctx._onKeyup();
      })("mouseenter", function MatSlider_mouseenter_HostBindingHandler() {
        return ctx._onMouseenter();
      })("selectstart", function MatSlider_selectstart_HostBindingHandler($event) {
        return $event.preventDefault();
      });
    }
    if (rf & 2) {
      ɵɵhostProperty("tabIndex", ctx.tabIndex);
      ɵɵattribute("aria-disabled", ctx.disabled)("aria-valuemax", ctx.max)("aria-valuemin", ctx.min)("aria-valuenow", ctx.value)("aria-valuetext", ctx.valueText == null ? ctx.displayValue : ctx.valueText)("aria-orientation", ctx.vertical ? "vertical" : "horizontal");
      ɵɵclassProp("mat-slider-disabled", ctx.disabled)("mat-slider-has-ticks", ctx.tickInterval)("mat-slider-horizontal", !ctx.vertical)("mat-slider-axis-inverted", ctx._shouldInvertAxis())("mat-slider-invert-mouse-coords", ctx._shouldInvertMouseCoords())("mat-slider-sliding", ctx._isSliding)("mat-slider-thumb-label-showing", ctx.thumbLabel)("mat-slider-vertical", ctx.vertical)("mat-slider-min-value", ctx._isMinValue())("mat-slider-hide-last-tick", ctx.disabled || ctx._isMinValue() && ctx._getThumbGap() && ctx._shouldInvertAxis())("_mat-animation-noopable", ctx._animationMode === "NoopAnimations");
    }
  },
  inputs: {
    disabled: "disabled",
    color: "color",
    tabIndex: "tabIndex",
    invert: "invert",
    max: "max",
    min: "min",
    step: "step",
    thumbLabel: "thumbLabel",
    tickInterval: "tickInterval",
    value: "value",
    displayWith: "displayWith",
    valueText: "valueText",
    vertical: "vertical"
  },
  outputs: {
    change: "change",
    input: "input",
    valueChange: "valueChange"
  },
  exportAs: ["matSlider"],
  features: [ɵɵProvidersFeature([MAT_SLIDER_VALUE_ACCESSOR]), ɵɵInheritDefinitionFeature],
  decls: 13,
  vars: 6,
  consts: [["sliderWrapper", ""], [1, "mat-slider-wrapper"], [1, "mat-slider-track-wrapper"], [1, "mat-slider-track-background", 3, "ngStyle"], [1, "mat-slider-track-fill", 3, "ngStyle"], [1, "mat-slider-ticks-container", 3, "ngStyle"], [1, "mat-slider-ticks", 3, "ngStyle"], [1, "mat-slider-thumb-container", 3, "ngStyle"], [1, "mat-slider-focus-ring"], [1, "mat-slider-thumb"], [1, "mat-slider-thumb-label"], [1, "mat-slider-thumb-label-text"]],
  template: function MatSlider_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div", 1, 0)(2, "div", 2);
      ɵɵelement(3, "div", 3)(4, "div", 4);
      ɵɵelementEnd();
      ɵɵelementStart(5, "div", 5);
      ɵɵelement(6, "div", 6);
      ɵɵelementEnd();
      ɵɵelementStart(7, "div", 7);
      ɵɵelement(8, "div", 8)(9, "div", 9);
      ɵɵelementStart(10, "div", 10)(11, "span", 11);
      ɵɵtext(12);
      ɵɵelementEnd()()()();
    }
    if (rf & 2) {
      ɵɵadvance(3);
      ɵɵproperty("ngStyle", ctx._getTrackBackgroundStyles());
      ɵɵadvance();
      ɵɵproperty("ngStyle", ctx._getTrackFillStyles());
      ɵɵadvance();
      ɵɵproperty("ngStyle", ctx._getTicksContainerStyles());
      ɵɵadvance();
      ɵɵproperty("ngStyle", ctx._getTicksStyles());
      ɵɵadvance();
      ɵɵproperty("ngStyle", ctx._getThumbContainerStyles());
      ɵɵadvance(5);
      ɵɵtextInterpolate(ctx.displayValue);
    }
  },
  dependencies: [NgStyle],
  styles: ['.mat-slider{display:inline-block;position:relative;box-sizing:border-box;padding:8px;outline:none;vertical-align:middle}.mat-slider:not(.mat-slider-disabled):active,.mat-slider.mat-slider-sliding:not(.mat-slider-disabled){cursor:grabbing}.mat-slider-wrapper{-webkit-print-color-adjust:exact;color-adjust:exact;position:absolute}.mat-slider-track-wrapper{position:absolute;top:0;left:0;overflow:hidden}.mat-slider-track-fill{position:absolute;transform-origin:0 0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-track-background{position:absolute;transform-origin:100% 100%;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-ticks-container{position:absolute;left:0;top:0;overflow:hidden}.mat-slider-ticks{-webkit-background-clip:content-box;background-clip:content-box;background-repeat:repeat;box-sizing:border-box;opacity:0;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-thumb-container{position:absolute;z-index:1;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-focus-ring{position:absolute;width:30px;height:30px;border-radius:50%;transform:scale(0);opacity:0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider.cdk-keyboard-focused .mat-slider-focus-ring,.mat-slider.cdk-program-focused .mat-slider-focus-ring{transform:scale(1);opacity:1}.mat-slider:not(.mat-slider-disabled):not(.mat-slider-sliding) .mat-slider-thumb-label,.mat-slider:not(.mat-slider-disabled):not(.mat-slider-sliding) .mat-slider-thumb{cursor:grab}.mat-slider-thumb{position:absolute;right:-10px;bottom:-10px;box-sizing:border-box;width:20px;height:20px;border:3px solid transparent;border-radius:50%;transform:scale(0.7);transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),border-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-thumb-label{display:none;align-items:center;justify-content:center;position:absolute;width:28px;height:28px;border-radius:50%;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),border-radius 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.cdk-high-contrast-active .mat-slider-thumb-label{outline:solid 1px}.mat-slider-thumb-label-text{z-index:1;opacity:0;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-sliding .mat-slider-track-fill,.mat-slider-sliding .mat-slider-track-background,.mat-slider-sliding .mat-slider-thumb-container{transition-duration:0ms}.mat-slider-has-ticks .mat-slider-wrapper::after{content:"";position:absolute;border-width:0;border-style:solid;opacity:0;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after,.mat-slider-has-ticks:hover:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after{opacity:1}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-disabled) .mat-slider-ticks,.mat-slider-has-ticks:hover:not(.mat-slider-disabled) .mat-slider-ticks{opacity:1}.mat-slider-thumb-label-showing .mat-slider-focus-ring{display:none}.mat-slider-thumb-label-showing .mat-slider-thumb-label{display:flex}.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:100% 100%}.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:0 0}.mat-slider:not(.mat-slider-disabled).cdk-focused.mat-slider-thumb-label-showing .mat-slider-thumb{transform:scale(0)}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label{border-radius:50% 50% 0}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label-text{opacity:1}.mat-slider:not(.mat-slider-disabled).cdk-mouse-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-touch-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-program-focused .mat-slider-thumb{border-width:2px;transform:scale(1)}.mat-slider-disabled .mat-slider-focus-ring{transform:scale(0);opacity:0}.mat-slider-disabled .mat-slider-thumb{border-width:4px;transform:scale(0.5)}.mat-slider-disabled .mat-slider-thumb-label{display:none}.mat-slider-horizontal{height:48px;min-width:128px}.mat-slider-horizontal .mat-slider-wrapper{height:2px;top:23px;left:8px;right:8px}.mat-slider-horizontal .mat-slider-wrapper::after{height:2px;border-left-width:2px;right:0;top:0}.mat-slider-horizontal .mat-slider-track-wrapper{height:2px;width:100%}.mat-slider-horizontal .mat-slider-track-fill{height:2px;width:100%;transform:scaleX(0)}.mat-slider-horizontal .mat-slider-track-background{height:2px;width:100%;transform:scaleX(1)}.mat-slider-horizontal .mat-slider-ticks-container{height:2px;width:100%}.cdk-high-contrast-active .mat-slider-horizontal .mat-slider-ticks-container{height:0;outline:solid 2px;top:1px}.mat-slider-horizontal .mat-slider-ticks{height:2px;width:100%}.mat-slider-horizontal .mat-slider-thumb-container{width:100%;height:0;top:50%}.mat-slider-horizontal .mat-slider-focus-ring{top:-15px;right:-15px}.mat-slider-horizontal .mat-slider-thumb-label{right:-14px;top:-40px;transform:translateY(26px) scale(0.01) rotate(45deg)}.mat-slider-horizontal .mat-slider-thumb-label-text{transform:rotate(-45deg)}.mat-slider-horizontal.cdk-focused .mat-slider-thumb-label{transform:rotate(45deg)}.cdk-high-contrast-active .mat-slider-horizontal.cdk-focused .mat-slider-thumb-label,.cdk-high-contrast-active .mat-slider-horizontal.cdk-focused .mat-slider-thumb-label-text{transform:none}.mat-slider-vertical{width:48px;min-height:128px}.mat-slider-vertical .mat-slider-wrapper{width:2px;top:8px;bottom:8px;left:23px}.mat-slider-vertical .mat-slider-wrapper::after{width:2px;border-top-width:2px;bottom:0;left:0}.mat-slider-vertical .mat-slider-track-wrapper{height:100%;width:2px}.mat-slider-vertical .mat-slider-track-fill{height:100%;width:2px;transform:scaleY(0)}.mat-slider-vertical .mat-slider-track-background{height:100%;width:2px;transform:scaleY(1)}.mat-slider-vertical .mat-slider-ticks-container{width:2px;height:100%}.cdk-high-contrast-active .mat-slider-vertical .mat-slider-ticks-container{width:0;outline:solid 2px;left:1px}.mat-slider-vertical .mat-slider-focus-ring{bottom:-15px;left:-15px}.mat-slider-vertical .mat-slider-ticks{width:2px;height:100%}.mat-slider-vertical .mat-slider-thumb-container{height:100%;width:0;left:50%}.mat-slider-vertical .mat-slider-thumb{-webkit-backface-visibility:hidden;backface-visibility:hidden}.mat-slider-vertical .mat-slider-thumb-label{bottom:-14px;left:-40px;transform:translateX(26px) scale(0.01) rotate(-45deg)}.mat-slider-vertical .mat-slider-thumb-label-text{transform:rotate(45deg)}.mat-slider-vertical.cdk-focused .mat-slider-thumb-label{transform:rotate(-45deg)}[dir=rtl] .mat-slider-wrapper::after{left:0;right:auto}[dir=rtl] .mat-slider-horizontal .mat-slider-track-fill{transform-origin:100% 100%}[dir=rtl] .mat-slider-horizontal .mat-slider-track-background{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:100% 100%}.mat-slider._mat-animation-noopable .mat-slider-track-fill,.mat-slider._mat-animation-noopable .mat-slider-track-background,.mat-slider._mat-animation-noopable .mat-slider-ticks,.mat-slider._mat-animation-noopable .mat-slider-thumb-container,.mat-slider._mat-animation-noopable .mat-slider-focus-ring,.mat-slider._mat-animation-noopable .mat-slider-thumb,.mat-slider._mat-animation-noopable .mat-slider-thumb-label,.mat-slider._mat-animation-noopable .mat-slider-thumb-label-text,.mat-slider._mat-animation-noopable .mat-slider-has-ticks .mat-slider-wrapper::after{transition:none}\n'],
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSlider, [{
    type: Component,
    args: [{
      selector: "mat-slider",
      exportAs: "matSlider",
      providers: [MAT_SLIDER_VALUE_ACCESSOR],
      host: {
        "(focus)": "_onFocus()",
        "(blur)": "_onBlur()",
        "(keydown)": "_onKeydown($event)",
        "(keyup)": "_onKeyup()",
        "(mouseenter)": "_onMouseenter()",
        // On Safari starting to slide temporarily triggers text selection mode which
        // show the wrong cursor. We prevent it by stopping the `selectstart` event.
        "(selectstart)": "$event.preventDefault()",
        "class": "mat-slider mat-focus-indicator",
        "role": "slider",
        "[tabIndex]": "tabIndex",
        "[attr.aria-disabled]": "disabled",
        "[attr.aria-valuemax]": "max",
        "[attr.aria-valuemin]": "min",
        "[attr.aria-valuenow]": "value",
        // NVDA and Jaws appear to announce the `aria-valuenow` by calculating its percentage based
        // on its value between `aria-valuemin` and `aria-valuemax`. Due to how decimals are handled,
        // it can cause the slider to read out a very long value like 0.20000068 if the current value
        // is 0.2 with a min of 0 and max of 1. We work around the issue by setting `aria-valuetext`
        // to the same value that we set on the slider's thumb which will be truncated.
        "[attr.aria-valuetext]": "valueText == null ? displayValue : valueText",
        "[attr.aria-orientation]": 'vertical ? "vertical" : "horizontal"',
        "[class.mat-slider-disabled]": "disabled",
        "[class.mat-slider-has-ticks]": "tickInterval",
        "[class.mat-slider-horizontal]": "!vertical",
        "[class.mat-slider-axis-inverted]": "_shouldInvertAxis()",
        // Class binding which is only used by the test harness as there is no other
        // way for the harness to detect if mouse coordinates need to be inverted.
        "[class.mat-slider-invert-mouse-coords]": "_shouldInvertMouseCoords()",
        "[class.mat-slider-sliding]": "_isSliding",
        "[class.mat-slider-thumb-label-showing]": "thumbLabel",
        "[class.mat-slider-vertical]": "vertical",
        "[class.mat-slider-min-value]": "_isMinValue()",
        "[class.mat-slider-hide-last-tick]": "disabled || _isMinValue() && _getThumbGap() && _shouldInvertAxis()",
        "[class._mat-animation-noopable]": '_animationMode === "NoopAnimations"'
      },
      inputs: ["disabled", "color", "tabIndex"],
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: '<div class="mat-slider-wrapper" #sliderWrapper>\n  <div class="mat-slider-track-wrapper">\n    <div class="mat-slider-track-background" [ngStyle]="_getTrackBackgroundStyles()"></div>\n    <div class="mat-slider-track-fill" [ngStyle]="_getTrackFillStyles()"></div>\n  </div>\n  <div class="mat-slider-ticks-container" [ngStyle]="_getTicksContainerStyles()">\n    <div class="mat-slider-ticks" [ngStyle]="_getTicksStyles()"></div>\n  </div>\n  <div class="mat-slider-thumb-container" [ngStyle]="_getThumbContainerStyles()">\n    <div class="mat-slider-focus-ring"></div>\n    <div class="mat-slider-thumb"></div>\n    <div class="mat-slider-thumb-label">\n      <span class="mat-slider-thumb-label-text">{{displayValue}}</span>\n    </div>\n  </div>\n</div>\n',
      styles: ['.mat-slider{display:inline-block;position:relative;box-sizing:border-box;padding:8px;outline:none;vertical-align:middle}.mat-slider:not(.mat-slider-disabled):active,.mat-slider.mat-slider-sliding:not(.mat-slider-disabled){cursor:grabbing}.mat-slider-wrapper{-webkit-print-color-adjust:exact;color-adjust:exact;position:absolute}.mat-slider-track-wrapper{position:absolute;top:0;left:0;overflow:hidden}.mat-slider-track-fill{position:absolute;transform-origin:0 0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-track-background{position:absolute;transform-origin:100% 100%;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-ticks-container{position:absolute;left:0;top:0;overflow:hidden}.mat-slider-ticks{-webkit-background-clip:content-box;background-clip:content-box;background-repeat:repeat;box-sizing:border-box;opacity:0;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-thumb-container{position:absolute;z-index:1;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-focus-ring{position:absolute;width:30px;height:30px;border-radius:50%;transform:scale(0);opacity:0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider.cdk-keyboard-focused .mat-slider-focus-ring,.mat-slider.cdk-program-focused .mat-slider-focus-ring{transform:scale(1);opacity:1}.mat-slider:not(.mat-slider-disabled):not(.mat-slider-sliding) .mat-slider-thumb-label,.mat-slider:not(.mat-slider-disabled):not(.mat-slider-sliding) .mat-slider-thumb{cursor:grab}.mat-slider-thumb{position:absolute;right:-10px;bottom:-10px;box-sizing:border-box;width:20px;height:20px;border:3px solid transparent;border-radius:50%;transform:scale(0.7);transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),border-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-thumb-label{display:none;align-items:center;justify-content:center;position:absolute;width:28px;height:28px;border-radius:50%;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),border-radius 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.cdk-high-contrast-active .mat-slider-thumb-label{outline:solid 1px}.mat-slider-thumb-label-text{z-index:1;opacity:0;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-sliding .mat-slider-track-fill,.mat-slider-sliding .mat-slider-track-background,.mat-slider-sliding .mat-slider-thumb-container{transition-duration:0ms}.mat-slider-has-ticks .mat-slider-wrapper::after{content:"";position:absolute;border-width:0;border-style:solid;opacity:0;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after,.mat-slider-has-ticks:hover:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after{opacity:1}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-disabled) .mat-slider-ticks,.mat-slider-has-ticks:hover:not(.mat-slider-disabled) .mat-slider-ticks{opacity:1}.mat-slider-thumb-label-showing .mat-slider-focus-ring{display:none}.mat-slider-thumb-label-showing .mat-slider-thumb-label{display:flex}.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:100% 100%}.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:0 0}.mat-slider:not(.mat-slider-disabled).cdk-focused.mat-slider-thumb-label-showing .mat-slider-thumb{transform:scale(0)}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label{border-radius:50% 50% 0}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label-text{opacity:1}.mat-slider:not(.mat-slider-disabled).cdk-mouse-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-touch-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-program-focused .mat-slider-thumb{border-width:2px;transform:scale(1)}.mat-slider-disabled .mat-slider-focus-ring{transform:scale(0);opacity:0}.mat-slider-disabled .mat-slider-thumb{border-width:4px;transform:scale(0.5)}.mat-slider-disabled .mat-slider-thumb-label{display:none}.mat-slider-horizontal{height:48px;min-width:128px}.mat-slider-horizontal .mat-slider-wrapper{height:2px;top:23px;left:8px;right:8px}.mat-slider-horizontal .mat-slider-wrapper::after{height:2px;border-left-width:2px;right:0;top:0}.mat-slider-horizontal .mat-slider-track-wrapper{height:2px;width:100%}.mat-slider-horizontal .mat-slider-track-fill{height:2px;width:100%;transform:scaleX(0)}.mat-slider-horizontal .mat-slider-track-background{height:2px;width:100%;transform:scaleX(1)}.mat-slider-horizontal .mat-slider-ticks-container{height:2px;width:100%}.cdk-high-contrast-active .mat-slider-horizontal .mat-slider-ticks-container{height:0;outline:solid 2px;top:1px}.mat-slider-horizontal .mat-slider-ticks{height:2px;width:100%}.mat-slider-horizontal .mat-slider-thumb-container{width:100%;height:0;top:50%}.mat-slider-horizontal .mat-slider-focus-ring{top:-15px;right:-15px}.mat-slider-horizontal .mat-slider-thumb-label{right:-14px;top:-40px;transform:translateY(26px) scale(0.01) rotate(45deg)}.mat-slider-horizontal .mat-slider-thumb-label-text{transform:rotate(-45deg)}.mat-slider-horizontal.cdk-focused .mat-slider-thumb-label{transform:rotate(45deg)}.cdk-high-contrast-active .mat-slider-horizontal.cdk-focused .mat-slider-thumb-label,.cdk-high-contrast-active .mat-slider-horizontal.cdk-focused .mat-slider-thumb-label-text{transform:none}.mat-slider-vertical{width:48px;min-height:128px}.mat-slider-vertical .mat-slider-wrapper{width:2px;top:8px;bottom:8px;left:23px}.mat-slider-vertical .mat-slider-wrapper::after{width:2px;border-top-width:2px;bottom:0;left:0}.mat-slider-vertical .mat-slider-track-wrapper{height:100%;width:2px}.mat-slider-vertical .mat-slider-track-fill{height:100%;width:2px;transform:scaleY(0)}.mat-slider-vertical .mat-slider-track-background{height:100%;width:2px;transform:scaleY(1)}.mat-slider-vertical .mat-slider-ticks-container{width:2px;height:100%}.cdk-high-contrast-active .mat-slider-vertical .mat-slider-ticks-container{width:0;outline:solid 2px;left:1px}.mat-slider-vertical .mat-slider-focus-ring{bottom:-15px;left:-15px}.mat-slider-vertical .mat-slider-ticks{width:2px;height:100%}.mat-slider-vertical .mat-slider-thumb-container{height:100%;width:0;left:50%}.mat-slider-vertical .mat-slider-thumb{-webkit-backface-visibility:hidden;backface-visibility:hidden}.mat-slider-vertical .mat-slider-thumb-label{bottom:-14px;left:-40px;transform:translateX(26px) scale(0.01) rotate(-45deg)}.mat-slider-vertical .mat-slider-thumb-label-text{transform:rotate(45deg)}.mat-slider-vertical.cdk-focused .mat-slider-thumb-label{transform:rotate(-45deg)}[dir=rtl] .mat-slider-wrapper::after{left:0;right:auto}[dir=rtl] .mat-slider-horizontal .mat-slider-track-fill{transform-origin:100% 100%}[dir=rtl] .mat-slider-horizontal .mat-slider-track-background{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:100% 100%}.mat-slider._mat-animation-noopable .mat-slider-track-fill,.mat-slider._mat-animation-noopable .mat-slider-track-background,.mat-slider._mat-animation-noopable .mat-slider-ticks,.mat-slider._mat-animation-noopable .mat-slider-thumb-container,.mat-slider._mat-animation-noopable .mat-slider-focus-ring,.mat-slider._mat-animation-noopable .mat-slider-thumb,.mat-slider._mat-animation-noopable .mat-slider-thumb-label,.mat-slider._mat-animation-noopable .mat-slider-thumb-label-text,.mat-slider._mat-animation-noopable .mat-slider-has-ticks .mat-slider-wrapper::after{transition:none}\n']
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: FocusMonitor
    }, {
      type: ChangeDetectorRef
    }, {
      type: Directionality,
      decorators: [{
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Attribute,
        args: ["tabindex"]
      }]
    }, {
      type: NgZone
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [ANIMATION_MODULE_TYPE]
      }]
    }];
  }, {
    invert: [{
      type: Input
    }],
    max: [{
      type: Input
    }],
    min: [{
      type: Input
    }],
    step: [{
      type: Input
    }],
    thumbLabel: [{
      type: Input
    }],
    tickInterval: [{
      type: Input
    }],
    value: [{
      type: Input
    }],
    displayWith: [{
      type: Input
    }],
    valueText: [{
      type: Input
    }],
    vertical: [{
      type: Input
    }],
    change: [{
      type: Output
    }],
    input: [{
      type: Output
    }],
    valueChange: [{
      type: Output
    }],
    _sliderWrapper: [{
      type: ViewChild,
      args: ["sliderWrapper"]
    }]
  });
})();
function isSafeNumber(value) {
  return !isNaN(value) && isFinite(value);
}
function isTouchEvent(event) {
  return event.type[0] === "t";
}
function getPointerPositionOnPage(event, id) {
  let point;
  if (isTouchEvent(event)) {
    if (typeof id === "number") {
      point = findMatchingTouch(event.touches, id) || findMatchingTouch(event.changedTouches, id);
    } else {
      point = event.touches[0] || event.changedTouches[0];
    }
  } else {
    point = event;
  }
  return point ? {
    x: point.clientX,
    y: point.clientY
  } : void 0;
}
function findMatchingTouch(touches, id) {
  for (let i = 0; i < touches.length; i++) {
    if (touches[i].identifier === id) {
      return touches[i];
    }
  }
  return void 0;
}
function getTouchIdForSlider(event, sliderHost) {
  for (let i = 0; i < event.touches.length; i++) {
    const target = event.touches[i].target;
    if (sliderHost === target || sliderHost.contains(target)) {
      return event.touches[i].identifier;
    }
  }
  return void 0;
}
var MatSliderModule = class {
};
MatSliderModule.ɵfac = function MatSliderModule_Factory(ɵt) {
  return new (ɵt || MatSliderModule)();
};
MatSliderModule.ɵmod = ɵɵdefineNgModule({
  type: MatSliderModule,
  declarations: [MatSlider],
  imports: [CommonModule, MatCommonModule],
  exports: [MatSlider, MatCommonModule]
});
MatSliderModule.ɵinj = ɵɵdefineInjector({
  imports: [[CommonModule, MatCommonModule], MatCommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatSliderModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, MatCommonModule],
      exports: [MatSlider, MatCommonModule],
      declarations: [MatSlider]
    }]
  }], null, null);
})();

// node_modules/@angular/material/fesm2020/tabs.mjs
var _c010 = ["*"];
function MatTab_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵprojection(0);
  }
}
var _c16 = (a0) => ({
  animationDuration: a0
});
var _c24 = (a0, a1) => ({
  value: a0,
  params: a1
});
function MatTabBody_ng_template_2_Template(rf, ctx) {
}
var _c34 = ["tabListContainer"];
var _c43 = ["tabList"];
var _c5 = ["tabListInner"];
var _c6 = ["nextPaginator"];
var _c7 = ["previousPaginator"];
var _c8 = ["tabBodyWrapper"];
var _c9 = ["tabHeader"];
function MatTabGroup_div_2_ng_template_2_ng_template_0_Template(rf, ctx) {
}
function MatTabGroup_div_2_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, MatTabGroup_div_2_ng_template_2_ng_template_0_Template, 0, 0, "ng-template", 10);
  }
  if (rf & 2) {
    const tab_r4 = ɵɵnextContext().$implicit;
    ɵɵproperty("cdkPortalOutlet", tab_r4.templateLabel);
  }
}
function MatTabGroup_div_2_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtext(0);
  }
  if (rf & 2) {
    const tab_r4 = ɵɵnextContext().$implicit;
    ɵɵtextInterpolate(tab_r4.textLabel);
  }
}
function MatTabGroup_div_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 7);
    ɵɵlistener("click", function MatTabGroup_div_2_Template_div_click_0_listener() {
      const ctx_r2 = ɵɵrestoreView(_r2);
      const tab_r4 = ctx_r2.$implicit;
      const i_r5 = ctx_r2.index;
      const ctx_r5 = ɵɵnextContext();
      const tabHeader_r7 = ɵɵreference(1);
      return ɵɵresetView(ctx_r5._handleClick(tab_r4, tabHeader_r7, i_r5));
    })("cdkFocusChange", function MatTabGroup_div_2_Template_div_cdkFocusChange_0_listener($event) {
      const i_r5 = ɵɵrestoreView(_r2).index;
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5._tabFocusChanged($event, i_r5));
    });
    ɵɵelementStart(1, "div", 8);
    ɵɵtemplate(2, MatTabGroup_div_2_ng_template_2_Template, 1, 1, "ng-template", 9)(3, MatTabGroup_div_2_ng_template_3_Template, 1, 1, "ng-template", null, 2, ɵɵtemplateRefExtractor);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const tab_r4 = ctx.$implicit;
    const i_r5 = ctx.index;
    const tabTextLabel_r8 = ɵɵreference(4);
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassProp("mat-tab-label-active", ctx_r5.selectedIndex === i_r5);
    ɵɵproperty("id", ctx_r5._getTabLabelId(i_r5))("ngClass", tab_r4.labelClass)("disabled", tab_r4.disabled)("matRippleDisabled", tab_r4.disabled || ctx_r5.disableRipple);
    ɵɵattribute("tabIndex", ctx_r5._getTabIndex(tab_r4, i_r5))("aria-posinset", i_r5 + 1)("aria-setsize", ctx_r5._tabs.length)("aria-controls", ctx_r5._getTabContentId(i_r5))("aria-selected", ctx_r5.selectedIndex === i_r5)("aria-label", tab_r4.ariaLabel || null)("aria-labelledby", !tab_r4.ariaLabel && tab_r4.ariaLabelledby ? tab_r4.ariaLabelledby : null);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", tab_r4.templateLabel)("ngIfElse", tabTextLabel_r8);
  }
}
function MatTabGroup_mat_tab_body_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-tab-body", 11);
    ɵɵlistener("_onCentered", function MatTabGroup_mat_tab_body_5_Template_mat_tab_body__onCentered_0_listener() {
      ɵɵrestoreView(_r9);
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5._removeTabBodyWrapperHeight());
    })("_onCentering", function MatTabGroup_mat_tab_body_5_Template_mat_tab_body__onCentering_0_listener($event) {
      ɵɵrestoreView(_r9);
      const ctx_r5 = ɵɵnextContext();
      return ɵɵresetView(ctx_r5._setTabBodyWrapperHeight($event));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const tab_r10 = ctx.$implicit;
    const i_r11 = ctx.index;
    const ctx_r5 = ɵɵnextContext();
    ɵɵclassProp("mat-tab-body-active", ctx_r5.selectedIndex === i_r11);
    ɵɵproperty("id", ctx_r5._getTabContentId(i_r11))("ngClass", tab_r10.bodyClass)("content", tab_r10.content)("position", tab_r10.position)("origin", tab_r10.origin)("animationDuration", ctx_r5.animationDuration);
    ɵɵattribute("tabindex", ctx_r5.contentTabIndex != null && ctx_r5.selectedIndex === i_r11 ? ctx_r5.contentTabIndex : null)("aria-labelledby", ctx_r5._getTabLabelId(i_r11));
  }
}
var _c10 = ["mat-tab-nav-bar", ""];
var _MAT_INK_BAR_POSITIONER = new InjectionToken("MatInkBarPositioner", {
  providedIn: "root",
  factory: _MAT_INK_BAR_POSITIONER_FACTORY
});
function _MAT_INK_BAR_POSITIONER_FACTORY() {
  const method = (element) => ({
    left: element ? (element.offsetLeft || 0) + "px" : "0",
    width: element ? (element.offsetWidth || 0) + "px" : "0"
  });
  return method;
}
var MatInkBar = class {
  constructor(_elementRef, _ngZone, _inkBarPositioner, _animationMode) {
    this._elementRef = _elementRef;
    this._ngZone = _ngZone;
    this._inkBarPositioner = _inkBarPositioner;
    this._animationMode = _animationMode;
  }
  /**
   * Calculates the styles from the provided element in order to align the ink-bar to that element.
   * Shows the ink bar if previously set as hidden.
   * @param element
   */
  alignToElement(element) {
    this.show();
    this._ngZone.onStable.pipe(take(1)).subscribe(() => {
      const positions = this._inkBarPositioner(element);
      const inkBar = this._elementRef.nativeElement;
      inkBar.style.left = positions.left;
      inkBar.style.width = positions.width;
    });
  }
  /** Shows the ink bar. */
  show() {
    this._elementRef.nativeElement.style.visibility = "visible";
  }
  /** Hides the ink bar. */
  hide() {
    this._elementRef.nativeElement.style.visibility = "hidden";
  }
};
MatInkBar.ɵfac = function MatInkBar_Factory(ɵt) {
  return new (ɵt || MatInkBar)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(_MAT_INK_BAR_POSITIONER), ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8));
};
MatInkBar.ɵdir = ɵɵdefineDirective({
  type: MatInkBar,
  selectors: [["mat-ink-bar"]],
  hostAttrs: [1, "mat-ink-bar"],
  hostVars: 2,
  hostBindings: function MatInkBar_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("_mat-animation-noopable", ctx._animationMode === "NoopAnimations");
    }
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatInkBar, [{
    type: Directive,
    args: [{
      selector: "mat-ink-bar",
      host: {
        "class": "mat-ink-bar",
        "[class._mat-animation-noopable]": `_animationMode === 'NoopAnimations'`
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [_MAT_INK_BAR_POSITIONER]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [ANIMATION_MODULE_TYPE]
      }]
    }];
  }, null);
})();
var MAT_TAB_CONTENT = new InjectionToken("MatTabContent");
var MatTabContent = class {
  constructor(template) {
    this.template = template;
  }
};
MatTabContent.ɵfac = function MatTabContent_Factory(ɵt) {
  return new (ɵt || MatTabContent)(ɵɵdirectiveInject(TemplateRef));
};
MatTabContent.ɵdir = ɵɵdefineDirective({
  type: MatTabContent,
  selectors: [["", "matTabContent", ""]],
  features: [ɵɵProvidersFeature([{
    provide: MAT_TAB_CONTENT,
    useExisting: MatTabContent
  }])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTabContent, [{
    type: Directive,
    args: [{
      selector: "[matTabContent]",
      providers: [{
        provide: MAT_TAB_CONTENT,
        useExisting: MatTabContent
      }]
    }]
  }], function() {
    return [{
      type: TemplateRef
    }];
  }, null);
})();
var MAT_TAB_LABEL = new InjectionToken("MatTabLabel");
var MAT_TAB = new InjectionToken("MAT_TAB");
var MatTabLabel = class extends CdkPortal {
  constructor(templateRef, viewContainerRef, _closestTab) {
    super(templateRef, viewContainerRef);
    this._closestTab = _closestTab;
  }
};
MatTabLabel.ɵfac = function MatTabLabel_Factory(ɵt) {
  return new (ɵt || MatTabLabel)(ɵɵdirectiveInject(TemplateRef), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(MAT_TAB, 8));
};
MatTabLabel.ɵdir = ɵɵdefineDirective({
  type: MatTabLabel,
  selectors: [["", "mat-tab-label", ""], ["", "matTabLabel", ""]],
  features: [ɵɵProvidersFeature([{
    provide: MAT_TAB_LABEL,
    useExisting: MatTabLabel
  }]), ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTabLabel, [{
    type: Directive,
    args: [{
      selector: "[mat-tab-label], [matTabLabel]",
      providers: [{
        provide: MAT_TAB_LABEL,
        useExisting: MatTabLabel
      }]
    }]
  }], function() {
    return [{
      type: TemplateRef
    }, {
      type: ViewContainerRef
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [MAT_TAB]
      }, {
        type: Optional
      }]
    }];
  }, null);
})();
var _MatTabBase = mixinDisabled(class {
});
var MAT_TAB_GROUP = new InjectionToken("MAT_TAB_GROUP");
var MatTab = class extends _MatTabBase {
  constructor(_viewContainerRef, _closestTabGroup) {
    super();
    this._viewContainerRef = _viewContainerRef;
    this._closestTabGroup = _closestTabGroup;
    this.textLabel = "";
    this._contentPortal = null;
    this._stateChanges = new Subject();
    this.position = null;
    this.origin = null;
    this.isActive = false;
  }
  /** Content for the tab label given by `<ng-template mat-tab-label>`. */
  get templateLabel() {
    return this._templateLabel;
  }
  set templateLabel(value) {
    this._setTemplateLabelInput(value);
  }
  /** @docs-private */
  get content() {
    return this._contentPortal;
  }
  ngOnChanges(changes) {
    if (changes.hasOwnProperty("textLabel") || changes.hasOwnProperty("disabled")) {
      this._stateChanges.next();
    }
  }
  ngOnDestroy() {
    this._stateChanges.complete();
  }
  ngOnInit() {
    this._contentPortal = new TemplatePortal(this._explicitContent || this._implicitContent, this._viewContainerRef);
  }
  /**
   * This has been extracted to a util because of TS 4 and VE.
   * View Engine doesn't support property rename inheritance.
   * TS 4.0 doesn't allow properties to override accessors or vice-versa.
   * @docs-private
   */
  _setTemplateLabelInput(value) {
    if (value && value._closestTab === this) {
      this._templateLabel = value;
    }
  }
};
MatTab.ɵfac = function MatTab_Factory(ɵt) {
  return new (ɵt || MatTab)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(MAT_TAB_GROUP, 8));
};
MatTab.ɵcmp = ɵɵdefineComponent({
  type: MatTab,
  selectors: [["mat-tab"]],
  contentQueries: function MatTab_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, MAT_TAB_LABEL, 5);
      ɵɵcontentQuery(dirIndex, MAT_TAB_CONTENT, 7, TemplateRef);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.templateLabel = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._explicitContent = _t.first);
    }
  },
  viewQuery: function MatTab_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(TemplateRef, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._implicitContent = _t.first);
    }
  },
  inputs: {
    disabled: "disabled",
    textLabel: [0, "label", "textLabel"],
    ariaLabel: [0, "aria-label", "ariaLabel"],
    ariaLabelledby: [0, "aria-labelledby", "ariaLabelledby"],
    labelClass: "labelClass",
    bodyClass: "bodyClass"
  },
  exportAs: ["matTab"],
  features: [ɵɵProvidersFeature([{
    provide: MAT_TAB,
    useExisting: MatTab
  }]), ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature],
  ngContentSelectors: _c010,
  decls: 1,
  vars: 0,
  template: function MatTab_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵtemplate(0, MatTab_ng_template_0_Template, 1, 0, "ng-template");
    }
  },
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTab, [{
    type: Component,
    args: [{
      selector: "mat-tab",
      inputs: ["disabled"],
      changeDetection: ChangeDetectionStrategy.Default,
      encapsulation: ViewEncapsulation$1.None,
      exportAs: "matTab",
      providers: [{
        provide: MAT_TAB,
        useExisting: MatTab
      }],
      template: "<!-- Create a template for the content of the <mat-tab> so that we can grab a reference to this\n    TemplateRef and use it in a Portal to render the tab content in the appropriate place in the\n    tab-group. -->\n<ng-template><ng-content></ng-content></ng-template>\n"
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [MAT_TAB_GROUP]
      }, {
        type: Optional
      }]
    }];
  }, {
    templateLabel: [{
      type: ContentChild,
      args: [MAT_TAB_LABEL]
    }],
    _explicitContent: [{
      type: ContentChild,
      args: [MAT_TAB_CONTENT, {
        read: TemplateRef,
        static: true
      }]
    }],
    _implicitContent: [{
      type: ViewChild,
      args: [TemplateRef, {
        static: true
      }]
    }],
    textLabel: [{
      type: Input,
      args: ["label"]
    }],
    ariaLabel: [{
      type: Input,
      args: ["aria-label"]
    }],
    ariaLabelledby: [{
      type: Input,
      args: ["aria-labelledby"]
    }],
    labelClass: [{
      type: Input
    }],
    bodyClass: [{
      type: Input
    }]
  });
})();
var matTabsAnimations = {
  /** Animation translates a tab along the X axis. */
  translateTab: trigger("translateTab", [
    // Note: transitions to `none` instead of 0, because some browsers might blur the content.
    state("center, void, left-origin-center, right-origin-center", style({
      transform: "none"
    })),
    // If the tab is either on the left or right, we additionally add a `min-height` of 1px
    // in order to ensure that the element has a height before its state changes. This is
    // necessary because Chrome does seem to skip the transition in RTL mode if the element does
    // not have a static height and is not rendered. See related issue: #9465
    state("left", style({
      transform: "translate3d(-100%, 0, 0)",
      minHeight: "1px"
    })),
    state("right", style({
      transform: "translate3d(100%, 0, 0)",
      minHeight: "1px"
    })),
    transition("* => left, * => right, left => center, right => center", animate("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)")),
    transition("void => left-origin-center", [style({
      transform: "translate3d(-100%, 0, 0)"
    }), animate("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)")]),
    transition("void => right-origin-center", [style({
      transform: "translate3d(100%, 0, 0)"
    }), animate("{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)")])
  ])
};
var MatTabBodyPortal = class extends CdkPortalOutlet {
  constructor(componentFactoryResolver, viewContainerRef, _host, _document) {
    super(componentFactoryResolver, viewContainerRef, _document);
    this._host = _host;
    this._centeringSub = Subscription.EMPTY;
    this._leavingSub = Subscription.EMPTY;
  }
  /** Set initial visibility or set up subscription for changing visibility. */
  ngOnInit() {
    super.ngOnInit();
    this._centeringSub = this._host._beforeCentering.pipe(startWith(this._host._isCenterPosition(this._host._position))).subscribe((isCentering) => {
      if (isCentering && !this.hasAttached()) {
        this.attach(this._host._content);
      }
    });
    this._leavingSub = this._host._afterLeavingCenter.subscribe(() => {
      this.detach();
    });
  }
  /** Clean up centering subscription. */
  ngOnDestroy() {
    super.ngOnDestroy();
    this._centeringSub.unsubscribe();
    this._leavingSub.unsubscribe();
  }
};
MatTabBodyPortal.ɵfac = function MatTabBodyPortal_Factory(ɵt) {
  return new (ɵt || MatTabBodyPortal)(ɵɵdirectiveInject(ComponentFactoryResolver$1), ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(forwardRef(() => MatTabBody)), ɵɵdirectiveInject(DOCUMENT));
};
MatTabBodyPortal.ɵdir = ɵɵdefineDirective({
  type: MatTabBodyPortal,
  selectors: [["", "matTabBodyHost", ""]],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTabBodyPortal, [{
    type: Directive,
    args: [{
      selector: "[matTabBodyHost]"
    }]
  }], function() {
    return [{
      type: ComponentFactoryResolver$1
    }, {
      type: ViewContainerRef
    }, {
      type: MatTabBody,
      decorators: [{
        type: Inject,
        args: [forwardRef(() => MatTabBody)]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [DOCUMENT]
      }]
    }];
  }, null);
})();
var _MatTabBodyBase = class {
  constructor(_elementRef, _dir, changeDetectorRef) {
    this._elementRef = _elementRef;
    this._dir = _dir;
    this._dirChangeSubscription = Subscription.EMPTY;
    this._translateTabComplete = new Subject();
    this._onCentering = new EventEmitter();
    this._beforeCentering = new EventEmitter();
    this._afterLeavingCenter = new EventEmitter();
    this._onCentered = new EventEmitter(true);
    this.animationDuration = "500ms";
    if (_dir) {
      this._dirChangeSubscription = _dir.change.subscribe((dir) => {
        this._computePositionAnimationState(dir);
        changeDetectorRef.markForCheck();
      });
    }
    this._translateTabComplete.pipe(distinctUntilChanged((x, y) => {
      return x.fromState === y.fromState && x.toState === y.toState;
    })).subscribe((event) => {
      if (this._isCenterPosition(event.toState) && this._isCenterPosition(this._position)) {
        this._onCentered.emit();
      }
      if (this._isCenterPosition(event.fromState) && !this._isCenterPosition(this._position)) {
        this._afterLeavingCenter.emit();
      }
    });
  }
  /** The shifted index position of the tab body, where zero represents the active center tab. */
  set position(position) {
    this._positionIndex = position;
    this._computePositionAnimationState();
  }
  /**
   * After initialized, check if the content is centered and has an origin. If so, set the
   * special position states that transition the tab from the left or right before centering.
   */
  ngOnInit() {
    if (this._position == "center" && this.origin != null) {
      this._position = this._computePositionFromOrigin(this.origin);
    }
  }
  ngOnDestroy() {
    this._dirChangeSubscription.unsubscribe();
    this._translateTabComplete.complete();
  }
  _onTranslateTabStarted(event) {
    const isCentering = this._isCenterPosition(event.toState);
    this._beforeCentering.emit(isCentering);
    if (isCentering) {
      this._onCentering.emit(this._elementRef.nativeElement.clientHeight);
    }
  }
  /** The text direction of the containing app. */
  _getLayoutDirection() {
    return this._dir && this._dir.value === "rtl" ? "rtl" : "ltr";
  }
  /** Whether the provided position state is considered center, regardless of origin. */
  _isCenterPosition(position) {
    return position == "center" || position == "left-origin-center" || position == "right-origin-center";
  }
  /** Computes the position state that will be used for the tab-body animation trigger. */
  _computePositionAnimationState(dir = this._getLayoutDirection()) {
    if (this._positionIndex < 0) {
      this._position = dir == "ltr" ? "left" : "right";
    } else if (this._positionIndex > 0) {
      this._position = dir == "ltr" ? "right" : "left";
    } else {
      this._position = "center";
    }
  }
  /**
   * Computes the position state based on the specified origin position. This is used if the
   * tab is becoming visible immediately after creation.
   */
  _computePositionFromOrigin(origin) {
    const dir = this._getLayoutDirection();
    if (dir == "ltr" && origin <= 0 || dir == "rtl" && origin > 0) {
      return "left-origin-center";
    }
    return "right-origin-center";
  }
};
_MatTabBodyBase.ɵfac = function _MatTabBodyBase_Factory(ɵt) {
  return new (ɵt || _MatTabBodyBase)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(ChangeDetectorRef));
};
_MatTabBodyBase.ɵdir = ɵɵdefineDirective({
  type: _MatTabBodyBase,
  inputs: {
    _content: [0, "content", "_content"],
    origin: "origin",
    animationDuration: "animationDuration",
    position: "position"
  },
  outputs: {
    _onCentering: "_onCentering",
    _beforeCentering: "_beforeCentering",
    _afterLeavingCenter: "_afterLeavingCenter",
    _onCentered: "_onCentered"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_MatTabBodyBase, [{
    type: Directive
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Directionality,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    _onCentering: [{
      type: Output
    }],
    _beforeCentering: [{
      type: Output
    }],
    _afterLeavingCenter: [{
      type: Output
    }],
    _onCentered: [{
      type: Output
    }],
    _content: [{
      type: Input,
      args: ["content"]
    }],
    origin: [{
      type: Input
    }],
    animationDuration: [{
      type: Input
    }],
    position: [{
      type: Input
    }]
  });
})();
var MatTabBody = class extends _MatTabBodyBase {
  constructor(elementRef, dir, changeDetectorRef) {
    super(elementRef, dir, changeDetectorRef);
  }
};
MatTabBody.ɵfac = function MatTabBody_Factory(ɵt) {
  return new (ɵt || MatTabBody)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(ChangeDetectorRef));
};
MatTabBody.ɵcmp = ɵɵdefineComponent({
  type: MatTabBody,
  selectors: [["mat-tab-body"]],
  viewQuery: function MatTabBody_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(CdkPortalOutlet, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._portalHost = _t.first);
    }
  },
  hostAttrs: [1, "mat-tab-body"],
  features: [ɵɵInheritDefinitionFeature],
  decls: 3,
  vars: 6,
  consts: [["content", ""], ["cdkScrollable", "", 1, "mat-tab-body-content"], ["matTabBodyHost", ""]],
  template: function MatTabBody_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "div", 1, 0);
      ɵɵlistener("@translateTab.start", function MatTabBody_Template_div_animation_translateTab_start_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._onTranslateTabStarted($event));
      })("@translateTab.done", function MatTabBody_Template_div_animation_translateTab_done_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._translateTabComplete.next($event));
      });
      ɵɵtemplate(2, MatTabBody_ng_template_2_Template, 0, 0, "ng-template", 2);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("@translateTab", ɵɵpureFunction2(3, _c24, ctx._position, ɵɵpureFunction1(1, _c16, ctx.animationDuration)));
    }
  },
  dependencies: [MatTabBodyPortal],
  styles: ['.mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}.mat-tab-body-content[style*="visibility: hidden"]{display:none}\n'],
  encapsulation: 2,
  data: {
    animation: [matTabsAnimations.translateTab]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTabBody, [{
    type: Component,
    args: [{
      selector: "mat-tab-body",
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.Default,
      animations: [matTabsAnimations.translateTab],
      host: {
        "class": "mat-tab-body"
      },
      template: '<div class="mat-tab-body-content" #content\n     [@translateTab]="{\n        value: _position,\n        params: {animationDuration: animationDuration}\n     }"\n     (@translateTab.start)="_onTranslateTabStarted($event)"\n     (@translateTab.done)="_translateTabComplete.next($event)"\n     cdkScrollable>\n  <ng-template matTabBodyHost></ng-template>\n</div>\n',
      styles: ['.mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}.mat-tab-body-content[style*="visibility: hidden"]{display:none}\n']
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Directionality,
      decorators: [{
        type: Optional
      }]
    }, {
      type: ChangeDetectorRef
    }];
  }, {
    _portalHost: [{
      type: ViewChild,
      args: [CdkPortalOutlet]
    }]
  });
})();
var MAT_TABS_CONFIG = new InjectionToken("MAT_TABS_CONFIG");
var _MatTabLabelWrapperBase = mixinDisabled(class {
});
var MatTabLabelWrapper = class extends _MatTabLabelWrapperBase {
  constructor(elementRef) {
    super();
    this.elementRef = elementRef;
  }
  /** Sets focus on the wrapper element */
  focus() {
    this.elementRef.nativeElement.focus();
  }
  getOffsetLeft() {
    return this.elementRef.nativeElement.offsetLeft;
  }
  getOffsetWidth() {
    return this.elementRef.nativeElement.offsetWidth;
  }
};
MatTabLabelWrapper.ɵfac = function MatTabLabelWrapper_Factory(ɵt) {
  return new (ɵt || MatTabLabelWrapper)(ɵɵdirectiveInject(ElementRef));
};
MatTabLabelWrapper.ɵdir = ɵɵdefineDirective({
  type: MatTabLabelWrapper,
  selectors: [["", "matTabLabelWrapper", ""]],
  hostVars: 3,
  hostBindings: function MatTabLabelWrapper_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-disabled", !!ctx.disabled);
      ɵɵclassProp("mat-tab-disabled", ctx.disabled);
    }
  },
  inputs: {
    disabled: "disabled"
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTabLabelWrapper, [{
    type: Directive,
    args: [{
      selector: "[matTabLabelWrapper]",
      inputs: ["disabled"],
      host: {
        "[class.mat-tab-disabled]": "disabled",
        "[attr.aria-disabled]": "!!disabled"
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }];
  }, null);
})();
var passiveEventListenerOptions = normalizePassiveListenerOptions({
  passive: true
});
var EXAGGERATED_OVERSCROLL = 60;
var HEADER_SCROLL_DELAY = 650;
var HEADER_SCROLL_INTERVAL = 100;
var MatPaginatedTabHeader = class {
  constructor(_elementRef, _changeDetectorRef, _viewportRuler, _dir, _ngZone, _platform, _animationMode) {
    this._elementRef = _elementRef;
    this._changeDetectorRef = _changeDetectorRef;
    this._viewportRuler = _viewportRuler;
    this._dir = _dir;
    this._ngZone = _ngZone;
    this._platform = _platform;
    this._animationMode = _animationMode;
    this._scrollDistance = 0;
    this._selectedIndexChanged = false;
    this._destroyed = new Subject();
    this._showPaginationControls = false;
    this._disableScrollAfter = true;
    this._disableScrollBefore = true;
    this._stopScrolling = new Subject();
    this.disablePagination = false;
    this._selectedIndex = 0;
    this.selectFocusedIndex = new EventEmitter();
    this.indexFocused = new EventEmitter();
    _ngZone.runOutsideAngular(() => {
      fromEvent(_elementRef.nativeElement, "mouseleave").pipe(takeUntil(this._destroyed)).subscribe(() => {
        this._stopInterval();
      });
    });
  }
  /** The index of the active tab. */
  get selectedIndex() {
    return this._selectedIndex;
  }
  set selectedIndex(value) {
    value = coerceNumberProperty(value);
    if (this._selectedIndex != value) {
      this._selectedIndexChanged = true;
      this._selectedIndex = value;
      if (this._keyManager) {
        this._keyManager.updateActiveItem(value);
      }
    }
  }
  ngAfterViewInit() {
    fromEvent(this._previousPaginator.nativeElement, "touchstart", passiveEventListenerOptions).pipe(takeUntil(this._destroyed)).subscribe(() => {
      this._handlePaginatorPress("before");
    });
    fromEvent(this._nextPaginator.nativeElement, "touchstart", passiveEventListenerOptions).pipe(takeUntil(this._destroyed)).subscribe(() => {
      this._handlePaginatorPress("after");
    });
  }
  ngAfterContentInit() {
    const dirChange = this._dir ? this._dir.change : of("ltr");
    const resize = this._viewportRuler.change(150);
    const realign = () => {
      this.updatePagination();
      this._alignInkBarToSelectedTab();
    };
    this._keyManager = new FocusKeyManager(this._items).withHorizontalOrientation(this._getLayoutDirection()).withHomeAndEnd().withWrap();
    this._keyManager.updateActiveItem(this._selectedIndex);
    this._ngZone.onStable.pipe(take(1)).subscribe(realign);
    merge(dirChange, resize, this._items.changes, this._itemsResized()).pipe(takeUntil(this._destroyed)).subscribe(() => {
      this._ngZone.run(() => {
        Promise.resolve().then(() => {
          this._scrollDistance = Math.max(0, Math.min(this._getMaxScrollDistance(), this._scrollDistance));
          realign();
        });
      });
      this._keyManager.withHorizontalOrientation(this._getLayoutDirection());
    });
    this._keyManager.change.pipe(takeUntil(this._destroyed)).subscribe((newFocusIndex) => {
      this.indexFocused.emit(newFocusIndex);
      this._setTabFocus(newFocusIndex);
    });
  }
  /** Sends any changes that could affect the layout of the items. */
  _itemsResized() {
    if (typeof ResizeObserver !== "function") {
      return EMPTY;
    }
    return this._items.changes.pipe(
      startWith(this._items),
      switchMap((tabItems) => new Observable((observer) => this._ngZone.runOutsideAngular(() => {
        const resizeObserver = new ResizeObserver(() => {
          observer.next();
        });
        tabItems.forEach((item) => {
          resizeObserver.observe(item.elementRef.nativeElement);
        });
        return () => {
          resizeObserver.disconnect();
        };
      }))),
      // Skip the first emit since the resize observer emits when an item
      // is observed for new items when the tab is already inserted
      skip(1)
    );
  }
  ngAfterContentChecked() {
    if (this._tabLabelCount != this._items.length) {
      this.updatePagination();
      this._tabLabelCount = this._items.length;
      this._changeDetectorRef.markForCheck();
    }
    if (this._selectedIndexChanged) {
      this._scrollToLabel(this._selectedIndex);
      this._checkScrollingControls();
      this._alignInkBarToSelectedTab();
      this._selectedIndexChanged = false;
      this._changeDetectorRef.markForCheck();
    }
    if (this._scrollDistanceChanged) {
      this._updateTabScrollPosition();
      this._scrollDistanceChanged = false;
      this._changeDetectorRef.markForCheck();
    }
  }
  ngOnDestroy() {
    this._destroyed.next();
    this._destroyed.complete();
    this._stopScrolling.complete();
  }
  /** Handles keyboard events on the header. */
  _handleKeydown(event) {
    if (hasModifierKey(event)) {
      return;
    }
    switch (event.keyCode) {
      case ENTER:
      case SPACE:
        if (this.focusIndex !== this.selectedIndex) {
          this.selectFocusedIndex.emit(this.focusIndex);
          this._itemSelected(event);
        }
        break;
      default:
        this._keyManager.onKeydown(event);
    }
  }
  /**
   * Callback for when the MutationObserver detects that the content has changed.
   */
  _onContentChanges() {
    const textContent = this._elementRef.nativeElement.textContent;
    if (textContent !== this._currentTextContent) {
      this._currentTextContent = textContent || "";
      this._ngZone.run(() => {
        this.updatePagination();
        this._alignInkBarToSelectedTab();
        this._changeDetectorRef.markForCheck();
      });
    }
  }
  /**
   * Updates the view whether pagination should be enabled or not.
   *
   * WARNING: Calling this method can be very costly in terms of performance. It should be called
   * as infrequently as possible from outside of the Tabs component as it causes a reflow of the
   * page.
   */
  updatePagination() {
    this._checkPaginationEnabled();
    this._checkScrollingControls();
    this._updateTabScrollPosition();
  }
  /** Tracks which element has focus; used for keyboard navigation */
  get focusIndex() {
    return this._keyManager ? this._keyManager.activeItemIndex : 0;
  }
  /** When the focus index is set, we must manually send focus to the correct label */
  set focusIndex(value) {
    if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {
      return;
    }
    this._keyManager.setActiveItem(value);
  }
  /**
   * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is
   * providing a valid index and return true.
   */
  _isValidIndex(index) {
    if (!this._items) {
      return true;
    }
    const tab = this._items ? this._items.toArray()[index] : null;
    return !!tab && !tab.disabled;
  }
  /**
   * Sets focus on the HTML element for the label wrapper and scrolls it into the view if
   * scrolling is enabled.
   */
  _setTabFocus(tabIndex) {
    if (this._showPaginationControls) {
      this._scrollToLabel(tabIndex);
    }
    if (this._items && this._items.length) {
      this._items.toArray()[tabIndex].focus();
      const containerEl = this._tabListContainer.nativeElement;
      const dir = this._getLayoutDirection();
      if (dir == "ltr") {
        containerEl.scrollLeft = 0;
      } else {
        containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;
      }
    }
  }
  /** The layout direction of the containing app. */
  _getLayoutDirection() {
    return this._dir && this._dir.value === "rtl" ? "rtl" : "ltr";
  }
  /** Performs the CSS transformation on the tab list that will cause the list to scroll. */
  _updateTabScrollPosition() {
    if (this.disablePagination) {
      return;
    }
    const scrollDistance = this.scrollDistance;
    const translateX = this._getLayoutDirection() === "ltr" ? -scrollDistance : scrollDistance;
    this._tabList.nativeElement.style.transform = `translateX(${Math.round(translateX)}px)`;
    if (this._platform.TRIDENT || this._platform.EDGE) {
      this._tabListContainer.nativeElement.scrollLeft = 0;
    }
  }
  /** Sets the distance in pixels that the tab header should be transformed in the X-axis. */
  get scrollDistance() {
    return this._scrollDistance;
  }
  set scrollDistance(value) {
    this._scrollTo(value);
  }
  /**
   * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or
   * the end of the list, respectively). The distance to scroll is computed to be a third of the
   * length of the tab list view window.
   *
   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
   * should be called sparingly.
   */
  _scrollHeader(direction) {
    const viewLength = this._tabListContainer.nativeElement.offsetWidth;
    const scrollAmount = (direction == "before" ? -1 : 1) * viewLength / 3;
    return this._scrollTo(this._scrollDistance + scrollAmount);
  }
  /** Handles click events on the pagination arrows. */
  _handlePaginatorClick(direction) {
    this._stopInterval();
    this._scrollHeader(direction);
  }
  /**
   * Moves the tab list such that the desired tab label (marked by index) is moved into view.
   *
   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
   * should be called sparingly.
   */
  _scrollToLabel(labelIndex) {
    if (this.disablePagination) {
      return;
    }
    const selectedLabel = this._items ? this._items.toArray()[labelIndex] : null;
    if (!selectedLabel) {
      return;
    }
    const viewLength = this._tabListContainer.nativeElement.offsetWidth;
    const {
      offsetLeft,
      offsetWidth
    } = selectedLabel.elementRef.nativeElement;
    let labelBeforePos, labelAfterPos;
    if (this._getLayoutDirection() == "ltr") {
      labelBeforePos = offsetLeft;
      labelAfterPos = labelBeforePos + offsetWidth;
    } else {
      labelAfterPos = this._tabListInner.nativeElement.offsetWidth - offsetLeft;
      labelBeforePos = labelAfterPos - offsetWidth;
    }
    const beforeVisiblePos = this.scrollDistance;
    const afterVisiblePos = this.scrollDistance + viewLength;
    if (labelBeforePos < beforeVisiblePos) {
      this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;
    } else if (labelAfterPos > afterVisiblePos) {
      this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;
    }
  }
  /**
   * Evaluate whether the pagination controls should be displayed. If the scroll width of the
   * tab list is wider than the size of the header container, then the pagination controls should
   * be shown.
   *
   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
   * should be called sparingly.
   */
  _checkPaginationEnabled() {
    if (this.disablePagination) {
      this._showPaginationControls = false;
    } else {
      const isEnabled = this._tabListInner.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;
      if (!isEnabled) {
        this.scrollDistance = 0;
      }
      if (isEnabled !== this._showPaginationControls) {
        this._changeDetectorRef.markForCheck();
      }
      this._showPaginationControls = isEnabled;
    }
  }
  /**
   * Evaluate whether the before and after controls should be enabled or disabled.
   * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the
   * before button. If the header is at the end of the list (scroll distance is equal to the
   * maximum distance we can scroll), then disable the after button.
   *
   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
   * should be called sparingly.
   */
  _checkScrollingControls() {
    if (this.disablePagination) {
      this._disableScrollAfter = this._disableScrollBefore = true;
    } else {
      this._disableScrollBefore = this.scrollDistance == 0;
      this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();
      this._changeDetectorRef.markForCheck();
    }
  }
  /**
   * Determines what is the maximum length in pixels that can be set for the scroll distance. This
   * is equal to the difference in width between the tab list container and tab header container.
   *
   * This is an expensive call that forces a layout reflow to compute box and scroll metrics and
   * should be called sparingly.
   */
  _getMaxScrollDistance() {
    const lengthOfTabList = this._tabListInner.nativeElement.scrollWidth;
    const viewLength = this._tabListContainer.nativeElement.offsetWidth;
    return lengthOfTabList - viewLength || 0;
  }
  /** Tells the ink-bar to align itself to the current label wrapper */
  _alignInkBarToSelectedTab() {
    const selectedItem = this._items && this._items.length ? this._items.toArray()[this.selectedIndex] : null;
    const selectedLabelWrapper = selectedItem ? selectedItem.elementRef.nativeElement : null;
    if (selectedLabelWrapper) {
      this._inkBar.alignToElement(selectedLabelWrapper);
    } else {
      this._inkBar.hide();
    }
  }
  /** Stops the currently-running paginator interval.  */
  _stopInterval() {
    this._stopScrolling.next();
  }
  /**
   * Handles the user pressing down on one of the paginators.
   * Starts scrolling the header after a certain amount of time.
   * @param direction In which direction the paginator should be scrolled.
   */
  _handlePaginatorPress(direction, mouseEvent) {
    if (mouseEvent && mouseEvent.button != null && mouseEvent.button !== 0) {
      return;
    }
    this._stopInterval();
    timer(HEADER_SCROLL_DELAY, HEADER_SCROLL_INTERVAL).pipe(takeUntil(merge(this._stopScrolling, this._destroyed))).subscribe(() => {
      const {
        maxScrollDistance,
        distance
      } = this._scrollHeader(direction);
      if (distance === 0 || distance >= maxScrollDistance) {
        this._stopInterval();
      }
    });
  }
  /**
   * Scrolls the header to a given position.
   * @param position Position to which to scroll.
   * @returns Information on the current scroll distance and the maximum.
   */
  _scrollTo(position) {
    if (this.disablePagination) {
      return {
        maxScrollDistance: 0,
        distance: 0
      };
    }
    const maxScrollDistance = this._getMaxScrollDistance();
    this._scrollDistance = Math.max(0, Math.min(maxScrollDistance, position));
    this._scrollDistanceChanged = true;
    this._checkScrollingControls();
    return {
      maxScrollDistance,
      distance: this._scrollDistance
    };
  }
};
MatPaginatedTabHeader.ɵfac = function MatPaginatedTabHeader_Factory(ɵt) {
  return new (ɵt || MatPaginatedTabHeader)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewportRuler), ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Platform), ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8));
};
MatPaginatedTabHeader.ɵdir = ɵɵdefineDirective({
  type: MatPaginatedTabHeader,
  inputs: {
    disablePagination: "disablePagination"
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatPaginatedTabHeader, [{
    type: Directive
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewportRuler
    }, {
      type: Directionality,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgZone
    }, {
      type: Platform
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [ANIMATION_MODULE_TYPE]
      }]
    }];
  }, {
    disablePagination: [{
      type: Input
    }]
  });
})();
var _MatTabHeaderBase = class extends MatPaginatedTabHeader {
  constructor(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode) {
    super(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode);
    this._disableRipple = false;
  }
  /** Whether the ripple effect is disabled or not. */
  get disableRipple() {
    return this._disableRipple;
  }
  set disableRipple(value) {
    this._disableRipple = coerceBooleanProperty(value);
  }
  _itemSelected(event) {
    event.preventDefault();
  }
};
_MatTabHeaderBase.ɵfac = function _MatTabHeaderBase_Factory(ɵt) {
  return new (ɵt || _MatTabHeaderBase)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewportRuler), ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Platform), ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8));
};
_MatTabHeaderBase.ɵdir = ɵɵdefineDirective({
  type: _MatTabHeaderBase,
  inputs: {
    disableRipple: "disableRipple"
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_MatTabHeaderBase, [{
    type: Directive
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewportRuler
    }, {
      type: Directionality,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgZone
    }, {
      type: Platform
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [ANIMATION_MODULE_TYPE]
      }]
    }];
  }, {
    disableRipple: [{
      type: Input
    }]
  });
})();
var MatTabHeader = class extends _MatTabHeaderBase {
  constructor(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode) {
    super(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode);
  }
};
MatTabHeader.ɵfac = function MatTabHeader_Factory(ɵt) {
  return new (ɵt || MatTabHeader)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewportRuler), ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Platform), ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8));
};
MatTabHeader.ɵcmp = ɵɵdefineComponent({
  type: MatTabHeader,
  selectors: [["mat-tab-header"]],
  contentQueries: function MatTabHeader_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, MatTabLabelWrapper, 4);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._items = _t);
    }
  },
  viewQuery: function MatTabHeader_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(MatInkBar, 7);
      ɵɵviewQuery(_c34, 7);
      ɵɵviewQuery(_c43, 7);
      ɵɵviewQuery(_c5, 7);
      ɵɵviewQuery(_c6, 5);
      ɵɵviewQuery(_c7, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._inkBar = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._tabListContainer = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._tabList = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._tabListInner = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._nextPaginator = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._previousPaginator = _t.first);
    }
  },
  hostAttrs: [1, "mat-tab-header"],
  hostVars: 4,
  hostBindings: function MatTabHeader_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("mat-tab-header-pagination-controls-enabled", ctx._showPaginationControls)("mat-tab-header-rtl", ctx._getLayoutDirection() == "rtl");
    }
  },
  inputs: {
    selectedIndex: "selectedIndex"
  },
  outputs: {
    selectFocusedIndex: "selectFocusedIndex",
    indexFocused: "indexFocused"
  },
  features: [ɵɵInheritDefinitionFeature],
  ngContentSelectors: _c010,
  decls: 14,
  vars: 10,
  consts: [["previousPaginator", ""], ["tabListContainer", ""], ["tabList", ""], ["tabListInner", ""], ["nextPaginator", ""], ["aria-hidden", "true", "type", "button", "mat-ripple", "", "tabindex", "-1", 1, "mat-tab-header-pagination", "mat-tab-header-pagination-before", "mat-elevation-z4", 3, "click", "mousedown", "touchend", "matRippleDisabled", "disabled"], [1, "mat-tab-header-pagination-chevron"], [1, "mat-tab-label-container", 3, "keydown"], ["role", "tablist", 1, "mat-tab-list", 3, "cdkObserveContent"], [1, "mat-tab-labels"], ["aria-hidden", "true", "type", "button", "mat-ripple", "", "tabindex", "-1", 1, "mat-tab-header-pagination", "mat-tab-header-pagination-after", "mat-elevation-z4", 3, "mousedown", "click", "touchend", "matRippleDisabled", "disabled"]],
  template: function MatTabHeader_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵelementStart(0, "button", 5, 0);
      ɵɵlistener("click", function MatTabHeader_Template_button_click_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._handlePaginatorClick("before"));
      })("mousedown", function MatTabHeader_Template_button_mousedown_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._handlePaginatorPress("before", $event));
      })("touchend", function MatTabHeader_Template_button_touchend_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._stopInterval());
      });
      ɵɵelement(2, "div", 6);
      ɵɵelementEnd();
      ɵɵelementStart(3, "div", 7, 1);
      ɵɵlistener("keydown", function MatTabHeader_Template_div_keydown_3_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._handleKeydown($event));
      });
      ɵɵelementStart(5, "div", 8, 2);
      ɵɵlistener("cdkObserveContent", function MatTabHeader_Template_div_cdkObserveContent_5_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._onContentChanges());
      });
      ɵɵelementStart(7, "div", 9, 3);
      ɵɵprojection(9);
      ɵɵelementEnd();
      ɵɵelement(10, "mat-ink-bar");
      ɵɵelementEnd()();
      ɵɵelementStart(11, "button", 10, 4);
      ɵɵlistener("mousedown", function MatTabHeader_Template_button_mousedown_11_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._handlePaginatorPress("after", $event));
      })("click", function MatTabHeader_Template_button_click_11_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._handlePaginatorClick("after"));
      })("touchend", function MatTabHeader_Template_button_touchend_11_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._stopInterval());
      });
      ɵɵelement(13, "div", 6);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassProp("mat-tab-header-pagination-disabled", ctx._disableScrollBefore);
      ɵɵproperty("matRippleDisabled", ctx._disableScrollBefore || ctx.disableRipple)("disabled", ctx._disableScrollBefore || null);
      ɵɵadvance(5);
      ɵɵclassProp("_mat-animation-noopable", ctx._animationMode === "NoopAnimations");
      ɵɵadvance(6);
      ɵɵclassProp("mat-tab-header-pagination-disabled", ctx._disableScrollAfter);
      ɵɵproperty("matRippleDisabled", ctx._disableScrollAfter || ctx.disableRipple)("disabled", ctx._disableScrollAfter || null);
    }
  },
  dependencies: [MatRipple, CdkObserveContent, MatInkBar],
  styles: [".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none;box-sizing:content-box;background:none;border:none;outline:0;padding:0}.mat-tab-header-pagination::-moz-focus-inner{border:0}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-labels{display:flex}[mat-align-tabs=center]>.mat-tab-header .mat-tab-labels{justify-content:center}[mat-align-tabs=end]>.mat-tab-header .mat-tab-labels{justify-content:flex-end}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}._mat-animation-noopable.mat-tab-list{transition:none;animation:none}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{min-width:72px}}\n"],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTabHeader, [{
    type: Component,
    args: [{
      selector: "mat-tab-header",
      inputs: ["selectedIndex"],
      outputs: ["selectFocusedIndex", "indexFocused"],
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.Default,
      host: {
        "class": "mat-tab-header",
        "[class.mat-tab-header-pagination-controls-enabled]": "_showPaginationControls",
        "[class.mat-tab-header-rtl]": "_getLayoutDirection() == 'rtl'"
      },
      template: `<button class="mat-tab-header-pagination mat-tab-header-pagination-before mat-elevation-z4"
     #previousPaginator
     aria-hidden="true"
     type="button"
     mat-ripple
     tabindex="-1"
     [matRippleDisabled]="_disableScrollBefore || disableRipple"
     [class.mat-tab-header-pagination-disabled]="_disableScrollBefore"
     [disabled]="_disableScrollBefore || null"
     (click)="_handlePaginatorClick('before')"
     (mousedown)="_handlePaginatorPress('before', $event)"
     (touchend)="_stopInterval()">
  <div class="mat-tab-header-pagination-chevron"></div>
</button>

<div class="mat-tab-label-container" #tabListContainer (keydown)="_handleKeydown($event)">
  <div
    #tabList
    class="mat-tab-list"
    [class._mat-animation-noopable]="_animationMode === 'NoopAnimations'"
    role="tablist"
    (cdkObserveContent)="_onContentChanges()">
    <div class="mat-tab-labels" #tabListInner>
      <ng-content></ng-content>
    </div>
    <mat-ink-bar></mat-ink-bar>
  </div>
</div>

<button class="mat-tab-header-pagination mat-tab-header-pagination-after mat-elevation-z4"
     #nextPaginator
     aria-hidden="true"
     type="button"
     mat-ripple
     [matRippleDisabled]="_disableScrollAfter || disableRipple"
     [class.mat-tab-header-pagination-disabled]="_disableScrollAfter"
     [disabled]="_disableScrollAfter || null"
     tabindex="-1"
     (mousedown)="_handlePaginatorPress('after', $event)"
     (click)="_handlePaginatorClick('after')"
     (touchend)="_stopInterval()">
  <div class="mat-tab-header-pagination-chevron"></div>
</button>
`,
      styles: [".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none;box-sizing:content-box;background:none;border:none;outline:0;padding:0}.mat-tab-header-pagination::-moz-focus-inner{border:0}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-labels{display:flex}[mat-align-tabs=center]>.mat-tab-header .mat-tab-labels{justify-content:center}[mat-align-tabs=end]>.mat-tab-header .mat-tab-labels{justify-content:flex-end}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}._mat-animation-noopable.mat-tab-list{transition:none;animation:none}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{min-width:72px}}\n"]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewportRuler
    }, {
      type: Directionality,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgZone
    }, {
      type: Platform
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [ANIMATION_MODULE_TYPE]
      }]
    }];
  }, {
    _items: [{
      type: ContentChildren,
      args: [MatTabLabelWrapper, {
        descendants: false
      }]
    }],
    _inkBar: [{
      type: ViewChild,
      args: [MatInkBar, {
        static: true
      }]
    }],
    _tabListContainer: [{
      type: ViewChild,
      args: ["tabListContainer", {
        static: true
      }]
    }],
    _tabList: [{
      type: ViewChild,
      args: ["tabList", {
        static: true
      }]
    }],
    _tabListInner: [{
      type: ViewChild,
      args: ["tabListInner", {
        static: true
      }]
    }],
    _nextPaginator: [{
      type: ViewChild,
      args: ["nextPaginator"]
    }],
    _previousPaginator: [{
      type: ViewChild,
      args: ["previousPaginator"]
    }]
  });
})();
var nextId3 = 0;
var MatTabChangeEvent = class {
};
var _MatTabGroupMixinBase = mixinColor(mixinDisableRipple(class {
  constructor(_elementRef) {
    this._elementRef = _elementRef;
  }
}), "primary");
var _MatTabGroupBase = class extends _MatTabGroupMixinBase {
  constructor(elementRef, _changeDetectorRef, defaultConfig, _animationMode) {
    super(elementRef);
    this._changeDetectorRef = _changeDetectorRef;
    this._animationMode = _animationMode;
    this._tabs = new QueryList();
    this._indexToSelect = 0;
    this._lastFocusedTabIndex = null;
    this._tabBodyWrapperHeight = 0;
    this._tabsSubscription = Subscription.EMPTY;
    this._tabLabelSubscription = Subscription.EMPTY;
    this._selectedIndex = null;
    this.headerPosition = "above";
    this.selectedIndexChange = new EventEmitter();
    this.focusChange = new EventEmitter();
    this.animationDone = new EventEmitter();
    this.selectedTabChange = new EventEmitter(true);
    this._groupId = nextId3++;
    this.animationDuration = defaultConfig && defaultConfig.animationDuration ? defaultConfig.animationDuration : "500ms";
    this.disablePagination = defaultConfig && defaultConfig.disablePagination != null ? defaultConfig.disablePagination : false;
    this.dynamicHeight = defaultConfig && defaultConfig.dynamicHeight != null ? defaultConfig.dynamicHeight : false;
    this.contentTabIndex = defaultConfig?.contentTabIndex ?? null;
  }
  /** Whether the tab group should grow to the size of the active tab. */
  get dynamicHeight() {
    return this._dynamicHeight;
  }
  set dynamicHeight(value) {
    this._dynamicHeight = coerceBooleanProperty(value);
  }
  /** The index of the active tab. */
  get selectedIndex() {
    return this._selectedIndex;
  }
  set selectedIndex(value) {
    this._indexToSelect = coerceNumberProperty(value, null);
  }
  /** Duration for the tab animation. Will be normalized to milliseconds if no units are set. */
  get animationDuration() {
    return this._animationDuration;
  }
  set animationDuration(value) {
    this._animationDuration = /^\d+$/.test(value + "") ? value + "ms" : value;
  }
  /**
   * `tabindex` to be set on the inner element that wraps the tab content. Can be used for improved
   * accessibility when the tab does not have focusable elements or if it has scrollable content.
   * The `tabindex` will be removed automatically for inactive tabs.
   * Read more at https://www.w3.org/TR/wai-aria-practices/examples/tabs/tabs-2/tabs.html
   */
  get contentTabIndex() {
    return this._contentTabIndex;
  }
  set contentTabIndex(value) {
    this._contentTabIndex = coerceNumberProperty(value, null);
  }
  /** Background color of the tab group. */
  get backgroundColor() {
    return this._backgroundColor;
  }
  set backgroundColor(value) {
    const nativeElement = this._elementRef.nativeElement;
    nativeElement.classList.remove(`mat-background-${this.backgroundColor}`);
    if (value) {
      nativeElement.classList.add(`mat-background-${value}`);
    }
    this._backgroundColor = value;
  }
  /**
   * After the content is checked, this component knows what tabs have been defined
   * and what the selected index should be. This is where we can know exactly what position
   * each tab should be in according to the new selected index, and additionally we know how
   * a new selected tab should transition in (from the left or right).
   */
  ngAfterContentChecked() {
    const indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);
    if (this._selectedIndex != indexToSelect) {
      const isFirstRun = this._selectedIndex == null;
      if (!isFirstRun) {
        this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));
        const wrapper = this._tabBodyWrapper.nativeElement;
        wrapper.style.minHeight = wrapper.clientHeight + "px";
      }
      Promise.resolve().then(() => {
        this._tabs.forEach((tab, index) => tab.isActive = index === indexToSelect);
        if (!isFirstRun) {
          this.selectedIndexChange.emit(indexToSelect);
          this._tabBodyWrapper.nativeElement.style.minHeight = "";
        }
      });
    }
    this._tabs.forEach((tab, index) => {
      tab.position = index - indexToSelect;
      if (this._selectedIndex != null && tab.position == 0 && !tab.origin) {
        tab.origin = indexToSelect - this._selectedIndex;
      }
    });
    if (this._selectedIndex !== indexToSelect) {
      this._selectedIndex = indexToSelect;
      this._lastFocusedTabIndex = null;
      this._changeDetectorRef.markForCheck();
    }
  }
  ngAfterContentInit() {
    this._subscribeToAllTabChanges();
    this._subscribeToTabLabels();
    this._tabsSubscription = this._tabs.changes.subscribe(() => {
      const indexToSelect = this._clampTabIndex(this._indexToSelect);
      if (indexToSelect === this._selectedIndex) {
        const tabs = this._tabs.toArray();
        let selectedTab;
        for (let i = 0; i < tabs.length; i++) {
          if (tabs[i].isActive) {
            this._indexToSelect = this._selectedIndex = i;
            this._lastFocusedTabIndex = null;
            selectedTab = tabs[i];
            break;
          }
        }
        if (!selectedTab && tabs[indexToSelect]) {
          Promise.resolve().then(() => {
            tabs[indexToSelect].isActive = true;
            this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));
          });
        }
      }
      this._changeDetectorRef.markForCheck();
    });
  }
  /** Listens to changes in all of the tabs. */
  _subscribeToAllTabChanges() {
    this._allTabs.changes.pipe(startWith(this._allTabs)).subscribe((tabs) => {
      this._tabs.reset(tabs.filter((tab) => {
        return tab._closestTabGroup === this || !tab._closestTabGroup;
      }));
      this._tabs.notifyOnChanges();
    });
  }
  ngOnDestroy() {
    this._tabs.destroy();
    this._tabsSubscription.unsubscribe();
    this._tabLabelSubscription.unsubscribe();
  }
  /** Re-aligns the ink bar to the selected tab element. */
  realignInkBar() {
    if (this._tabHeader) {
      this._tabHeader._alignInkBarToSelectedTab();
    }
  }
  /**
   * Recalculates the tab group's pagination dimensions.
   *
   * WARNING: Calling this method can be very costly in terms of performance. It should be called
   * as infrequently as possible from outside of the Tabs component as it causes a reflow of the
   * page.
   */
  updatePagination() {
    if (this._tabHeader) {
      this._tabHeader.updatePagination();
    }
  }
  /**
   * Sets focus to a particular tab.
   * @param index Index of the tab to be focused.
   */
  focusTab(index) {
    const header = this._tabHeader;
    if (header) {
      header.focusIndex = index;
    }
  }
  _focusChanged(index) {
    this._lastFocusedTabIndex = index;
    this.focusChange.emit(this._createChangeEvent(index));
  }
  _createChangeEvent(index) {
    const event = new MatTabChangeEvent();
    event.index = index;
    if (this._tabs && this._tabs.length) {
      event.tab = this._tabs.toArray()[index];
    }
    return event;
  }
  /**
   * Subscribes to changes in the tab labels. This is needed, because the @Input for the label is
   * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the
   * binding to be updated, we need to subscribe to changes in it and trigger change detection
   * manually.
   */
  _subscribeToTabLabels() {
    if (this._tabLabelSubscription) {
      this._tabLabelSubscription.unsubscribe();
    }
    this._tabLabelSubscription = merge(...this._tabs.map((tab) => tab._stateChanges)).subscribe(() => this._changeDetectorRef.markForCheck());
  }
  /** Clamps the given index to the bounds of 0 and the tabs length. */
  _clampTabIndex(index) {
    return Math.min(this._tabs.length - 1, Math.max(index || 0, 0));
  }
  /** Returns a unique id for each tab label element */
  _getTabLabelId(i) {
    return `mat-tab-label-${this._groupId}-${i}`;
  }
  /** Returns a unique id for each tab content element */
  _getTabContentId(i) {
    return `mat-tab-content-${this._groupId}-${i}`;
  }
  /**
   * Sets the height of the body wrapper to the height of the activating tab if dynamic
   * height property is true.
   */
  _setTabBodyWrapperHeight(tabHeight) {
    if (!this._dynamicHeight || !this._tabBodyWrapperHeight) {
      return;
    }
    const wrapper = this._tabBodyWrapper.nativeElement;
    wrapper.style.height = this._tabBodyWrapperHeight + "px";
    if (this._tabBodyWrapper.nativeElement.offsetHeight) {
      wrapper.style.height = tabHeight + "px";
    }
  }
  /** Removes the height of the tab body wrapper. */
  _removeTabBodyWrapperHeight() {
    const wrapper = this._tabBodyWrapper.nativeElement;
    this._tabBodyWrapperHeight = wrapper.clientHeight;
    wrapper.style.height = "";
    this.animationDone.emit();
  }
  /** Handle click events, setting new selected index if appropriate. */
  _handleClick(tab, tabHeader, index) {
    if (!tab.disabled) {
      this.selectedIndex = tabHeader.focusIndex = index;
    }
  }
  /** Retrieves the tabindex for the tab. */
  _getTabIndex(tab, index) {
    if (tab.disabled) {
      return null;
    }
    const targetIndex = this._lastFocusedTabIndex ?? this.selectedIndex;
    return index === targetIndex ? 0 : -1;
  }
  /** Callback for when the focused state of a tab has changed. */
  _tabFocusChanged(focusOrigin, index) {
    if (focusOrigin && focusOrigin !== "mouse" && focusOrigin !== "touch") {
      this._tabHeader.focusIndex = index;
    }
  }
};
_MatTabGroupBase.ɵfac = function _MatTabGroupBase_Factory(ɵt) {
  return new (ɵt || _MatTabGroupBase)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(MAT_TABS_CONFIG, 8), ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8));
};
_MatTabGroupBase.ɵdir = ɵɵdefineDirective({
  type: _MatTabGroupBase,
  inputs: {
    dynamicHeight: "dynamicHeight",
    selectedIndex: "selectedIndex",
    headerPosition: "headerPosition",
    animationDuration: "animationDuration",
    contentTabIndex: "contentTabIndex",
    disablePagination: "disablePagination",
    backgroundColor: "backgroundColor"
  },
  outputs: {
    selectedIndexChange: "selectedIndexChange",
    focusChange: "focusChange",
    animationDone: "animationDone",
    selectedTabChange: "selectedTabChange"
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_MatTabGroupBase, [{
    type: Directive
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [MAT_TABS_CONFIG]
      }, {
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [ANIMATION_MODULE_TYPE]
      }]
    }];
  }, {
    dynamicHeight: [{
      type: Input
    }],
    selectedIndex: [{
      type: Input
    }],
    headerPosition: [{
      type: Input
    }],
    animationDuration: [{
      type: Input
    }],
    contentTabIndex: [{
      type: Input
    }],
    disablePagination: [{
      type: Input
    }],
    backgroundColor: [{
      type: Input
    }],
    selectedIndexChange: [{
      type: Output
    }],
    focusChange: [{
      type: Output
    }],
    animationDone: [{
      type: Output
    }],
    selectedTabChange: [{
      type: Output
    }]
  });
})();
var MatTabGroup = class extends _MatTabGroupBase {
  constructor(elementRef, changeDetectorRef, defaultConfig, animationMode) {
    super(elementRef, changeDetectorRef, defaultConfig, animationMode);
  }
};
MatTabGroup.ɵfac = function MatTabGroup_Factory(ɵt) {
  return new (ɵt || MatTabGroup)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(MAT_TABS_CONFIG, 8), ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8));
};
MatTabGroup.ɵcmp = ɵɵdefineComponent({
  type: MatTabGroup,
  selectors: [["mat-tab-group"]],
  contentQueries: function MatTabGroup_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, MatTab, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._allTabs = _t);
    }
  },
  viewQuery: function MatTabGroup_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(_c8, 5);
      ɵɵviewQuery(_c9, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._tabBodyWrapper = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._tabHeader = _t.first);
    }
  },
  hostAttrs: [1, "mat-tab-group"],
  hostVars: 4,
  hostBindings: function MatTabGroup_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵclassProp("mat-tab-group-dynamic-height", ctx.dynamicHeight)("mat-tab-group-inverted-header", ctx.headerPosition === "below");
    }
  },
  inputs: {
    color: "color",
    disableRipple: "disableRipple"
  },
  exportAs: ["matTabGroup"],
  features: [ɵɵProvidersFeature([{
    provide: MAT_TAB_GROUP,
    useExisting: MatTabGroup
  }]), ɵɵInheritDefinitionFeature],
  decls: 6,
  vars: 7,
  consts: [["tabHeader", ""], ["tabBodyWrapper", ""], ["tabTextLabel", ""], [3, "indexFocused", "selectFocusedIndex", "selectedIndex", "disableRipple", "disablePagination"], ["class", "mat-tab-label mat-focus-indicator", "role", "tab", "matTabLabelWrapper", "", "mat-ripple", "", "cdkMonitorElementFocus", "", 3, "id", "mat-tab-label-active", "ngClass", "disabled", "matRippleDisabled", "click", "cdkFocusChange", 4, "ngFor", "ngForOf"], [1, "mat-tab-body-wrapper"], ["role", "tabpanel", 3, "id", "mat-tab-body-active", "ngClass", "content", "position", "origin", "animationDuration", "_onCentered", "_onCentering", 4, "ngFor", "ngForOf"], ["role", "tab", "matTabLabelWrapper", "", "mat-ripple", "", "cdkMonitorElementFocus", "", 1, "mat-tab-label", "mat-focus-indicator", 3, "click", "cdkFocusChange", "id", "ngClass", "disabled", "matRippleDisabled"], [1, "mat-tab-label-content"], [3, "ngIf", "ngIfElse"], [3, "cdkPortalOutlet"], ["role", "tabpanel", 3, "_onCentered", "_onCentering", "id", "ngClass", "content", "position", "origin", "animationDuration"]],
  template: function MatTabGroup_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "mat-tab-header", 3, 0);
      ɵɵlistener("indexFocused", function MatTabGroup_Template_mat_tab_header_indexFocused_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._focusChanged($event));
      })("selectFocusedIndex", function MatTabGroup_Template_mat_tab_header_selectFocusedIndex_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.selectedIndex = $event);
      });
      ɵɵtemplate(2, MatTabGroup_div_2_Template, 5, 15, "div", 4);
      ɵɵelementEnd();
      ɵɵelementStart(3, "div", 5, 1);
      ɵɵtemplate(5, MatTabGroup_mat_tab_body_5_Template, 1, 10, "mat-tab-body", 6);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵproperty("selectedIndex", ctx.selectedIndex || 0)("disableRipple", ctx.disableRipple)("disablePagination", ctx.disablePagination);
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx._tabs);
      ɵɵadvance();
      ɵɵclassProp("_mat-animation-noopable", ctx._animationMode === "NoopAnimations");
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx._tabs);
    }
  },
  dependencies: [MatTabHeader, MatTabBody, NgForOf, MatTabLabelWrapper, MatRipple, CdkMonitorFocus, NgClass, NgIf, CdkPortalOutlet],
  styles: [".mat-tab-group{display:flex;flex-direction:column;max-width:100%}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{padding:0 12px}}@media(max-width: 959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height 500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-tab-body-wrapper{transition:none;animation:none}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;outline:0;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\n"],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTabGroup, [{
    type: Component,
    args: [{
      selector: "mat-tab-group",
      exportAs: "matTabGroup",
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.Default,
      inputs: ["color", "disableRipple"],
      providers: [{
        provide: MAT_TAB_GROUP,
        useExisting: MatTabGroup
      }],
      host: {
        "class": "mat-tab-group",
        "[class.mat-tab-group-dynamic-height]": "dynamicHeight",
        "[class.mat-tab-group-inverted-header]": 'headerPosition === "below"'
      },
      template: `<mat-tab-header #tabHeader
               [selectedIndex]="selectedIndex || 0"
               [disableRipple]="disableRipple"
               [disablePagination]="disablePagination"
               (indexFocused)="_focusChanged($event)"
               (selectFocusedIndex)="selectedIndex = $event">
  <div class="mat-tab-label mat-focus-indicator" role="tab" matTabLabelWrapper mat-ripple
       cdkMonitorElementFocus
       *ngFor="let tab of _tabs; let i = index"
       [id]="_getTabLabelId(i)"
       [attr.tabIndex]="_getTabIndex(tab, i)"
       [attr.aria-posinset]="i + 1"
       [attr.aria-setsize]="_tabs.length"
       [attr.aria-controls]="_getTabContentId(i)"
       [attr.aria-selected]="selectedIndex === i"
       [attr.aria-label]="tab.ariaLabel || null"
       [attr.aria-labelledby]="(!tab.ariaLabel && tab.ariaLabelledby) ? tab.ariaLabelledby : null"
       [class.mat-tab-label-active]="selectedIndex === i"
       [ngClass]="tab.labelClass"
       [disabled]="tab.disabled"
       [matRippleDisabled]="tab.disabled || disableRipple"
       (click)="_handleClick(tab, tabHeader, i)"
       (cdkFocusChange)="_tabFocusChanged($event, i)">


    <div class="mat-tab-label-content">
      <!-- If there is a label template, use it. -->
      <ng-template [ngIf]="tab.templateLabel" [ngIfElse]="tabTextLabel">
        <ng-template [cdkPortalOutlet]="tab.templateLabel"></ng-template>
      </ng-template>

      <!-- If there is not a label template, fall back to the text label. -->
      <ng-template #tabTextLabel>{{tab.textLabel}}</ng-template>
    </div>
  </div>
</mat-tab-header>

<div
  class="mat-tab-body-wrapper"
  [class._mat-animation-noopable]="_animationMode === 'NoopAnimations'"
  #tabBodyWrapper>
  <mat-tab-body role="tabpanel"
               *ngFor="let tab of _tabs; let i = index"
               [id]="_getTabContentId(i)"
               [attr.tabindex]="(contentTabIndex != null && selectedIndex === i) ? contentTabIndex : null"
               [attr.aria-labelledby]="_getTabLabelId(i)"
               [class.mat-tab-body-active]="selectedIndex === i"
               [ngClass]="tab.bodyClass"
               [content]="tab.content!"
               [position]="tab.position!"
               [origin]="tab.origin"
               [animationDuration]="animationDuration"
               (_onCentered)="_removeTabBodyWrapperHeight()"
               (_onCentering)="_setTabBodyWrapperHeight($event)">
  </mat-tab-body>
</div>
`,
      styles: [".mat-tab-group{display:flex;flex-direction:column;max-width:100%}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{padding:0 12px}}@media(max-width: 959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height 500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-tab-body-wrapper{transition:none;animation:none}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;outline:0;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\n"]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: ChangeDetectorRef
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [MAT_TABS_CONFIG]
      }, {
        type: Optional
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [ANIMATION_MODULE_TYPE]
      }]
    }];
  }, {
    _allTabs: [{
      type: ContentChildren,
      args: [MatTab, {
        descendants: true
      }]
    }],
    _tabBodyWrapper: [{
      type: ViewChild,
      args: ["tabBodyWrapper"]
    }],
    _tabHeader: [{
      type: ViewChild,
      args: ["tabHeader"]
    }]
  });
})();
var nextUniqueId3 = 0;
var _MatTabNavBase = class extends MatPaginatedTabHeader {
  constructor(elementRef, dir, ngZone, changeDetectorRef, viewportRuler, platform, animationMode) {
    super(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode);
    this._disableRipple = false;
    this.color = "primary";
  }
  /** Background color of the tab nav. */
  get backgroundColor() {
    return this._backgroundColor;
  }
  set backgroundColor(value) {
    const classList = this._elementRef.nativeElement.classList;
    classList.remove(`mat-background-${this.backgroundColor}`);
    if (value) {
      classList.add(`mat-background-${value}`);
    }
    this._backgroundColor = value;
  }
  /** Whether the ripple effect is disabled or not. */
  get disableRipple() {
    return this._disableRipple;
  }
  set disableRipple(value) {
    this._disableRipple = coerceBooleanProperty(value);
  }
  _itemSelected() {
  }
  ngAfterContentInit() {
    this._items.changes.pipe(startWith(null), takeUntil(this._destroyed)).subscribe(() => {
      this.updateActiveLink();
    });
    super.ngAfterContentInit();
  }
  /** Notifies the component that the active link has been changed. */
  updateActiveLink() {
    if (!this._items) {
      return;
    }
    const items = this._items.toArray();
    for (let i = 0; i < items.length; i++) {
      if (items[i].active) {
        this.selectedIndex = i;
        this._changeDetectorRef.markForCheck();
        if (this.tabPanel) {
          this.tabPanel._activeTabId = items[i].id;
        }
        return;
      }
    }
    this.selectedIndex = -1;
    this._inkBar.hide();
  }
  _getRole() {
    return this.tabPanel ? "tablist" : this._elementRef.nativeElement.getAttribute("role");
  }
};
_MatTabNavBase.ɵfac = function _MatTabNavBase_Factory(ɵt) {
  return new (ɵt || _MatTabNavBase)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewportRuler), ɵɵdirectiveInject(Platform), ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8));
};
_MatTabNavBase.ɵdir = ɵɵdefineDirective({
  type: _MatTabNavBase,
  inputs: {
    backgroundColor: "backgroundColor",
    disableRipple: "disableRipple",
    color: "color",
    tabPanel: "tabPanel"
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_MatTabNavBase, [{
    type: Directive
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Directionality,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewportRuler
    }, {
      type: Platform
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [ANIMATION_MODULE_TYPE]
      }]
    }];
  }, {
    backgroundColor: [{
      type: Input
    }],
    disableRipple: [{
      type: Input
    }],
    color: [{
      type: Input
    }],
    tabPanel: [{
      type: Input
    }]
  });
})();
var MatTabNav = class extends _MatTabNavBase {
  constructor(elementRef, dir, ngZone, changeDetectorRef, viewportRuler, platform, animationMode) {
    super(elementRef, dir, ngZone, changeDetectorRef, viewportRuler, platform, animationMode);
  }
};
MatTabNav.ɵfac = function MatTabNav_Factory(ɵt) {
  return new (ɵt || MatTabNav)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(Directionality, 8), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(ViewportRuler), ɵɵdirectiveInject(Platform), ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8));
};
MatTabNav.ɵcmp = ɵɵdefineComponent({
  type: MatTabNav,
  selectors: [["", "mat-tab-nav-bar", ""]],
  contentQueries: function MatTabNav_ContentQueries(rf, ctx, dirIndex) {
    if (rf & 1) {
      ɵɵcontentQuery(dirIndex, MatTabLink, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._items = _t);
    }
  },
  viewQuery: function MatTabNav_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(MatInkBar, 7);
      ɵɵviewQuery(_c34, 7);
      ɵɵviewQuery(_c43, 7);
      ɵɵviewQuery(_c5, 7);
      ɵɵviewQuery(_c6, 5);
      ɵɵviewQuery(_c7, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._inkBar = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._tabListContainer = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._tabList = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._tabListInner = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._nextPaginator = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._previousPaginator = _t.first);
    }
  },
  hostAttrs: [1, "mat-tab-nav-bar", "mat-tab-header"],
  hostVars: 11,
  hostBindings: function MatTabNav_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("role", ctx._getRole());
      ɵɵclassProp("mat-tab-header-pagination-controls-enabled", ctx._showPaginationControls)("mat-tab-header-rtl", ctx._getLayoutDirection() == "rtl")("mat-primary", ctx.color !== "warn" && ctx.color !== "accent")("mat-accent", ctx.color === "accent")("mat-warn", ctx.color === "warn");
    }
  },
  inputs: {
    color: "color"
  },
  exportAs: ["matTabNavBar", "matTabNav"],
  features: [ɵɵInheritDefinitionFeature],
  attrs: _c10,
  ngContentSelectors: _c010,
  decls: 14,
  vars: 10,
  consts: [["previousPaginator", ""], ["tabListContainer", ""], ["tabList", ""], ["tabListInner", ""], ["nextPaginator", ""], ["aria-hidden", "true", "type", "button", "mat-ripple", "", "tabindex", "-1", 1, "mat-tab-header-pagination", "mat-tab-header-pagination-before", "mat-elevation-z4", 3, "click", "mousedown", "touchend", "matRippleDisabled", "disabled"], [1, "mat-tab-header-pagination-chevron"], [1, "mat-tab-link-container", 3, "keydown"], [1, "mat-tab-list", 3, "cdkObserveContent"], [1, "mat-tab-links"], ["aria-hidden", "true", "type", "button", "mat-ripple", "", "tabindex", "-1", 1, "mat-tab-header-pagination", "mat-tab-header-pagination-after", "mat-elevation-z4", 3, "mousedown", "click", "touchend", "matRippleDisabled", "disabled"]],
  template: function MatTabNav_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵprojectionDef();
      ɵɵelementStart(0, "button", 5, 0);
      ɵɵlistener("click", function MatTabNav_Template_button_click_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._handlePaginatorClick("before"));
      })("mousedown", function MatTabNav_Template_button_mousedown_0_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._handlePaginatorPress("before", $event));
      })("touchend", function MatTabNav_Template_button_touchend_0_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._stopInterval());
      });
      ɵɵelement(2, "div", 6);
      ɵɵelementEnd();
      ɵɵelementStart(3, "div", 7, 1);
      ɵɵlistener("keydown", function MatTabNav_Template_div_keydown_3_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._handleKeydown($event));
      });
      ɵɵelementStart(5, "div", 8, 2);
      ɵɵlistener("cdkObserveContent", function MatTabNav_Template_div_cdkObserveContent_5_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._onContentChanges());
      });
      ɵɵelementStart(7, "div", 9, 3);
      ɵɵprojection(9);
      ɵɵelementEnd();
      ɵɵelement(10, "mat-ink-bar");
      ɵɵelementEnd()();
      ɵɵelementStart(11, "button", 10, 4);
      ɵɵlistener("mousedown", function MatTabNav_Template_button_mousedown_11_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._handlePaginatorPress("after", $event));
      })("click", function MatTabNav_Template_button_click_11_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._handlePaginatorClick("after"));
      })("touchend", function MatTabNav_Template_button_touchend_11_listener() {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx._stopInterval());
      });
      ɵɵelement(13, "div", 6);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵclassProp("mat-tab-header-pagination-disabled", ctx._disableScrollBefore);
      ɵɵproperty("matRippleDisabled", ctx._disableScrollBefore || ctx.disableRipple)("disabled", ctx._disableScrollBefore || null);
      ɵɵadvance(5);
      ɵɵclassProp("_mat-animation-noopable", ctx._animationMode === "NoopAnimations");
      ɵɵadvance(6);
      ɵɵclassProp("mat-tab-header-pagination-disabled", ctx._disableScrollAfter);
      ɵɵproperty("matRippleDisabled", ctx._disableScrollAfter || ctx.disableRipple)("disabled", ctx._disableScrollAfter || null);
    }
  },
  dependencies: [MatRipple, CdkObserveContent, MatInkBar],
  styles: [".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none;box-sizing:content-box;background:none;border:none;outline:0;padding:0}.mat-tab-header-pagination::-moz-focus-inner{border:0}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-tab-links{display:flex}[mat-align-tabs=center]>.mat-tab-link-container .mat-tab-links{justify-content:center}[mat-align-tabs=end]>.mat-tab-link-container .mat-tab-links{justify-content:flex-end}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-link-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:none}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-link:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-link.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-link.mat-tab-disabled{opacity:.5}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-link{opacity:1}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media(max-width: 599px){.mat-tab-link{min-width:72px}}\n"],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTabNav, [{
    type: Component,
    args: [{
      selector: "[mat-tab-nav-bar]",
      exportAs: "matTabNavBar, matTabNav",
      inputs: ["color"],
      host: {
        "[attr.role]": "_getRole()",
        "class": "mat-tab-nav-bar mat-tab-header",
        "[class.mat-tab-header-pagination-controls-enabled]": "_showPaginationControls",
        "[class.mat-tab-header-rtl]": "_getLayoutDirection() == 'rtl'",
        "[class.mat-primary]": 'color !== "warn" && color !== "accent"',
        "[class.mat-accent]": 'color === "accent"',
        "[class.mat-warn]": 'color === "warn"'
      },
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.Default,
      template: `<button class="mat-tab-header-pagination mat-tab-header-pagination-before mat-elevation-z4"
     #previousPaginator
     aria-hidden="true"
     type="button"
     mat-ripple
     tabindex="-1"
     [matRippleDisabled]="_disableScrollBefore || disableRipple"
     [class.mat-tab-header-pagination-disabled]="_disableScrollBefore"
     [disabled]="_disableScrollBefore || null"
     (click)="_handlePaginatorClick('before')"
     (mousedown)="_handlePaginatorPress('before', $event)"
     (touchend)="_stopInterval()">
  <div class="mat-tab-header-pagination-chevron"></div>
</button>

<div class="mat-tab-link-container" #tabListContainer (keydown)="_handleKeydown($event)">
  <div
    class="mat-tab-list"
    [class._mat-animation-noopable]="_animationMode === 'NoopAnimations'"
    #tabList
    (cdkObserveContent)="_onContentChanges()">
    <div class="mat-tab-links" #tabListInner>
      <ng-content></ng-content>
    </div>
    <mat-ink-bar></mat-ink-bar>
  </div>
</div>

<button class="mat-tab-header-pagination mat-tab-header-pagination-after mat-elevation-z4"
     #nextPaginator
     aria-hidden="true"
     type="button"
     mat-ripple
     [matRippleDisabled]="_disableScrollAfter || disableRipple"
     [class.mat-tab-header-pagination-disabled]="_disableScrollAfter"
     [disabled]="_disableScrollAfter || null"
     tabindex="-1"
     (mousedown)="_handlePaginatorPress('after', $event)"
     (click)="_handlePaginatorClick('after')"
     (touchend)="_stopInterval()">
  <div class="mat-tab-header-pagination-chevron"></div>
</button>
`,
      styles: [".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none;box-sizing:content-box;background:none;border:none;outline:0;padding:0}.mat-tab-header-pagination::-moz-focus-inner{border:0}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-tab-links{display:flex}[mat-align-tabs=center]>.mat-tab-link-container .mat-tab-links{justify-content:center}[mat-align-tabs=end]>.mat-tab-link-container .mat-tab-links{justify-content:flex-end}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-link-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:none}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-link:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-link.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-link.mat-tab-disabled{opacity:.5}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-link{opacity:1}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media(max-width: 599px){.mat-tab-link{min-width:72px}}\n"]
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: Directionality,
      decorators: [{
        type: Optional
      }]
    }, {
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }, {
      type: ViewportRuler
    }, {
      type: Platform
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [ANIMATION_MODULE_TYPE]
      }]
    }];
  }, {
    _items: [{
      type: ContentChildren,
      args: [forwardRef(() => MatTabLink), {
        descendants: true
      }]
    }],
    _inkBar: [{
      type: ViewChild,
      args: [MatInkBar, {
        static: true
      }]
    }],
    _tabListContainer: [{
      type: ViewChild,
      args: ["tabListContainer", {
        static: true
      }]
    }],
    _tabList: [{
      type: ViewChild,
      args: ["tabList", {
        static: true
      }]
    }],
    _tabListInner: [{
      type: ViewChild,
      args: ["tabListInner", {
        static: true
      }]
    }],
    _nextPaginator: [{
      type: ViewChild,
      args: ["nextPaginator"]
    }],
    _previousPaginator: [{
      type: ViewChild,
      args: ["previousPaginator"]
    }]
  });
})();
var _MatTabLinkMixinBase = mixinTabIndex(mixinDisableRipple(mixinDisabled(class {
})));
var _MatTabLinkBase = class extends _MatTabLinkMixinBase {
  constructor(_tabNavBar, elementRef, globalRippleOptions, tabIndex, _focusMonitor, animationMode) {
    super();
    this._tabNavBar = _tabNavBar;
    this.elementRef = elementRef;
    this._focusMonitor = _focusMonitor;
    this._isActive = false;
    this.id = `mat-tab-link-${nextUniqueId3++}`;
    this.rippleConfig = globalRippleOptions || {};
    this.tabIndex = parseInt(tabIndex) || 0;
    if (animationMode === "NoopAnimations") {
      this.rippleConfig.animation = {
        enterDuration: 0,
        exitDuration: 0
      };
    }
  }
  /** Whether the link is active. */
  get active() {
    return this._isActive;
  }
  set active(value) {
    const newValue = coerceBooleanProperty(value);
    if (newValue !== this._isActive) {
      this._isActive = newValue;
      this._tabNavBar.updateActiveLink();
    }
  }
  /**
   * Whether ripples are disabled on interaction.
   * @docs-private
   */
  get rippleDisabled() {
    return this.disabled || this.disableRipple || this._tabNavBar.disableRipple || !!this.rippleConfig.disabled;
  }
  /** Focuses the tab link. */
  focus() {
    this.elementRef.nativeElement.focus();
  }
  ngAfterViewInit() {
    this._focusMonitor.monitor(this.elementRef);
  }
  ngOnDestroy() {
    this._focusMonitor.stopMonitoring(this.elementRef);
  }
  _handleFocus() {
    this._tabNavBar.focusIndex = this._tabNavBar._items.toArray().indexOf(this);
  }
  _handleKeydown(event) {
    if (this._tabNavBar.tabPanel && event.keyCode === SPACE) {
      this.elementRef.nativeElement.click();
    }
  }
  _getAriaControls() {
    return this._tabNavBar.tabPanel ? this._tabNavBar.tabPanel?.id : this.elementRef.nativeElement.getAttribute("aria-controls");
  }
  _getAriaSelected() {
    if (this._tabNavBar.tabPanel) {
      return this.active ? "true" : "false";
    } else {
      return this.elementRef.nativeElement.getAttribute("aria-selected");
    }
  }
  _getAriaCurrent() {
    return this.active && !this._tabNavBar.tabPanel ? "page" : null;
  }
  _getRole() {
    return this._tabNavBar.tabPanel ? "tab" : this.elementRef.nativeElement.getAttribute("role");
  }
  _getTabIndex() {
    if (this._tabNavBar.tabPanel) {
      return this._isActive ? 0 : -1;
    } else {
      return this.tabIndex;
    }
  }
};
_MatTabLinkBase.ɵfac = function _MatTabLinkBase_Factory(ɵt) {
  return new (ɵt || _MatTabLinkBase)(ɵɵdirectiveInject(_MatTabNavBase), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(MAT_RIPPLE_GLOBAL_OPTIONS, 8), ɵɵinjectAttribute("tabindex"), ɵɵdirectiveInject(FocusMonitor), ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8));
};
_MatTabLinkBase.ɵdir = ɵɵdefineDirective({
  type: _MatTabLinkBase,
  inputs: {
    active: "active",
    id: "id"
  },
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_MatTabLinkBase, [{
    type: Directive
  }], function() {
    return [{
      type: _MatTabNavBase
    }, {
      type: ElementRef
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [MAT_RIPPLE_GLOBAL_OPTIONS]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Attribute,
        args: ["tabindex"]
      }]
    }, {
      type: FocusMonitor
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [ANIMATION_MODULE_TYPE]
      }]
    }];
  }, {
    active: [{
      type: Input
    }],
    id: [{
      type: Input
    }]
  });
})();
var MatTabLink = class extends _MatTabLinkBase {
  constructor(tabNavBar, elementRef, ngZone, platform, globalRippleOptions, tabIndex, focusMonitor, animationMode) {
    super(tabNavBar, elementRef, globalRippleOptions, tabIndex, focusMonitor, animationMode);
    this._tabLinkRipple = new RippleRenderer(this, ngZone, elementRef, platform);
    this._tabLinkRipple.setupTriggerEvents(elementRef.nativeElement);
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this._tabLinkRipple._removeTriggerEvents();
  }
};
MatTabLink.ɵfac = function MatTabLink_Factory(ɵt) {
  return new (ɵt || MatTabLink)(ɵɵdirectiveInject(MatTabNav), ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(NgZone), ɵɵdirectiveInject(Platform), ɵɵdirectiveInject(MAT_RIPPLE_GLOBAL_OPTIONS, 8), ɵɵinjectAttribute("tabindex"), ɵɵdirectiveInject(FocusMonitor), ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8));
};
MatTabLink.ɵdir = ɵɵdefineDirective({
  type: MatTabLink,
  selectors: [["", "mat-tab-link", ""], ["", "matTabLink", ""]],
  hostAttrs: [1, "mat-tab-link", "mat-focus-indicator"],
  hostVars: 11,
  hostBindings: function MatTabLink_HostBindings(rf, ctx) {
    if (rf & 1) {
      ɵɵlistener("focus", function MatTabLink_focus_HostBindingHandler() {
        return ctx._handleFocus();
      })("keydown", function MatTabLink_keydown_HostBindingHandler($event) {
        return ctx._handleKeydown($event);
      });
    }
    if (rf & 2) {
      ɵɵattribute("aria-controls", ctx._getAriaControls())("aria-current", ctx._getAriaCurrent())("aria-disabled", ctx.disabled)("aria-selected", ctx._getAriaSelected())("id", ctx.id)("tabIndex", ctx._getTabIndex())("role", ctx._getRole());
      ɵɵclassProp("mat-tab-disabled", ctx.disabled)("mat-tab-label-active", ctx.active);
    }
  },
  inputs: {
    disabled: "disabled",
    disableRipple: "disableRipple",
    tabIndex: "tabIndex"
  },
  exportAs: ["matTabLink"],
  features: [ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTabLink, [{
    type: Directive,
    args: [{
      selector: "[mat-tab-link], [matTabLink]",
      exportAs: "matTabLink",
      inputs: ["disabled", "disableRipple", "tabIndex"],
      host: {
        "class": "mat-tab-link mat-focus-indicator",
        "[attr.aria-controls]": "_getAriaControls()",
        "[attr.aria-current]": "_getAriaCurrent()",
        "[attr.aria-disabled]": "disabled",
        "[attr.aria-selected]": "_getAriaSelected()",
        "[attr.id]": "id",
        "[attr.tabIndex]": "_getTabIndex()",
        "[attr.role]": "_getRole()",
        "[class.mat-tab-disabled]": "disabled",
        "[class.mat-tab-label-active]": "active",
        "(focus)": "_handleFocus()",
        "(keydown)": "_handleKeydown($event)"
      }
    }]
  }], function() {
    return [{
      type: MatTabNav
    }, {
      type: ElementRef
    }, {
      type: NgZone
    }, {
      type: Platform
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [MAT_RIPPLE_GLOBAL_OPTIONS]
      }]
    }, {
      type: void 0,
      decorators: [{
        type: Attribute,
        args: ["tabindex"]
      }]
    }, {
      type: FocusMonitor
    }, {
      type: void 0,
      decorators: [{
        type: Optional
      }, {
        type: Inject,
        args: [ANIMATION_MODULE_TYPE]
      }]
    }];
  }, null);
})();
var MatTabNavPanel = class {
  constructor() {
    this.id = `mat-tab-nav-panel-${nextUniqueId3++}`;
  }
};
MatTabNavPanel.ɵfac = function MatTabNavPanel_Factory(ɵt) {
  return new (ɵt || MatTabNavPanel)();
};
MatTabNavPanel.ɵcmp = ɵɵdefineComponent({
  type: MatTabNavPanel,
  selectors: [["mat-tab-nav-panel"]],
  hostAttrs: ["role", "tabpanel", 1, "mat-tab-nav-panel"],
  hostVars: 2,
  hostBindings: function MatTabNavPanel_HostBindings(rf, ctx) {
    if (rf & 2) {
      ɵɵattribute("aria-labelledby", ctx._activeTabId)("id", ctx.id);
    }
  },
  inputs: {
    id: "id"
  },
  exportAs: ["matTabNavPanel"],
  ngContentSelectors: _c010,
  decls: 1,
  vars: 0,
  template: function MatTabNavPanel_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵprojectionDef();
      ɵɵprojection(0);
    }
  },
  encapsulation: 2,
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTabNavPanel, [{
    type: Component,
    args: [{
      selector: "mat-tab-nav-panel",
      exportAs: "matTabNavPanel",
      template: "<ng-content></ng-content>",
      host: {
        "[attr.aria-labelledby]": "_activeTabId",
        "[attr.id]": "id",
        "class": "mat-tab-nav-panel",
        "role": "tabpanel"
      },
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    id: [{
      type: Input
    }]
  });
})();
var MatTabsModule = class {
};
MatTabsModule.ɵfac = function MatTabsModule_Factory(ɵt) {
  return new (ɵt || MatTabsModule)();
};
MatTabsModule.ɵmod = ɵɵdefineNgModule({
  type: MatTabsModule,
  declarations: [MatTabGroup, MatTabLabel, MatTab, MatInkBar, MatTabLabelWrapper, MatTabNav, MatTabNavPanel, MatTabLink, MatTabBody, MatTabBodyPortal, MatTabHeader, MatTabContent],
  imports: [CommonModule, MatCommonModule, PortalModule, MatRippleModule, ObserversModule, A11yModule],
  exports: [MatCommonModule, MatTabGroup, MatTabLabel, MatTab, MatTabNav, MatTabNavPanel, MatTabLink, MatTabContent]
});
MatTabsModule.ɵinj = ɵɵdefineInjector({
  imports: [[CommonModule, MatCommonModule, PortalModule, MatRippleModule, ObserversModule, A11yModule], MatCommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTabsModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, MatCommonModule, PortalModule, MatRippleModule, ObserversModule, A11yModule],
      // Don't export all components because some are only to be used internally.
      exports: [MatCommonModule, MatTabGroup, MatTabLabel, MatTab, MatTabNav, MatTabNavPanel, MatTabLink, MatTabContent],
      declarations: [MatTabGroup, MatTabLabel, MatTab, MatInkBar, MatTabLabelWrapper, MatTabNav, MatTabNavPanel, MatTabLink, MatTabBody, MatTabBodyPortal, MatTabHeader, MatTabContent]
    }]
  }], null, null);
})();

// node_modules/@angular/material/fesm2020/tree.mjs
var _MatTreeNodeBase = mixinTabIndex(mixinDisabled(CdkTreeNode));
var MatTreeNode = class extends _MatTreeNodeBase {
  constructor(elementRef, tree, tabIndex) {
    super(elementRef, tree);
    this.tabIndex = Number(tabIndex) || 0;
  }
  // This is a workaround for https://github.com/angular/angular/issues/23091
  // In aot mode, the lifecycle hooks from parent class are not called.
  ngOnInit() {
    super.ngOnInit();
  }
  ngOnDestroy() {
    super.ngOnDestroy();
  }
};
MatTreeNode.ɵfac = function MatTreeNode_Factory(ɵt) {
  return new (ɵt || MatTreeNode)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(CdkTree), ɵɵinjectAttribute("tabindex"));
};
MatTreeNode.ɵdir = ɵɵdefineDirective({
  type: MatTreeNode,
  selectors: [["mat-tree-node"]],
  hostAttrs: [1, "mat-tree-node"],
  inputs: {
    role: "role",
    disabled: "disabled",
    tabIndex: "tabIndex"
  },
  exportAs: ["matTreeNode"],
  features: [ɵɵProvidersFeature([{
    provide: CdkTreeNode,
    useExisting: MatTreeNode
  }]), ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTreeNode, [{
    type: Directive,
    args: [{
      selector: "mat-tree-node",
      exportAs: "matTreeNode",
      inputs: ["role", "disabled", "tabIndex"],
      providers: [{
        provide: CdkTreeNode,
        useExisting: MatTreeNode
      }],
      host: {
        "class": "mat-tree-node"
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: CdkTree
    }, {
      type: void 0,
      decorators: [{
        type: Attribute,
        args: ["tabindex"]
      }]
    }];
  }, null);
})();
var MatTreeNodeDef = class extends CdkTreeNodeDef {
};
MatTreeNodeDef.ɵfac = /* @__PURE__ */ (() => {
  let ɵMatTreeNodeDef_BaseFactory;
  return function MatTreeNodeDef_Factory(ɵt) {
    return (ɵMatTreeNodeDef_BaseFactory || (ɵMatTreeNodeDef_BaseFactory = ɵɵgetInheritedFactory(MatTreeNodeDef)))(ɵt || MatTreeNodeDef);
  };
})();
MatTreeNodeDef.ɵdir = ɵɵdefineDirective({
  type: MatTreeNodeDef,
  selectors: [["", "matTreeNodeDef", ""]],
  inputs: {
    when: [0, "matTreeNodeDefWhen", "when"],
    data: [0, "matTreeNode", "data"]
  },
  features: [ɵɵProvidersFeature([{
    provide: CdkTreeNodeDef,
    useExisting: MatTreeNodeDef
  }]), ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTreeNodeDef, [{
    type: Directive,
    args: [{
      selector: "[matTreeNodeDef]",
      inputs: ["when: matTreeNodeDefWhen"],
      providers: [{
        provide: CdkTreeNodeDef,
        useExisting: MatTreeNodeDef
      }]
    }]
  }], null, {
    data: [{
      type: Input,
      args: ["matTreeNode"]
    }]
  });
})();
var MatNestedTreeNode = class extends CdkNestedTreeNode {
  constructor(elementRef, tree, differs, tabIndex) {
    super(elementRef, tree, differs);
    this._disabled = false;
    this.tabIndex = Number(tabIndex) || 0;
  }
  /** Whether the node is disabled. */
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = coerceBooleanProperty(value);
  }
  /** Tabindex for the node. */
  get tabIndex() {
    return this.disabled ? -1 : this._tabIndex;
  }
  set tabIndex(value) {
    this._tabIndex = value != null ? value : 0;
  }
  // This is a workaround for https://github.com/angular/angular/issues/19145
  // In aot mode, the lifecycle hooks from parent class are not called.
  // TODO(tinayuangao): Remove when the angular issue #19145 is fixed
  ngOnInit() {
    super.ngOnInit();
  }
  ngAfterContentInit() {
    super.ngAfterContentInit();
  }
  ngOnDestroy() {
    super.ngOnDestroy();
  }
};
MatNestedTreeNode.ɵfac = function MatNestedTreeNode_Factory(ɵt) {
  return new (ɵt || MatNestedTreeNode)(ɵɵdirectiveInject(ElementRef), ɵɵdirectiveInject(CdkTree), ɵɵdirectiveInject(IterableDiffers), ɵɵinjectAttribute("tabindex"));
};
MatNestedTreeNode.ɵdir = ɵɵdefineDirective({
  type: MatNestedTreeNode,
  selectors: [["mat-nested-tree-node"]],
  hostAttrs: [1, "mat-nested-tree-node"],
  inputs: {
    role: "role",
    disabled: "disabled",
    tabIndex: "tabIndex",
    node: [0, "matNestedTreeNode", "node"]
  },
  exportAs: ["matNestedTreeNode"],
  features: [ɵɵProvidersFeature([{
    provide: CdkNestedTreeNode,
    useExisting: MatNestedTreeNode
  }, {
    provide: CdkTreeNode,
    useExisting: MatNestedTreeNode
  }, {
    provide: CDK_TREE_NODE_OUTLET_NODE,
    useExisting: MatNestedTreeNode
  }]), ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatNestedTreeNode, [{
    type: Directive,
    args: [{
      selector: "mat-nested-tree-node",
      exportAs: "matNestedTreeNode",
      inputs: ["role", "disabled", "tabIndex"],
      providers: [{
        provide: CdkNestedTreeNode,
        useExisting: MatNestedTreeNode
      }, {
        provide: CdkTreeNode,
        useExisting: MatNestedTreeNode
      }, {
        provide: CDK_TREE_NODE_OUTLET_NODE,
        useExisting: MatNestedTreeNode
      }],
      host: {
        "class": "mat-nested-tree-node"
      }
    }]
  }], function() {
    return [{
      type: ElementRef
    }, {
      type: CdkTree
    }, {
      type: IterableDiffers
    }, {
      type: void 0,
      decorators: [{
        type: Attribute,
        args: ["tabindex"]
      }]
    }];
  }, {
    node: [{
      type: Input,
      args: ["matNestedTreeNode"]
    }],
    disabled: [{
      type: Input
    }],
    tabIndex: [{
      type: Input
    }]
  });
})();
var MatTreeNodePadding = class extends CdkTreeNodePadding {
  /** The level of depth of the tree node. The padding will be `level * indent` pixels. */
  get level() {
    return this._level;
  }
  set level(value) {
    this._setLevelInput(value);
  }
  /** The indent for each level. Default number 40px from material design menu sub-menu spec. */
  get indent() {
    return this._indent;
  }
  set indent(indent) {
    this._setIndentInput(indent);
  }
};
MatTreeNodePadding.ɵfac = /* @__PURE__ */ (() => {
  let ɵMatTreeNodePadding_BaseFactory;
  return function MatTreeNodePadding_Factory(ɵt) {
    return (ɵMatTreeNodePadding_BaseFactory || (ɵMatTreeNodePadding_BaseFactory = ɵɵgetInheritedFactory(MatTreeNodePadding)))(ɵt || MatTreeNodePadding);
  };
})();
MatTreeNodePadding.ɵdir = ɵɵdefineDirective({
  type: MatTreeNodePadding,
  selectors: [["", "matTreeNodePadding", ""]],
  inputs: {
    level: [0, "matTreeNodePadding", "level"],
    indent: [0, "matTreeNodePaddingIndent", "indent"]
  },
  features: [ɵɵProvidersFeature([{
    provide: CdkTreeNodePadding,
    useExisting: MatTreeNodePadding
  }]), ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTreeNodePadding, [{
    type: Directive,
    args: [{
      selector: "[matTreeNodePadding]",
      providers: [{
        provide: CdkTreeNodePadding,
        useExisting: MatTreeNodePadding
      }]
    }]
  }], null, {
    level: [{
      type: Input,
      args: ["matTreeNodePadding"]
    }],
    indent: [{
      type: Input,
      args: ["matTreeNodePaddingIndent"]
    }]
  });
})();
var MatTreeNodeOutlet = class {
  constructor(viewContainer, _node) {
    this.viewContainer = viewContainer;
    this._node = _node;
  }
};
MatTreeNodeOutlet.ɵfac = function MatTreeNodeOutlet_Factory(ɵt) {
  return new (ɵt || MatTreeNodeOutlet)(ɵɵdirectiveInject(ViewContainerRef), ɵɵdirectiveInject(CDK_TREE_NODE_OUTLET_NODE, 8));
};
MatTreeNodeOutlet.ɵdir = ɵɵdefineDirective({
  type: MatTreeNodeOutlet,
  selectors: [["", "matTreeNodeOutlet", ""]],
  features: [ɵɵProvidersFeature([{
    provide: CdkTreeNodeOutlet,
    useExisting: MatTreeNodeOutlet
  }])]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTreeNodeOutlet, [{
    type: Directive,
    args: [{
      selector: "[matTreeNodeOutlet]",
      providers: [{
        provide: CdkTreeNodeOutlet,
        useExisting: MatTreeNodeOutlet
      }]
    }]
  }], function() {
    return [{
      type: ViewContainerRef
    }, {
      type: void 0,
      decorators: [{
        type: Inject,
        args: [CDK_TREE_NODE_OUTLET_NODE]
      }, {
        type: Optional
      }]
    }];
  }, null);
})();
var MatTree = class extends CdkTree {
};
MatTree.ɵfac = /* @__PURE__ */ (() => {
  let ɵMatTree_BaseFactory;
  return function MatTree_Factory(ɵt) {
    return (ɵMatTree_BaseFactory || (ɵMatTree_BaseFactory = ɵɵgetInheritedFactory(MatTree)))(ɵt || MatTree);
  };
})();
MatTree.ɵcmp = ɵɵdefineComponent({
  type: MatTree,
  selectors: [["mat-tree"]],
  viewQuery: function MatTree_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(MatTreeNodeOutlet, 7);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx._nodeOutlet = _t.first);
    }
  },
  hostAttrs: ["role", "tree", 1, "mat-tree"],
  exportAs: ["matTree"],
  features: [ɵɵProvidersFeature([{
    provide: CdkTree,
    useExisting: MatTree
  }]), ɵɵInheritDefinitionFeature],
  decls: 1,
  vars: 0,
  consts: [["matTreeNodeOutlet", ""]],
  template: function MatTree_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementContainer(0, 0);
    }
  },
  dependencies: [MatTreeNodeOutlet],
  styles: [".mat-tree{display:block}.mat-tree-node{display:flex;align-items:center;flex:1;word-wrap:break-word}.mat-nested-tree-node{border-bottom-width:0}\n"],
  encapsulation: 2
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTree, [{
    type: Component,
    args: [{
      selector: "mat-tree",
      exportAs: "matTree",
      template: `<ng-container matTreeNodeOutlet></ng-container>`,
      host: {
        "class": "mat-tree",
        "role": "tree"
      },
      encapsulation: ViewEncapsulation$1.None,
      changeDetection: ChangeDetectionStrategy.Default,
      providers: [{
        provide: CdkTree,
        useExisting: MatTree
      }],
      styles: [".mat-tree{display:block}.mat-tree-node{display:flex;align-items:center;flex:1;word-wrap:break-word}.mat-nested-tree-node{border-bottom-width:0}\n"]
    }]
  }], null, {
    _nodeOutlet: [{
      type: ViewChild,
      args: [MatTreeNodeOutlet, {
        static: true
      }]
    }]
  });
})();
var MatTreeNodeToggle = class extends CdkTreeNodeToggle {
};
MatTreeNodeToggle.ɵfac = /* @__PURE__ */ (() => {
  let ɵMatTreeNodeToggle_BaseFactory;
  return function MatTreeNodeToggle_Factory(ɵt) {
    return (ɵMatTreeNodeToggle_BaseFactory || (ɵMatTreeNodeToggle_BaseFactory = ɵɵgetInheritedFactory(MatTreeNodeToggle)))(ɵt || MatTreeNodeToggle);
  };
})();
MatTreeNodeToggle.ɵdir = ɵɵdefineDirective({
  type: MatTreeNodeToggle,
  selectors: [["", "matTreeNodeToggle", ""]],
  inputs: {
    recursive: [0, "matTreeNodeToggleRecursive", "recursive"]
  },
  features: [ɵɵProvidersFeature([{
    provide: CdkTreeNodeToggle,
    useExisting: MatTreeNodeToggle
  }]), ɵɵInheritDefinitionFeature]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTreeNodeToggle, [{
    type: Directive,
    args: [{
      selector: "[matTreeNodeToggle]",
      providers: [{
        provide: CdkTreeNodeToggle,
        useExisting: MatTreeNodeToggle
      }],
      inputs: ["recursive: matTreeNodeToggleRecursive"]
    }]
  }], null, null);
})();
var MAT_TREE_DIRECTIVES = [MatNestedTreeNode, MatTreeNodeDef, MatTreeNodePadding, MatTreeNodeToggle, MatTree, MatTreeNode, MatTreeNodeOutlet];
var MatTreeModule = class {
};
MatTreeModule.ɵfac = function MatTreeModule_Factory(ɵt) {
  return new (ɵt || MatTreeModule)();
};
MatTreeModule.ɵmod = ɵɵdefineNgModule({
  type: MatTreeModule,
  declarations: [MatNestedTreeNode, MatTreeNodeDef, MatTreeNodePadding, MatTreeNodeToggle, MatTree, MatTreeNode, MatTreeNodeOutlet],
  imports: [CdkTreeModule, MatCommonModule],
  exports: [MatCommonModule, MatNestedTreeNode, MatTreeNodeDef, MatTreeNodePadding, MatTreeNodeToggle, MatTree, MatTreeNode, MatTreeNodeOutlet]
});
MatTreeModule.ɵinj = ɵɵdefineInjector({
  imports: [[CdkTreeModule, MatCommonModule], MatCommonModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MatTreeModule, [{
    type: NgModule,
    args: [{
      imports: [CdkTreeModule, MatCommonModule],
      exports: [MatCommonModule, MAT_TREE_DIRECTIVES],
      declarations: MAT_TREE_DIRECTIVES
    }]
  }], null, null);
})();

// node_modules/@innovapptive.com/dynamictable/fesm2020/innovapptive.com-dynamictable.mjs
function TableFilterPanelComponent_mat_option_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-option", 20)(1, "div", 21);
    ɵɵlistener("click", function TableFilterPanelComponent_mat_option_13_Template_div_click_1_listener() {
      const item_r4 = ɵɵrestoreView(_r3).$implicit;
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.addGroup(item_r4));
    });
    ɵɵelementStart(2, "span", 22);
    ɵɵtext(3);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const item_r4 = ctx.$implicit;
    const ctx_r4 = ɵɵnextContext();
    ɵɵproperty("disabled", ctx_r4.configOptions.groupByColumns.length >= 3)("value", item_r4);
    ɵɵadvance(3);
    ɵɵtextInterpolate(item_r4.displayName);
  }
}
function TableFilterPanelComponent_mat_list_item_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-list-item", 23)(1, "div", 24)(2, "span", 25);
    ɵɵtext(3);
    ɵɵelementEnd();
    ɵɵelementStart(4, "mat-icon", 26);
    ɵɵlistener("click", function TableFilterPanelComponent_mat_list_item_15_Template_mat_icon_click_4_listener($event) {
      const column_r7 = ɵɵrestoreView(_r6).$implicit;
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.removeGroup($event, column_r7));
    });
    ɵɵtext(5, " close ");
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const column_r7 = ctx.$implicit;
    ɵɵadvance(3);
    ɵɵtextInterpolate1(" ", column_r7.displayName, " ");
  }
}
function TableFilterPanelComponent_mat_option_30_Template(rf, ctx) {
  if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-option", 27)(1, "div", 21);
    ɵɵlistener("click", function TableFilterPanelComponent_mat_option_30_Template_div_click_1_listener() {
      const item_r10 = ɵɵrestoreView(_r9).$implicit;
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.optionClicked(item_r10));
    });
    ɵɵelementStart(2, "mat-checkbox", 28);
    ɵɵlistener("change", function TableFilterPanelComponent_mat_option_30_Template_mat_checkbox_change_2_listener($event) {
      const item_r10 = ɵɵrestoreView(_r9).$implicit;
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.toggleColumnVisibility($event.checked, item_r10.id));
    });
    ɵɵtext(3);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const item_r10 = ctx.$implicit;
    ɵɵproperty("value", item_r10);
    ɵɵadvance(2);
    ɵɵproperty("checked", item_r10.visible);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", item_r10.displayName, " ");
  }
}
function TableFilterPanelComponent_mat_list_item_33_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-list-item", 23)(1, "div", 24)(2, "mat-checkbox", 29);
    ɵɵlistener("change", function TableFilterPanelComponent_mat_list_item_33_Template_mat_checkbox_change_2_listener($event) {
      const column_r12 = ɵɵrestoreView(_r11).$implicit;
      const ctx_r4 = ɵɵnextContext();
      return ɵɵresetView(ctx_r4.toggleColumnVisibility($event.checked, column_r12["id"]));
    });
    ɵɵtext(3);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const column_r12 = ctx.$implicit;
    ɵɵadvance(2);
    ɵɵproperty("checked", column_r12["visible"]);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", column_r12.displayName, " ");
  }
}
var _c011 = (a0, a1) => ({
  width: a0,
  "max-height": a1
});
var _c17 = () => ["expandedDetail"];
var _c25 = (a0, a1) => ({
  disabled: a0,
  "not-disabled": a1
});
var _c35 = (a0) => ({
  "red-text": a0
});
var _c44 = (a0) => ({
  highlight: a0
});
var _c52 = () => [10, 25, 50, 75, 100];
function DynamictableComponent_div_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 20)(1, "cwp-table-filter-panel", 21);
    ɵɵlistener("eventsHandler", function DynamictableComponent_div_1_Template_cwp_table_filter_panel_eventsHandler_1_listener($event) {
      ɵɵrestoreView(_r1);
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.handleEvent($event));
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("configOptions", ctx_r1.configOptions);
  }
}
function DynamictableComponent_ng_container_5_th_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "th", 25)(1, "mat-checkbox", 26);
    ɵɵlistener("change", function DynamictableComponent_ng_container_5_th_1_Template_mat_checkbox_change_1_listener($event) {
      ɵɵrestoreView(_r3);
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView($event ? ctx_r1.masterToggle() : null);
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("checked", ctx_r1.selection.hasValue() && ctx_r1.isAllSelected())("indeterminate", ctx_r1.selection.hasValue() && !ctx_r1.isAllSelected())("aria-label", ctx_r1.checkboxLabel());
  }
}
function DynamictableComponent_ng_container_5_td_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 27)(1, "mat-checkbox", 28);
    ɵɵlistener("click", function DynamictableComponent_ng_container_5_td_2_Template_mat_checkbox_click_1_listener($event) {
      ɵɵrestoreView(_r4);
      return ɵɵresetView($event.stopPropagation());
    })("change", function DynamictableComponent_ng_container_5_td_2_Template_mat_checkbox_change_1_listener($event) {
      const row_r5 = ɵɵrestoreView(_r4).$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView($event ? ctx_r1.toggleRowSelect(row_r5) : null);
    });
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const row_r5 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("disabled", ctx_r1.configOptions.enableRowsSelection && !ctx_r1.evaluateCondition(row_r5, ctx_r1.configOptions.enableRowLevelActions))("checked", ctx_r1.configOptions.enableRowsSelection && ctx_r1.evaluateCondition(row_r5, ctx_r1.configOptions.enableRowLevelActions) && ctx_r1.selection.isSelected(row_r5))("aria-label", ctx_r1.checkboxLabel(row_r5));
  }
}
function DynamictableComponent_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 22);
    ɵɵtemplate(1, DynamictableComponent_ng_container_5_th_1_Template, 2, 3, "th", 23)(2, DynamictableComponent_ng_container_5_td_2_Template, 2, 3, "td", 24);
    ɵɵelementContainerEnd();
  }
}
function DynamictableComponent_ng_container_6_th_1_span_4_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 48);
    ɵɵtext(1, " ↑ ");
    ɵɵelementEnd();
  }
}
function DynamictableComponent_ng_container_6_th_1_span_4_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 49);
    ɵɵtext(1, " ↓ ");
    ɵɵelementEnd();
  }
}
function DynamictableComponent_ng_container_6_th_1_span_4_span_3_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1, "⇅");
    ɵɵelementEnd();
  }
}
function DynamictableComponent_ng_container_6_th_1_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtemplate(1, DynamictableComponent_ng_container_6_th_1_span_4_span_1_Template, 2, 0, "span", 46)(2, DynamictableComponent_ng_container_6_th_1_span_4_span_2_Template, 2, 0, "span", 47)(3, DynamictableComponent_ng_container_6_th_1_span_4_span_3_Template, 2, 0, "span", 35);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r7 = ɵɵnextContext(2).$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.sort && ctx_r1.sort.active === column_r7.id && ctx_r1.sort.direction == "asc");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.sort && ctx_r1.sort.active === column_r7.id && ctx_r1.sort.direction == "desc");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.sort && ctx_r1.sort.active !== column_r7.id);
  }
}
function DynamictableComponent_ng_container_6_th_1_button_6_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 50);
    ɵɵlistener("click", function DynamictableComponent_ng_container_6_th_1_button_6_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r8);
      return ɵɵresetView($event.stopPropagation());
    });
    ɵɵelementStart(1, "mat-icon");
    ɵɵtext(2, "more_horiz");
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const menu_r9 = ɵɵreference(8);
    ɵɵproperty("matMenuTriggerFor", menu_r9);
  }
}
function DynamictableComponent_ng_container_6_th_1_button_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 51);
    ɵɵlistener("click", function DynamictableComponent_ng_container_6_th_1_button_9_Template_button_click_0_listener() {
      ɵɵrestoreView(_r10);
      const column_r7 = ɵɵnextContext(2).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.hideColumn(column_r7.id));
    });
    ɵɵtext(1, " Hide Column ");
    ɵɵelementEnd();
  }
}
function DynamictableComponent_ng_container_6_th_1_button_10_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 52);
    ɵɵlistener("click", function DynamictableComponent_ng_container_6_th_1_button_10_Template_button_click_0_listener() {
      ɵɵrestoreView(_r11);
      const column_r7 = ɵɵnextContext(2).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.moveLeft(column_r7.id));
    });
    ɵɵtext(1, " Move Left ");
    ɵɵelementEnd();
  }
}
function DynamictableComponent_ng_container_6_th_1_button_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r12 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 53);
    ɵɵlistener("click", function DynamictableComponent_ng_container_6_th_1_button_11_Template_button_click_0_listener() {
      ɵɵrestoreView(_r12);
      const column_r7 = ɵɵnextContext(2).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.moveRight(column_r7.id));
    });
    ɵɵtext(1, " Move Right ");
    ɵɵelementEnd();
  }
}
function DynamictableComponent_ng_container_6_th_1_button_12_Template(rf, ctx) {
  if (rf & 1) {
    const _r13 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 54);
    ɵɵlistener("click", function DynamictableComponent_ng_container_6_th_1_button_12_Template_button_click_0_listener() {
      ɵɵrestoreView(_r13);
      const column_r7 = ɵɵnextContext(2).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.stick(column_r7.id));
    });
    ɵɵtext(1, " Stick ");
    ɵɵelementEnd();
  }
}
function DynamictableComponent_ng_container_6_th_1_button_13_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 55);
    ɵɵlistener("click", function DynamictableComponent_ng_container_6_th_1_button_13_Template_button_click_0_listener() {
      ɵɵrestoreView(_r14);
      const column_r7 = ɵɵnextContext(2).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.unstick(column_r7.id));
    });
    ɵɵtext(1, " Un-stick ");
    ɵɵelementEnd();
  }
}
function DynamictableComponent_ng_container_6_th_1_button_14_Template(rf, ctx) {
  if (rf & 1) {
    const _r15 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 56);
    ɵɵlistener("click", function DynamictableComponent_ng_container_6_th_1_button_14_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r15);
      const column_r7 = ɵɵnextContext(2).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.addGroup(column_r7, $event));
    });
    ɵɵtext(1, " Group Rows by this Column ");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext(3);
    ɵɵproperty("disabled", ctx_r1.configOptions.groupByColumns.length >= 3);
  }
}
function DynamictableComponent_ng_container_6_th_1_button_15_Template(rf, ctx) {
  if (rf & 1) {
    const _r16 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 57);
    ɵɵlistener("click", function DynamictableComponent_ng_container_6_th_1_button_15_Template_button_click_0_listener($event) {
      ɵɵrestoreView(_r16);
      const column_r7 = ɵɵnextContext(2).$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.removeGroup(column_r7, $event));
    });
    ɵɵtext(1, " Un-group this Column ");
    ɵɵelementEnd();
  }
}
function DynamictableComponent_ng_container_6_th_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "th", 32)(1, "div", 33)(2, "div", 34);
    ɵɵtext(3);
    ɵɵtemplate(4, DynamictableComponent_ng_container_6_th_1_span_4_Template, 4, 3, "span", 35);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 36);
    ɵɵlistener("click", function DynamictableComponent_ng_container_6_th_1_Template_div_click_5_listener($event) {
      ɵɵrestoreView(_r6);
      return ɵɵresetView($event.stopPropagation());
    });
    ɵɵtemplate(6, DynamictableComponent_ng_container_6_th_1_button_6_Template, 3, 1, "button", 37);
    ɵɵelementStart(7, "mat-menu", 38, 0);
    ɵɵtemplate(9, DynamictableComponent_ng_container_6_th_1_button_9_Template, 2, 0, "button", 39)(10, DynamictableComponent_ng_container_6_th_1_button_10_Template, 2, 0, "button", 40)(11, DynamictableComponent_ng_container_6_th_1_button_11_Template, 2, 0, "button", 41)(12, DynamictableComponent_ng_container_6_th_1_button_12_Template, 2, 0, "button", 42)(13, DynamictableComponent_ng_container_6_th_1_button_13_Template, 2, 0, "button", 43)(14, DynamictableComponent_ng_container_6_th_1_button_14_Template, 2, 1, "button", 44)(15, DynamictableComponent_ng_container_6_th_1_button_15_Template, 2, 0, "button", 45);
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const column_r7 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("cdkDragDisabled", !column_r7.movable)("disableClear", true)("disabled", !column_r7.sortable);
    ɵɵadvance(3);
    ɵɵtextInterpolate1(" ", column_r7.displayName, " ");
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r7.sortable === true);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", column_r7.showMenuOptions);
    ɵɵadvance(3);
    ɵɵproperty("ngIf", column_r7.hideable);
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r7.movable);
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r7.movable);
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isSticky(ctx_r1.stickyColumns, column_r7.id) && column_r7.stickable);
    ɵɵadvance();
    ɵɵproperty("ngIf", (ctx_r1.isSticky(ctx_r1.stickyColumns, column_r7.id) || ctx_r1.isStickyEnd(ctx_r1.stickyEndColumns, column_r7.id)) && column_r7.stickable);
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r7.visible && column_r7.groupable && !ctx_r1.isGrouped(column_r7.id));
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r7.visible && column_r7.groupable && ctx_r1.isGrouped(column_r7.id));
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_img_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "img", 67);
  }
  if (rf & 2) {
    const element_r18 = ɵɵnextContext(2).$implicit;
    ɵɵproperty("src", element_r18.preTextImage.image, ɵɵsanitizeUrl)("ngStyle", element_r18.preTextImage.style);
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_2_span_1_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "span", 74);
  }
  if (rf & 2) {
    const element_r18 = ɵɵnextContext(4).$implicit;
    ɵɵproperty("innerHTML", element_r18.rightElement, ɵɵsanitizeHtml);
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_2_span_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r19 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 72, 1);
    ɵɵlistener("click", function DynamictableComponent_ng_container_6_td_2_div_1_span_2_span_1_Template_span_click_0_listener() {
      ɵɵrestoreView(_r19);
      const element_r18 = ɵɵnextContext(3).$implicit;
      const column_r7 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onCellClick(element_r18, column_r7.id, column_r7.controlType));
    });
    ɵɵtext(2);
    ɵɵpipe(3, "dynamicTypePipe");
    ɵɵtemplate(4, DynamictableComponent_ng_container_6_td_2_div_1_span_2_span_1_span_4_Template, 1, 1, "span", 73);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const element_r18 = ɵɵnextContext(3).$implicit;
    const column_r7 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵpropertyInterpolate("matTooltip", element_r18[column_r7.id]);
    ɵɵproperty("ngStyle", ctx_r1.getConditionalStyles(column_r7.titleStyle, element_r18, column_r7))("matTooltipDisabled", !column_r7.hasMatToolTip);
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(3, 5, element_r18[column_r7.id], column_r7.type), " ");
    ɵɵadvance(2);
    ɵɵproperty("ngIf", column_r7.hasRightElement);
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_2_span_2_span_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1, ", ");
    ɵɵelementEnd();
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_2_span_2_span_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r20 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span", 77);
    ɵɵlistener("click", function DynamictableComponent_ng_container_6_td_2_div_1_span_2_span_2_span_1_Template_span_click_0_listener() {
      const item_r21 = ɵɵrestoreView(_r20).$implicit;
      const element_r18 = ɵɵnextContext(4).$implicit;
      const column_r7 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onCellClick(element_r18, column_r7.id, item_r21));
    });
    ɵɵtext(1);
    ɵɵtemplate(2, DynamictableComponent_ng_container_6_td_2_div_1_span_2_span_2_span_1_span_2_Template, 2, 0, "span", 35);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const item_r21 = ctx.$implicit;
    const isLast_r22 = ctx.last;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", item_r21, "");
    ɵɵadvance();
    ɵɵproperty("ngIf", !isLast_r22);
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_2_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 75);
    ɵɵtemplate(1, DynamictableComponent_ng_container_6_td_2_div_1_span_2_span_2_span_1_Template, 3, 2, "span", 76);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const element_r18 = ɵɵnextContext(3).$implicit;
    const column_r7 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngStyle", column_r7.titleStyle);
    ɵɵadvance();
    ɵɵproperty("ngForOf", element_r18[column_r7.id]);
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_2_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 78);
    ɵɵtext(1);
    ɵɵpipe(2, "dynamicTypePipe");
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const element_r18 = ɵɵnextContext(3).$implicit;
    const column_r7 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngStyle", element_r18[column_r7.subtitleColumn] !== "" ? column_r7.subtitleStyle : "");
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", ɵɵpipeBind2(2, 2, element_r18[column_r7.subtitleColumn], column_r7.type), " ");
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_2_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 79);
    ɵɵelement(1, "br")(2, "span", 80);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const element_r18 = ɵɵnextContext(3).$implicit;
    ɵɵadvance(2);
    ɵɵproperty("innerHTML", element_r18.belowElement, ɵɵsanitizeHtml);
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 7);
    ɵɵtemplate(1, DynamictableComponent_ng_container_6_td_2_div_1_span_2_span_1_Template, 5, 8, "span", 68)(2, DynamictableComponent_ng_container_6_td_2_div_1_span_2_span_2_Template, 2, 2, "span", 69);
    ɵɵelement(3, "br");
    ɵɵtemplate(4, DynamictableComponent_ng_container_6_td_2_div_1_span_2_span_4_Template, 3, 5, "span", 70)(5, DynamictableComponent_ng_container_6_td_2_div_1_span_2_span_5_Template, 3, 1, "span", 71);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const element_r18 = ɵɵnextContext(2).$implicit;
    const column_r7 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngClass", (column_r7 == null ? null : column_r7.hasMatToolTip) ? "mat-tooltip-parent" : "");
    ɵɵadvance();
    ɵɵproperty("ngIf", !ctx_r1.isArray(element_r18[column_r7.id]));
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.isArray(element_r18[column_r7.id]));
    ɵɵadvance(2);
    ɵɵproperty("ngIf", column_r7.hasSubtitle);
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r7.hasBelowElement);
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r23 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "span")(1, "span", 81)(2, "mat-slide-toggle", 82);
    ɵɵlistener("change", function DynamictableComponent_ng_container_6_td_2_div_1_span_3_Template_mat_slide_toggle_change_2_listener($event) {
      ɵɵrestoreView(_r23);
      const ctx_r1 = ɵɵnextContext(4);
      return ɵɵresetView(ctx_r1.onToggleChange($event));
    });
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const element_r18 = ɵɵnextContext(2).$implicit;
    const column_r7 = ɵɵnextContext().$implicit;
    ɵɵadvance(2);
    ɵɵproperty("checked", element_r18[column_r7.id]);
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵelement(1, "span", 80);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const element_r18 = ɵɵnextContext(2).$implicit;
    const column_r7 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("innerHTML", element_r18[column_r7.id], ɵɵsanitizeHtml);
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_5_button_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 85);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r7 = ɵɵnextContext(4).$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", column_r7.controlValue, " ");
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_5_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 86);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const element_r18 = ɵɵnextContext(3).$implicit;
    const column_r7 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", element_r18[column_r7.id], " ");
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 83);
    ɵɵtemplate(1, DynamictableComponent_ng_container_6_td_2_div_1_span_5_button_1_Template, 2, 1, "button", 84)(2, DynamictableComponent_ng_container_6_td_2_div_1_span_5_ng_template_2_Template, 2, 1, "ng-template", null, 2, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const freeText_r24 = ɵɵreference(3);
    const element_r18 = ɵɵnextContext(2).$implicit;
    const column_r7 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", !element_r18[column_r7.id])("ngIfElse", freeText_r24);
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_6_span_1_ng_container_1_mat_icon_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const button_r27 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", button_r27.iconName, " ");
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_6_span_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r25 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "mat-button-toggle-group", 90, 3);
    ɵɵlistener("change", function DynamictableComponent_ng_container_6_td_2_div_1_span_6_span_1_ng_container_1_Template_mat_button_toggle_group_change_1_listener() {
      ɵɵrestoreView(_r25);
      const group_r26 = ɵɵreference(2);
      const element_r18 = ɵɵnextContext(4).$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onValChange(element_r18, group_r26.value));
    });
    ɵɵelementStart(3, "mat-button-toggle", 91);
    ɵɵtemplate(4, DynamictableComponent_ng_container_6_td_2_div_1_span_6_span_1_ng_container_1_mat_icon_4_Template, 2, 1, "mat-icon", 35);
    ɵɵelementEnd()();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const button_r27 = ctx.$implicit;
    ɵɵadvance(3);
    ɵɵclassMap(button_r27.class);
    ɵɵproperty("value", button_r27.value);
    ɵɵadvance();
    ɵɵproperty("ngIf", button_r27.isIcon);
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_6_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtemplate(1, DynamictableComponent_ng_container_6_td_2_div_1_span_6_span_1_ng_container_1_Template, 5, 5, "ng-container", 89);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const column_r7 = ɵɵnextContext(4).$implicit;
    ɵɵadvance();
    ɵɵproperty("ngForOf", column_r7 == null ? null : column_r7.controlValue);
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_6_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 86);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const element_r18 = ɵɵnextContext(3).$implicit;
    const column_r7 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", element_r18[column_r7.id], " ");
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 87);
    ɵɵtemplate(1, DynamictableComponent_ng_container_6_td_2_div_1_span_6_span_1_Template, 2, 1, "span", 35)(2, DynamictableComponent_ng_container_6_td_2_div_1_span_6_span_2_Template, 2, 1, "span", 88);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const element_r18 = ɵɵnextContext(2).$implicit;
    const column_r7 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", (column_r7 == null ? null : column_r7.controlValue.length) && !element_r18[column_r7.id]);
    ɵɵadvance();
    ɵɵproperty("ngIf", element_r18[column_r7.id]);
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_7_button_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 94);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const menu_r28 = ɵɵreference(3);
    const column_r7 = ɵɵnextContext(3).$implicit;
    ɵɵproperty("matMenuTriggerFor", menu_r28);
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", column_r7.controlValue["buttonName"], " ");
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_7_ng_template_4_button_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r29 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 96);
    ɵɵlistener("click", function DynamictableComponent_ng_container_6_td_2_div_1_span_7_ng_template_4_button_0_Template_button_click_0_listener() {
      const btn_r30 = ɵɵrestoreView(_r29).$implicit;
      const element_r18 = ɵɵnextContext(4).$implicit;
      const column_r7 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onMenuButtonClick(element_r18, column_r7.id, btn_r30));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const btn_r30 = ctx.$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", btn_r30, " ");
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_7_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵtemplate(0, DynamictableComponent_ng_container_6_td_2_div_1_span_7_ng_template_4_button_0_Template, 2, 1, "button", 95);
  }
  if (rf & 2) {
    const column_r7 = ɵɵnextContext(4).$implicit;
    ɵɵproperty("ngForOf", column_r7.controlValue["menuButtonNames"]);
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_7_ng_template_5_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const element_r18 = ɵɵnextContext(3).$implicit;
    const column_r7 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", element_r18[column_r7.id], " ");
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 83);
    ɵɵtemplate(1, DynamictableComponent_ng_container_6_td_2_div_1_span_7_button_1_Template, 2, 2, "button", 92);
    ɵɵelementStart(2, "mat-menu", null, 0);
    ɵɵtemplate(4, DynamictableComponent_ng_container_6_td_2_div_1_span_7_ng_template_4_Template, 1, 1, "ng-template", 93);
    ɵɵelementEnd();
    ɵɵtemplate(5, DynamictableComponent_ng_container_6_td_2_div_1_span_7_ng_template_5_Template, 2, 1, "ng-template", null, 2, ɵɵtemplateRefExtractor);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const freeText_r31 = ɵɵreference(6);
    const element_r18 = ɵɵnextContext(2).$implicit;
    const column_r7 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", !element_r18[column_r7.id])("ngIfElse", freeText_r31);
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_8_div_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div");
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const value_r32 = ctx.$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", value_r32, " ");
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span")(1, "span", 97);
    ɵɵtemplate(2, DynamictableComponent_ng_container_6_td_2_div_1_span_8_div_2_Template, 2, 1, "div", 89);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const element_r18 = ɵɵnextContext(2).$implicit;
    const column_r7 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance();
    ɵɵproperty("ngStyle", column_r7.titleStyle);
    ɵɵadvance();
    ɵɵproperty("ngForOf", ctx_r1.getDisplayValues(element_r18[column_r7.id], column_r7.controlValue));
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_9_span_1_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 105);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const element_r18 = ɵɵnextContext(4).$implicit;
    const column_r7 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", element_r18[column_r7.id], " ");
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_9_span_1_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 106);
    ɵɵtext(1, " Select ");
    ɵɵelementEnd();
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_9_span_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 101);
    ɵɵtemplate(1, DynamictableComponent_ng_container_6_td_2_div_1_span_9_span_1_span_1_Template, 2, 1, "span", 102)(2, DynamictableComponent_ng_container_6_td_2_div_1_span_9_span_1_span_2_Template, 2, 0, "span", 103);
    ɵɵelementStart(3, "span", 104)(4, "mat-icon");
    ɵɵtext(5, "arrow_drop_down");
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const element_r18 = ɵɵnextContext(3).$implicit;
    const column_r7 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", element_r18[column_r7.id] !== void 0);
    ɵɵadvance();
    ɵɵproperty("ngIf", element_r18[column_r7.id] === void 0);
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_9_span_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 107);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const element_r18 = ɵɵnextContext(3).$implicit;
    const column_r7 = ɵɵnextContext().$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", element_r18[column_r7.id], " ");
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_span_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "span", 98);
    ɵɵtemplate(1, DynamictableComponent_ng_container_6_td_2_div_1_span_9_span_1_Template, 6, 2, "span", 99)(2, DynamictableComponent_ng_container_6_td_2_div_1_span_9_span_2_Template, 2, 1, "span", 100);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const element_r18 = ɵɵnextContext(2).$implicit;
    const column_r7 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("id", element_r18.id);
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.getDisplayType(element_r18, column_r7, column_r7.controlValue) === "dropdown");
    ɵɵadvance();
    ɵɵproperty("ngIf", ctx_r1.getDisplayType(element_r18, column_r7, column_r7.controlValue) === "text");
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_img_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "img", 108);
  }
  if (rf & 2) {
    const element_r18 = ɵɵnextContext(2).$implicit;
    ɵɵproperty("src", element_r18.postTextImage.image, ɵɵsanitizeUrl)("ngStyle", element_r18.postTextImage.style);
  }
}
function DynamictableComponent_ng_container_6_td_2_div_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 60);
    ɵɵtemplate(1, DynamictableComponent_ng_container_6_td_2_div_1_img_1_Template, 1, 2, "img", 61)(2, DynamictableComponent_ng_container_6_td_2_div_1_span_2_Template, 6, 5, "span", 62)(3, DynamictableComponent_ng_container_6_td_2_div_1_span_3_Template, 3, 1, "span", 35)(4, DynamictableComponent_ng_container_6_td_2_div_1_span_4_Template, 2, 1, "span", 35)(5, DynamictableComponent_ng_container_6_td_2_div_1_span_5_Template, 4, 2, "span", 63)(6, DynamictableComponent_ng_container_6_td_2_div_1_span_6_Template, 3, 2, "span", 64)(7, DynamictableComponent_ng_container_6_td_2_div_1_span_7_Template, 7, 2, "span", 63)(8, DynamictableComponent_ng_container_6_td_2_div_1_span_8_Template, 3, 2, "span", 35)(9, DynamictableComponent_ng_container_6_td_2_div_1_span_9_Template, 3, 3, "span", 65)(10, DynamictableComponent_ng_container_6_td_2_div_1_img_10_Template, 1, 2, "img", 66);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const element_r18 = ɵɵnextContext().$implicit;
    const column_r7 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("ngClass", ɵɵpureFunction2(11, _c25, element_r18[column_r7.controlValue == null ? null : column_r7.controlValue.dependentFieldId] === true && column_r7.controlValue.disableBackground === true, element_r18[column_r7.controlValue == null ? null : column_r7.controlValue.dependentFieldId] === false && column_r7.controlValue.disableBackground === true));
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r7.hasPreTextImage && element_r18.preTextImage && element_r18.preTextImage.image && element_r18.preTextImage.condition && ctx_r1.evaluateCondition(element_r18, element_r18.preTextImage));
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r7.controlType === "string");
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r7.controlType === "slide-toggle");
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r7.controlType === "html");
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r7.controlType === "button");
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r7.controlType === "button-toggle");
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r7.controlType === "menu");
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r7.controlType === "space-between");
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r7.controlType === "dropdown");
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r7.hasPostTextImage && element_r18.postTextImage && element_r18.postTextImage.image && element_r18.postTextImage.condition && ctx_r1.evaluateCondition(element_r18, element_r18.postTextImage));
  }
}
function DynamictableComponent_ng_container_6_td_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r17 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "td", 58);
    ɵɵlistener("click", function DynamictableComponent_ng_container_6_td_2_Template_td_click_0_listener() {
      const element_r18 = ɵɵrestoreView(_r17).$implicit;
      const column_r7 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext();
      return ɵɵresetView(ctx_r1.onCellClick(element_r18, column_r7.id, column_r7.controlType));
    });
    ɵɵtemplate(1, DynamictableComponent_ng_container_6_td_2_div_1_Template, 11, 14, "div", 59);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const element_r18 = ctx.$implicit;
    const i_r33 = ctx.dataIndex;
    const column_r7 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵstyleProp("display", ctx_r1.getRowSpan(column_r7.id, i_r33) ? "" : "none");
    ɵɵpropertyInterpolate("id", column_r7.id);
    ɵɵproperty("ngStyle", ctx_r1.evaluateExpression(element_r18, column_r7));
    ɵɵattribute("rowspan", ctx_r1.getRowSpan(column_r7.id, i_r33));
    ɵɵadvance();
    ɵɵproperty("ngIf", column_r7 && element_r18);
  }
}
function DynamictableComponent_ng_container_6_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 29);
    ɵɵtemplate(1, DynamictableComponent_ng_container_6_th_1_Template, 16, 13, "th", 30)(2, DynamictableComponent_ng_container_6_td_2_Template, 2, 6, "td", 31);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const column_r7 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵproperty("matColumnDef", column_r7.id)("sticky", ctx_r1.isSticky(ctx_r1.stickyColumns, column_r7.id))("stickyEnd", ctx_r1.isStickyEnd(ctx_r1.stickyEndColumns, column_r7.id));
  }
}
function DynamictableComponent_ng_container_7_th_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "th", 111);
    ɵɵtext(1, " Actions ");
    ɵɵelementEnd();
  }
}
function DynamictableComponent_ng_container_7_td_2_ng_container_2_mat_icon_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r37 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-icon", 119);
    ɵɵlistener("click", function DynamictableComponent_ng_container_7_td_2_ng_container_2_mat_icon_2_Template_mat_icon_click_0_listener() {
      ɵɵrestoreView(_r37);
      const iconAction_r35 = ɵɵnextContext().$implicit;
      const row_r36 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onRowLevelActionIconClick(iconAction_r35, row_r36));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const iconAction_r35 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngStyle", iconAction_r35.styleToggleOn);
    ɵɵadvance();
    ɵɵtextInterpolate1("", iconAction_r35.iconToggleOn, " ");
  }
}
function DynamictableComponent_ng_container_7_td_2_ng_container_2_mat_icon_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r38 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "mat-icon", 120);
    ɵɵlistener("click", function DynamictableComponent_ng_container_7_td_2_ng_container_2_mat_icon_3_Template_mat_icon_click_0_listener() {
      ɵɵrestoreView(_r38);
      const iconAction_r35 = ɵɵnextContext().$implicit;
      const row_r36 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onRowLevelActionIconClick(iconAction_r35, row_r36));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const iconAction_r35 = ɵɵnextContext().$implicit;
    ɵɵproperty("ngStyle", iconAction_r35.styleToggleOff);
    ɵɵadvance();
    ɵɵtextInterpolate(iconAction_r35.iconToggleOff);
  }
}
function DynamictableComponent_ng_container_7_td_2_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r34 = ɵɵgetCurrentView();
    ɵɵelementContainerStart(0);
    ɵɵelementStart(1, "button", 116);
    ɵɵlistener("click", function DynamictableComponent_ng_container_7_td_2_ng_container_2_Template_button_click_1_listener() {
      const iconAction_r35 = ɵɵrestoreView(_r34).$implicit;
      const row_r36 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onRowLevelActionIconClick(iconAction_r35, row_r36));
    });
    ɵɵtemplate(2, DynamictableComponent_ng_container_7_td_2_ng_container_2_mat_icon_2_Template, 2, 2, "mat-icon", 117)(3, DynamictableComponent_ng_container_7_td_2_ng_container_2_mat_icon_3_Template, 2, 2, "mat-icon", 118);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const iconAction_r35 = ctx.$implicit;
    const row_r36 = ɵɵnextContext().$implicit;
    ɵɵadvance(2);
    ɵɵproperty("ngIf", row_r36[iconAction_r35.property]);
    ɵɵadvance();
    ɵɵproperty("ngIf", !row_r36[iconAction_r35.property]);
  }
}
function DynamictableComponent_ng_container_7_td_2_ng_container_8_ng_container_1_button_1_mat_icon_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "mat-icon", 125);
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const action_r40 = ɵɵnextContext(3).$implicit;
    ɵɵproperty("ngClass", ɵɵpureFunction1(2, _c35, action_r40.title === "Delete" || action_r40.title === "Deactivate" || action_r40.title === "Archive"));
    ɵɵadvance();
    ɵɵtextInterpolate(action_r40.icon);
  }
}
function DynamictableComponent_ng_container_7_td_2_ng_container_8_ng_container_1_button_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r39 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 122);
    ɵɵlistener("click", function DynamictableComponent_ng_container_7_td_2_ng_container_8_ng_container_1_button_1_Template_button_click_0_listener() {
      ɵɵrestoreView(_r39);
      const action_r40 = ɵɵnextContext(2).$implicit;
      const row_r36 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onRowLevelActionClick(action_r40, row_r36));
    });
    ɵɵtemplate(1, DynamictableComponent_ng_container_7_td_2_ng_container_8_ng_container_1_button_1_mat_icon_1_Template, 2, 4, "mat-icon", 123);
    ɵɵelementStart(2, "span", 124);
    ɵɵtext(3);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const action_r40 = ɵɵnextContext(2).$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", action_r40.icon);
    ɵɵadvance();
    ɵɵproperty("ngClass", ɵɵpureFunction1(3, _c35, action_r40.title === "Delete" || action_r40.title === "Deactivate" || action_r40.title === "Archive"));
    ɵɵadvance();
    ɵɵtextInterpolate(action_r40.title);
  }
}
function DynamictableComponent_ng_container_7_td_2_ng_container_8_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, DynamictableComponent_ng_container_7_td_2_ng_container_8_ng_container_1_button_1_Template, 4, 5, "button", 121);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const action_r40 = ɵɵnextContext().$implicit;
    const row_r36 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", !action_r40.condition || action_r40.condition && ctx_r1.evaluateCondition(row_r36, action_r40));
  }
}
function DynamictableComponent_ng_container_7_td_2_ng_container_8_ng_container_2_button_1_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "button", 128)(1, "span", 129);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    ɵɵnextContext();
    const nestedMenu_r41 = ɵɵreference(3);
    const action_r40 = ɵɵnextContext().$implicit;
    ɵɵproperty("matMenuTriggerFor", nestedMenu_r41);
    ɵɵadvance(2);
    ɵɵtextInterpolate(action_r40.title);
  }
}
function DynamictableComponent_ng_container_7_td_2_ng_container_8_ng_container_2_button_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r42 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 130);
    ɵɵlistener("click", function DynamictableComponent_ng_container_7_td_2_ng_container_8_ng_container_2_button_4_Template_button_click_0_listener() {
      const subMenu_r43 = ɵɵrestoreView(_r42).$implicit;
      const action_r40 = ɵɵnextContext(2).$implicit;
      const row_r36 = ɵɵnextContext().$implicit;
      const ctx_r1 = ɵɵnextContext(2);
      return ɵɵresetView(ctx_r1.onRowLevelActionClick(action_r40, row_r36, subMenu_r43));
    });
    ɵɵtext(1);
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const subMenu_r43 = ctx.$implicit;
    ɵɵadvance();
    ɵɵtextInterpolate1(" ", subMenu_r43, " ");
  }
}
function DynamictableComponent_ng_container_7_td_2_ng_container_8_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, DynamictableComponent_ng_container_7_td_2_ng_container_8_ng_container_2_button_1_Template, 3, 2, "button", 126);
    ɵɵelementStart(2, "mat-menu", null, 5);
    ɵɵtemplate(4, DynamictableComponent_ng_container_7_td_2_ng_container_8_ng_container_2_button_4_Template, 2, 1, "button", 127);
    ɵɵelementEnd();
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const action_r40 = ɵɵnextContext().$implicit;
    const row_r36 = ɵɵnextContext().$implicit;
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance();
    ɵɵproperty("ngIf", !action_r40.condition || action_r40.condition && ctx_r1.evaluateCondition(row_r36, action_r40));
    ɵɵadvance(3);
    ɵɵproperty("ngForOf", action_r40.menuValues);
  }
}
function DynamictableComponent_ng_container_7_td_2_ng_container_8_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0);
    ɵɵtemplate(1, DynamictableComponent_ng_container_7_td_2_ng_container_8_ng_container_1_Template, 2, 1, "ng-container", 35)(2, DynamictableComponent_ng_container_7_td_2_ng_container_8_ng_container_2_Template, 5, 2, "ng-container", 35);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    const action_r40 = ctx.$implicit;
    ɵɵadvance();
    ɵɵproperty("ngIf", action_r40.type !== "menu");
    ɵɵadvance();
    ɵɵproperty("ngIf", action_r40.type === "menu");
  }
}
function DynamictableComponent_ng_container_7_td_2_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 112)(1, "div", 113);
    ɵɵtemplate(2, DynamictableComponent_ng_container_7_td_2_ng_container_2_Template, 4, 2, "ng-container", 35);
    ɵɵelementStart(3, "button", 114)(4, "mat-icon", 115);
    ɵɵtext(5, "more_horiz");
    ɵɵelementEnd()();
    ɵɵelementStart(6, "mat-menu", null, 4);
    ɵɵtemplate(8, DynamictableComponent_ng_container_7_td_2_ng_container_8_Template, 3, 2, "ng-container", 89);
    ɵɵelementEnd()()();
  }
  if (rf & 2) {
    const row_r36 = ctx.$implicit;
    const actionsMenu_r44 = ɵɵreference(7);
    const ctx_r1 = ɵɵnextContext(2);
    ɵɵadvance(2);
    ɵɵproperty("ngIf", ctx_r1.configOptions.rowLevelActions.iconAction);
    ɵɵadvance();
    ɵɵproperty("matMenuTriggerFor", actionsMenu_r44)("disabled", !ctx_r1.evaluateCondition(row_r36, ctx_r1.configOptions.enableRowLevelActions));
    ɵɵadvance(5);
    ɵɵproperty("ngForOf", ctx_r1.configOptions.rowLevelActions.menuActions);
  }
}
function DynamictableComponent_ng_container_7_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementContainerStart(0, 109);
    ɵɵtemplate(1, DynamictableComponent_ng_container_7_th_1_Template, 2, 0, "th", 110)(2, DynamictableComponent_ng_container_7_td_2_Template, 9, 4, "td", 14);
    ɵɵelementContainerEnd();
  }
  if (rf & 2) {
    ɵɵproperty("stickyEnd", true);
  }
}
function DynamictableComponent_td_9_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "td", 112)(1, "div", 131)(2, "div", 132)(3, "div", 133);
    ɵɵtext(4);
    ɵɵelementEnd();
    ɵɵelementStart(5, "div", 134);
    ɵɵtext(6);
    ɵɵelementEnd();
    ɵɵelementStart(7, "div", 135);
    ɵɵtext(8);
    ɵɵelementEnd();
    ɵɵelementStart(9, "div", 136);
    ɵɵtext(10);
    ɵɵelementEnd()();
    ɵɵelementStart(11, "div", 137);
    ɵɵtext(12);
    ɵɵelementStart(13, "span", 138);
    ɵɵtext(14, " -- Wikipedia ");
    ɵɵelementEnd()()()();
  }
  if (rf & 2) {
    const element_r45 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵattribute("colspan", ctx_r1.columnsToDisplay.length);
    ɵɵadvance();
    ɵɵproperty("@detailExpand", element_r45 == ctx_r1.expandedElement ? "expanded" : "collapsed");
    ɵɵadvance(3);
    ɵɵtextInterpolate1(" ", element_r45.name, " ");
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", element_r45.progress, " ");
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", element_r45.fruit, " ");
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", element_r45.id, " ");
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", element_r45.name, " ");
  }
}
function DynamictableComponent_tr_10_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 139);
  }
}
function DynamictableComponent_tr_11_Template(rf, ctx) {
  if (rf & 1) {
    const _r46 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "tr", 140);
    ɵɵlistener("click", function DynamictableComponent_tr_11_Template_tr_click_0_listener() {
      const row_r47 = ɵɵrestoreView(_r46).$implicit;
      const ctx_r1 = ɵɵnextContext();
      ctx_r1.expandedElement = ctx_r1.expandedElement === row_r47 ? null : row_r47;
      return ɵɵresetView(ctx_r1.highlight(row_r47));
    });
    ɵɵelementEnd();
  }
  if (rf & 2) {
    const row_r47 = ctx.$implicit;
    const ctx_r1 = ɵɵnextContext();
    ɵɵclassProp("example-expanded-row", ctx_r1.expandedElement === row_r47);
    ɵɵproperty("ngClass", ɵɵpureFunction1(3, _c44, ctx_r1.selectedRowIndex == (row_r47 == null ? null : row_r47.id)));
  }
}
function DynamictableComponent_tr_12_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "tr", 141);
  }
}
function DynamictableComponent_div_13_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelementStart(0, "div", 142)(1, "span", 143);
    ɵɵtext(2);
    ɵɵelementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = ɵɵnextContext();
    ɵɵadvance(2);
    ɵɵtextInterpolate1(" ", (ctx_r1.configOptions == null ? null : ctx_r1.configOptions.noDataText) ? ctx_r1.configOptions == null ? null : ctx_r1.configOptions.noDataText : "No Data Found", " ");
  }
}
function DynamictableComponent_mat_paginator_14_Template(rf, ctx) {
  if (rf & 1) {
    ɵɵelement(0, "mat-paginator", 144);
  }
  if (rf & 2) {
    ɵɵproperty("pageSizeOptions", ɵɵpureFunction0(1, _c52));
  }
}
var Constants = {
  ADD_GROUP: "ADD_GROUP",
  REMOVE_GROUP: "REMOVE_GROUP",
  ADD_COLUMN: "ADD_COLUMN",
  REMOVE_COLUMN: "REMOVE_COLUMN",
  REFRESH_CONFIG: "REFRESH_CONFIG",
  // TOGGLE_COLUMN:'TOGGLE_COLUMN',
  REFRESH_FILTER_PANEL: "REFRESH_FILTER_PANEL",
  WRITE_TO_UNDO_REDO: "WRITE_TO_UNDO_REDO",
  EXECUTE_UNDO: "EXECUTE_UNDO",
  EXECUTE_REDO: "EXECUTE_REDO"
};
var DynamictableFilterService = class {
  constructor() {
    this.tableLeftPanelEventEmitter = new EventEmitter();
  }
  emitEvent(data) {
    this.tableLeftPanelEventEmitter.emit(data);
  }
  getEventEmitter() {
    return this.tableLeftPanelEventEmitter;
  }
};
DynamictableFilterService.ɵfac = function DynamictableFilterService_Factory(ɵt) {
  return new (ɵt || DynamictableFilterService)();
};
DynamictableFilterService.ɵprov = ɵɵdefineInjectable({
  token: DynamictableFilterService,
  factory: DynamictableFilterService.ɵfac,
  providedIn: "root"
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DynamictableFilterService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [];
  }, null);
})();
var DynamictableScrollerService = class {
  constructor() {
    this.scrollEventEmitter = new EventEmitter();
  }
  emitEvent(data) {
    this.scrollEventEmitter.emit(data);
  }
  getEventEmitter() {
    return this.scrollEventEmitter;
  }
};
DynamictableScrollerService.ɵfac = function DynamictableScrollerService_Factory(ɵt) {
  return new (ɵt || DynamictableScrollerService)();
};
DynamictableScrollerService.ɵprov = ɵɵdefineInjectable({
  token: DynamictableScrollerService,
  factory: DynamictableScrollerService.ɵfac,
  providedIn: "root"
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DynamictableScrollerService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], function() {
    return [];
  }, null);
})();
var TableFilterPanelComponent = class {
  constructor(_snackBar, changeDetectorRefs, dynamictableFilterService) {
    this._snackBar = _snackBar;
    this.changeDetectorRefs = changeDetectorRefs;
    this.dynamictableFilterService = dynamictableFilterService;
    this.horizontalPosition = "center";
    this.verticalPosition = "top";
    this.addGroupUpdate = new Subject();
    this.addColumnUpdate = new Subject();
    this.groupedColumns = new Array();
    this.visibleColumns = new Array();
    this.addGroupUpdate.pipe(debounceTime(50), distinctUntilChanged()).subscribe((value) => {
      if (value === "") {
        let _filtered = this.configOptions.allColumns.filter((x) => x.groupable && x.visible);
        this.filteredGroupableColumns = _filtered;
        this.changeDetectorRefs.detectChanges();
      } else {
        let _filtered = this.configOptions.allColumns.filter((column) => {
          let index = this.groupedColumns.findIndex((x) => x.id === column.id);
          return index < 0 && column.visible && column.groupable && column.displayName?.toLowerCase()?.indexOf(value?.toLocaleLowerCase()) > -1;
        });
        this.filteredGroupableColumns = _filtered;
        this.changeDetectorRefs.detectChanges();
      }
    });
    this.addColumnUpdate.pipe(debounceTime(50), distinctUntilChanged()).subscribe((value) => {
      if (value === "") {
        this.filteredAllColumns = this.configOptions.allColumns;
        this.changeDetectorRefs.detectChanges();
      } else {
        let _filtered = this.configOptions.allColumns.filter((column) => column.displayName.toLocaleLowerCase().indexOf(value?.toLocaleLowerCase()) > -1);
        this.filteredAllColumns = _filtered;
        this.changeDetectorRefs.detectChanges();
      }
    });
  }
  refreshFilterPanel() {
    this.configOptions = __spreadValues({}, this.configOptions);
    this.groupableColumns = this.configOptions.allColumns.filter((column) => column["visible"] && column["groupable"]);
    this.visibleColumns = this.configOptions.allColumns.filter((column) => column["visible"]);
    this.groupedColumns = [];
    this.configOptions.groupByColumns.forEach((column) => {
      let index = this.groupableColumns.findIndex((x) => x.id === column);
      if (index > -1) {
        this.groupedColumns.push(this.groupableColumns[index]);
        this.groupableColumns.splice(index, 1);
      }
    });
    this.filteredGroupableColumns = this.groupableColumns;
    this.filteredAllColumns = this.configOptions.allColumns;
    this.displayedColumns = this.configOptions.allColumns.filter((column) => column["visible"]);
    this.changeDetectorRefs.detectChanges();
  }
  displayFn(reportColumn) {
    return "";
  }
  ngOnInit() {
    this.refreshFilterPanel();
    this.subscription = this.dynamictableFilterService.getEventEmitter().subscribe((eventData) => {
      this.handleEvent(eventData);
    });
  }
  ngOnChanges(changes) {
    if (changes && changes["configOptions"] && !changes["configOptions"].firstChange) {
      this.refreshFilterPanel();
    }
  }
  handleEvent(event) {
    if (event.eventType === Constants.REFRESH_FILTER_PANEL) {
      this.refreshFilterPanel();
    }
  }
  addGroup(column) {
    this.dynamictableFilterService.emitEvent({
      eventType: Constants.ADD_GROUP,
      data: column
    });
    this.groupSearchKey = "";
  }
  removeGroup(event, column) {
    event.stopPropagation();
    this.dynamictableFilterService.emitEvent({
      eventType: Constants.REMOVE_GROUP,
      data: column
    });
  }
  openSnackBar(message) {
    this._snackBar.open(message, "", {
      horizontalPosition: this.horizontalPosition,
      verticalPosition: this.verticalPosition,
      duration: 5e3
      // 5 milliseconds
    });
  }
  optionClicked(item) {
    item.visible = !item.visible;
    this.toggleColumnVisibility(item.visible, item.id);
  }
  toggleColumnVisibility(isChecked, columnId) {
    this.visibleColumns = this.configOptions.allColumns.filter((column) => column["visible"]);
    if (!isChecked && this.visibleColumns.length == 1) {
      this.filteredAllColumns.forEach((col) => {
        if (col.id === columnId) {
          col.visible = true;
        }
      });
      this.displayedColumns.forEach((col) => {
        if (col.id === columnId) {
          col.visible = true;
        }
      });
      this.openSnackBar("Please make sure to have aleast one column in the report!");
      return;
    }
    this.dynamictableFilterService.emitEvent({
      eventType: isChecked ? Constants.ADD_COLUMN : Constants.REMOVE_COLUMN,
      data: {
        isChecked,
        columnId
      }
    });
    this.columnSearchKey = "";
  }
};
TableFilterPanelComponent.ɵfac = function TableFilterPanelComponent_Factory(ɵt) {
  return new (ɵt || TableFilterPanelComponent)(ɵɵdirectiveInject(MatSnackBar), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(DynamictableFilterService));
};
TableFilterPanelComponent.ɵcmp = ɵɵdefineComponent({
  type: TableFilterPanelComponent,
  selectors: [["cwp-table-filter-panel"]],
  inputs: {
    configOptions: "configOptions"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 34,
  vars: 10,
  consts: [["inputTrigger", ""], ["autoCompleteGroups", "matAutocomplete"], ["inputColumn", ""], ["autoCompleteColumns", "matAutocomplete"], [1, "groupBySection"], ["id", "tableFilterPanelByField"], ["appearance", "outline", 1, "width-100", "outline-fields"], ["id", "tableFilterPanelSearchIcon", "matPrefix", ""], ["type", "text", "placeholder", "Add Group", "matInput", "", 3, "ngModelChange", "matAutocomplete", "ngModel"], [3, "optionSelected", "displayWith"], [3, "disabled", "value", 4, "ngFor", "ngForOf"], ["role", "list", 1, "groupBySectionScroll"], ["role", "listitem", "class", "columnListItem", 4, "ngFor", "ngForOf"], ["id", "tableFilterPanelRows", 1, "warning-group-message"], [1, "tableColumns"], ["id", "tableFilterPanelCol"], ["id", "tableFilterPanelSearch", "matPrefix", ""], ["type", "text", "placeholder", "Select Columns", "matInput", "", 3, "ngModelChange", "matAutocomplete", "ngModel"], [3, "value", 4, "ngFor", "ngForOf"], ["role", "list", 1, "tableColumnsScroll"], [3, "disabled", "value"], [3, "click"], ["id", "tableFilterPanelName"], ["role", "listitem", 1, "columnListItem"], [1, "listItemContent"], ["id", "tableFilterPanelColName", 1, "groupby-name"], ["id", "tableFilterPanelCloseIcon", 1, "smallIcon", 3, "click"], [3, "value"], [3, "change", "checked"], ["disableRipple", "", 3, "change", "checked"]],
  template: function TableFilterPanelComponent_Template(rf, ctx) {
    if (rf & 1) {
      const _r1 = ɵɵgetCurrentView();
      ɵɵelementStart(0, "div")(1, "div", 4)(2, "label", 5)(3, "b");
      ɵɵtext(4, "Group by Fields");
      ɵɵelementEnd()();
      ɵɵelement(5, "br");
      ɵɵelementStart(6, "mat-form-field", 6)(7, "mat-icon", 7);
      ɵɵtext(8, "search");
      ɵɵelementEnd();
      ɵɵelementStart(9, "input", 8, 0);
      ɵɵtwoWayListener("ngModelChange", function TableFilterPanelComponent_Template_input_ngModelChange_9_listener($event) {
        ɵɵrestoreView(_r1);
        ɵɵtwoWayBindingSet(ctx.groupSearchKey, $event) || (ctx.groupSearchKey = $event);
        return ɵɵresetView($event);
      });
      ɵɵlistener("ngModelChange", function TableFilterPanelComponent_Template_input_ngModelChange_9_listener() {
        ɵɵrestoreView(_r1);
        const inputTrigger_r2 = ɵɵreference(10);
        return ɵɵresetView(ctx.addGroupUpdate.next(inputTrigger_r2.value));
      });
      ɵɵelementEnd();
      ɵɵelementStart(11, "mat-autocomplete", 9, 1);
      ɵɵlistener("optionSelected", function TableFilterPanelComponent_Template_mat_autocomplete_optionSelected_11_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.addGroup($event.option.value));
      });
      ɵɵtemplate(13, TableFilterPanelComponent_mat_option_13_Template, 4, 3, "mat-option", 10);
      ɵɵelementEnd()();
      ɵɵelementStart(14, "mat-list", 11);
      ɵɵtemplate(15, TableFilterPanelComponent_mat_list_item_15_Template, 6, 1, "mat-list-item", 12);
      ɵɵelementEnd();
      ɵɵelementStart(16, "p", 13);
      ɵɵtext(17, " Can add only upto 3 Rows ");
      ɵɵelementEnd()();
      ɵɵelementStart(18, "div", 14)(19, "label", 15)(20, "b");
      ɵɵtext(21, "Columns");
      ɵɵelementEnd()();
      ɵɵelement(22, "br");
      ɵɵelementStart(23, "mat-form-field", 6)(24, "mat-icon", 16);
      ɵɵtext(25, "search");
      ɵɵelementEnd();
      ɵɵelementStart(26, "input", 17, 2);
      ɵɵtwoWayListener("ngModelChange", function TableFilterPanelComponent_Template_input_ngModelChange_26_listener($event) {
        ɵɵrestoreView(_r1);
        ɵɵtwoWayBindingSet(ctx.columnSearchKey, $event) || (ctx.columnSearchKey = $event);
        return ɵɵresetView($event);
      });
      ɵɵlistener("ngModelChange", function TableFilterPanelComponent_Template_input_ngModelChange_26_listener() {
        ɵɵrestoreView(_r1);
        const inputColumn_r8 = ɵɵreference(27);
        return ɵɵresetView(ctx.addColumnUpdate.next(inputColumn_r8.value));
      });
      ɵɵelementEnd();
      ɵɵelementStart(28, "mat-autocomplete", 9, 3);
      ɵɵlistener("optionSelected", function TableFilterPanelComponent_Template_mat_autocomplete_optionSelected_28_listener($event) {
        ɵɵrestoreView(_r1);
        return ɵɵresetView(ctx.optionClicked($event.option.value));
      });
      ɵɵtemplate(30, TableFilterPanelComponent_mat_option_30_Template, 4, 3, "mat-option", 18);
      ɵɵelementEnd()();
      ɵɵelement(31, "br");
      ɵɵelementStart(32, "mat-list", 19);
      ɵɵtemplate(33, TableFilterPanelComponent_mat_list_item_33_Template, 4, 2, "mat-list-item", 12);
      ɵɵelementEnd()()();
    }
    if (rf & 2) {
      const autoCompleteGroups_r13 = ɵɵreference(12);
      const autoCompleteColumns_r14 = ɵɵreference(29);
      ɵɵadvance(9);
      ɵɵproperty("matAutocomplete", autoCompleteGroups_r13);
      ɵɵtwoWayProperty("ngModel", ctx.groupSearchKey);
      ɵɵadvance(2);
      ɵɵproperty("displayWith", ctx.displayFn);
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.filteredGroupableColumns);
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.groupedColumns);
      ɵɵadvance(11);
      ɵɵproperty("matAutocomplete", autoCompleteColumns_r14);
      ɵɵtwoWayProperty("ngModel", ctx.columnSearchKey);
      ɵɵadvance(2);
      ɵɵproperty("displayWith", ctx.displayFn);
      ɵɵadvance(2);
      ɵɵproperty("ngForOf", ctx.filteredAllColumns);
      ɵɵadvance(3);
      ɵɵproperty("ngForOf", ctx.configOptions.allColumns);
    }
  },
  dependencies: [MatFormField, MatIcon, MatAutocomplete, MatOption, MatList, MatListItem, MatCheckbox, MatPrefix, MatInput, MatAutocompleteTrigger, DefaultValueAccessor, NgControlStatus, NgModel, NgForOf],
  styles: [".groupBySection[_ngcontent-%COMP%]{padding:10px;border:1px solid #b0b0b0;border-radius:5px;margin:5px 0}.groupBySectionScroll[_ngcontent-%COMP%]{max-height:180px;overflow-y:scroll;overflow-x:hidden;padding:0}.columnListItem[_ngcontent-%COMP%]{background:#f0f2ff;border:1px solid #f2f2f2;padding:5px!important;width:94%!important;font-size:10pt;height:25px!important;margin:1px}.listItemContent[_ngcontent-%COMP%]{display:flex;flex-wrap:wrap;justify-content:space-between;align-content:center;width:100%}.groupby-name[_ngcontent-%COMP%]{position:relative;top:5px}.smallIcon[_ngcontent-%COMP%]{transform:scale(.75);cursor:pointer}.tableColumns[_ngcontent-%COMP%]{padding:10px;border:1px solid #b0b0b0;border-radius:5px;margin:5px 0}.tableColumnsScroll[_ngcontent-%COMP%]{height:180px;overflow-y:scroll;overflow-x:hidden;padding:0}.width-100[_ngcontent-%COMP%]{width:100%}.warning-group-message[_ngcontent-%COMP%]{margin:10px 0 0 5px;color:#757575;font-size:80%}"],
  changeDetection: 0
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableFilterPanelComponent, [{
    type: Component,
    args: [{
      selector: "cwp-table-filter-panel",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: `<div>
  <div class="groupBySection">
    <label id="tableFilterPanelByField"><b>Group by Fields</b></label
    ><br />
    <mat-form-field appearance="outline" class="width-100 outline-fields">
      <mat-icon id="tableFilterPanelSearchIcon" matPrefix>search</mat-icon>
      <input
        type="text"
        #inputTrigger
        placeholder="Add Group"
        matInput
        [matAutocomplete]="autoCompleteGroups"
        [(ngModel)]="groupSearchKey"
        (ngModelChange)="addGroupUpdate.next(inputTrigger.value)"
      />
      <mat-autocomplete
        #autoCompleteGroups="matAutocomplete"
        [displayWith]="displayFn"
        (optionSelected)="addGroup($event.option.value)"
      >
        <mat-option
          *ngFor="let item of filteredGroupableColumns"
          [disabled]="this.configOptions.groupByColumns.length >= 3"
          [value]="item"
        >
          <div (click)="addGroup(item)">
            <span id="tableFilterPanelName">{{ item.displayName }}</span>
          </div>
        </mat-option>
      </mat-autocomplete>
    </mat-form-field>
    <mat-list role="list" class="groupBySectionScroll">
      <mat-list-item
        role="listitem"
        *ngFor="let column of groupedColumns"
        class="columnListItem"
      >
        <div class="listItemContent">
          <span id="tableFilterPanelColName" class="groupby-name">
            {{ column.displayName }}
          </span>
          <mat-icon
            id="tableFilterPanelCloseIcon"
            class="smallIcon"
            (click)="removeGroup($event, column)"
          >
            close
          </mat-icon>
        </div>
      </mat-list-item>
    </mat-list>
    <p id="tableFilterPanelRows" class="warning-group-message">
      Can add only upto 3 Rows
    </p>
  </div>
  <div class="tableColumns">
    <label id="tableFilterPanelCol"><b>Columns</b></label>
    <br />
    <mat-form-field appearance="outline" class="width-100 outline-fields">
      <mat-icon id="tableFilterPanelSearch" matPrefix>search</mat-icon>
      <input
        type="text"
        placeholder="Select Columns"
        matInput
        #inputColumn
        [matAutocomplete]="autoCompleteColumns"
        [(ngModel)]="columnSearchKey"
        (ngModelChange)="addColumnUpdate.next(inputColumn.value)"
      />
      <mat-autocomplete
        #autoCompleteColumns="matAutocomplete"
        [displayWith]="displayFn"
        (optionSelected)="optionClicked($event.option.value)"
      >
        <mat-option *ngFor="let item of filteredAllColumns" [value]="item">
          <div (click)="optionClicked(item)">
            <mat-checkbox
              [checked]="item.visible"
              (change)="toggleColumnVisibility($event.checked, item.id)"
            >
              {{ item.displayName }}
            </mat-checkbox>
          </div>
        </mat-option>
      </mat-autocomplete>
    </mat-form-field>
    <br />
    <mat-list role="list" class="tableColumnsScroll">
      <mat-list-item
        role="listitem"
        *ngFor="let column of configOptions.allColumns"
        class="columnListItem"
      >
        <div class="listItemContent">
          <mat-checkbox
            disableRipple
            (change)="toggleColumnVisibility($event.checked, column['id'])"
            [checked]="column['visible']"
          >
            {{ column.displayName }}
          </mat-checkbox>
        </div>
      </mat-list-item>
    </mat-list>
  </div>
</div>
`,
      styles: [".groupBySection{padding:10px;border:1px solid #b0b0b0;border-radius:5px;margin:5px 0}.groupBySectionScroll{max-height:180px;overflow-y:scroll;overflow-x:hidden;padding:0}.columnListItem{background:#f0f2ff;border:1px solid #f2f2f2;padding:5px!important;width:94%!important;font-size:10pt;height:25px!important;margin:1px}.listItemContent{display:flex;flex-wrap:wrap;justify-content:space-between;align-content:center;width:100%}.groupby-name{position:relative;top:5px}.smallIcon{transform:scale(.75);cursor:pointer}.tableColumns{padding:10px;border:1px solid #b0b0b0;border-radius:5px;margin:5px 0}.tableColumnsScroll{height:180px;overflow-y:scroll;overflow-x:hidden;padding:0}.width-100{width:100%}.warning-group-message{margin:10px 0 0 5px;color:#757575;font-size:80%}\n"]
    }]
  }], function() {
    return [{
      type: MatSnackBar
    }, {
      type: ChangeDetectorRef
    }, {
      type: DynamictableFilterService
    }];
  }, {
    configOptions: [{
      type: Input
    }]
  });
})();
var TimeAgoPipe = class {
  constructor(ngZone, changeDetectorRef) {
    this.ngZone = ngZone;
    this.changeDetectorRef = changeDetectorRef;
  }
  ngOnDestroy() {
    this.removeTimer();
  }
  transform(value) {
    this.removeTimer();
    const value1 = value?.replace("T", " ").replace(".000Z", "");
    const d = new Date(value1);
    const now = /* @__PURE__ */ new Date();
    const seconds = Math.round(Math.abs((now.getTime() - d.getTime()) / 1e3));
    const timeToUpdate = Number.isNaN(seconds) ? 1e3 : this.getSecondsUntilUpdate(seconds) * 1e3;
    this.timer = this.ngZone.runOutsideAngular(() => {
      if (typeof window !== "undefined") {
        return window.setTimeout(() => {
          this.ngZone.run(() => this.changeDetectorRef.markForCheck());
        }, timeToUpdate);
      }
      return null;
    });
    const minutes = Math.round(Math.abs(seconds / 60));
    const hours = Math.round(Math.abs(minutes / 60));
    const days = Math.round(Math.abs(hours / 24));
    const months = Math.round(Math.abs(days / 30.416));
    const years = Math.round(Math.abs(days / 365));
    if (Number.isNaN(seconds)) {
      return "";
    } else if (seconds <= 45) {
      return "Just now";
    } else if (minutes <= 3) {
      return "Just now";
    } else if (minutes <= 45) {
      return minutes + " minutes ago";
    } else if (minutes <= 90) {
      return "An hour ago";
    } else if (hours <= 22) {
      return "Today";
    } else if (hours <= 36) {
      return "Yesterday";
    } else if (days <= 25) {
      return days + " days ago";
    } else if (days <= 45) {
      return "A month ago";
    } else if (days <= 345) {
      return months + " months ago";
    } else if (days <= 545) {
      return "A year ago";
    } else {
      return years + " years ago";
    }
  }
  removeTimer() {
    if (this.timer) {
      window.clearTimeout(this.timer);
      this.timer = null;
    }
  }
  getSecondsUntilUpdate(seconds) {
    const min = 60;
    const hr = min * 60;
    const day = hr * 24;
    if (seconds < min) {
      return 2;
    } else if (seconds < hr) {
      return 30;
    } else if (seconds < day) {
      return 300;
    } else {
      return 3600;
    }
  }
};
TimeAgoPipe.ɵfac = function TimeAgoPipe_Factory(ɵt) {
  return new (ɵt || TimeAgoPipe)(ɵɵdirectiveInject(NgZone, 16), ɵɵdirectiveInject(ChangeDetectorRef, 16));
};
TimeAgoPipe.ɵpipe = ɵɵdefinePipe({
  name: "timeAgo",
  type: TimeAgoPipe,
  pure: false
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimeAgoPipe, [{
    type: Pipe,
    args: [{
      name: "timeAgo",
      pure: false
    }]
  }], function() {
    return [{
      type: NgZone
    }, {
      type: ChangeDetectorRef
    }];
  }, null);
})();
var DynamicTypePipe = class {
  constructor(timeAgoPipe) {
    this.timeAgoPipe = timeAgoPipe;
  }
  transform(val, pipeType) {
    switch (pipeType) {
      case "date":
        val = new DatePipe("en-US").transform(val, "short");
        break;
      case "timeAgo":
        val = this.timeAgoPipe.transform(val);
        break;
      default:
    }
    return val;
  }
};
DynamicTypePipe.ɵfac = function DynamicTypePipe_Factory(ɵt) {
  return new (ɵt || DynamicTypePipe)(ɵɵdirectiveInject(TimeAgoPipe, 16));
};
DynamicTypePipe.ɵpipe = ɵɵdefinePipe({
  name: "dynamicTypePipe",
  type: DynamicTypePipe,
  pure: true
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DynamicTypePipe, [{
    type: Pipe,
    args: [{
      name: "dynamicTypePipe"
    }]
  }], function() {
    return [{
      type: TimeAgoPipe
    }];
  }, null);
})();
var DynamictableComponent = class {
  constructor(_snackBar, changeDetectorRefs, dynamictableFilterService, domSanitizer, dynamictableScrollerService) {
    this._snackBar = _snackBar;
    this.changeDetectorRefs = changeDetectorRefs;
    this.dynamictableFilterService = dynamictableFilterService;
    this.domSanitizer = domSanitizer;
    this.dynamictableScrollerService = dynamictableScrollerService;
    this.horizontalPosition = "center";
    this.verticalPosition = "top";
    this.spans = [];
    this.selectedRows = [];
    this.opened = false;
    this.lastScrollLeft = 0;
    this.stickyColumns = [];
    this.stickyEndColumns = [];
    this.selectedRowIndex = -1;
    this.reverseSortColumns = {};
    this.fetchDataCallback = new EventEmitter();
    this.rowLevelActionHandler = new EventEmitter();
    this.cellClickActionHandler = new EventEmitter();
    this.onConfigOptionsChange = new EventEmitter();
    this.onToggleChangeHandler = new EventEmitter();
    this.onSelectButtonToggle = new EventEmitter();
    this.visibleColumns = new Array();
    this.customWhen = (index) => {
      return this.configOptions.rowsExpandable;
    };
  }
  set configOptions(configOptions) {
    this._configOptions = configOptions ? __spreadValues({}, configOptions) : {};
  }
  get configOptions() {
    return this._configOptions;
  }
  set dataSource(dataSource) {
    this._dataSource = dataSource ? dataSource : {};
    this.dataSource.paginator = this.paginator;
    this.selectedRows = this.dataSource?.data.filter((data) => data?.isSelected);
  }
  get dataSource() {
    return this._dataSource;
  }
  resetConfigOptions() {
    this.configOptions = __spreadValues({}, this.configOptions);
    this.setColumnsToDisplay();
    this.visibleColumns = this.configOptions.allColumns.filter((column) => column["visible"]);
    this.configOptions.groupByColumns.forEach((column) => {
      this.reOrderColumns(column, "index");
      this.setColumnsToDisplay();
      this.stick(column);
      this.displayedColumns.forEach((column2) => {
        if (column2.id == column2) {
          column2.sticky = true;
        }
      });
    });
  }
  highlight(row) {
    this.selectedRowIndex = row.id;
  }
  ngOnInit() {
    this.selection = new SelectionModel(true, this.selectedRows);
    this.resetConfigOptions();
    this.subscription = this.dynamictableFilterService.getEventEmitter().subscribe((eventData) => this.handleEvent(eventData));
    this.scrollSubscription = this.dynamictableScrollerService.getEventEmitter().subscribe(() => {
      this.scrollToTop();
    });
    this.dataSource.sortingDataAccessor = (data, sortHeaderId) => {
      const configInfo = this.configOptions.allColumns.filter((item) => item.id === sortHeaderId);
      if (data[sortHeaderId] === null || data[sortHeaderId] === void 0) {
        if (configInfo.type === "string") {
          return "";
        } else if (configInfo.type === "number") {
          return 0;
        }
      }
      if (configInfo.type === "string") {
        return data[sortHeaderId].toLowerCase();
      } else {
        return data[sortHeaderId];
      }
    };
    this.configOptions.allColumns.map((col) => {
      if (col.reverseSort) {
        this.reverseSortColumns[col.id] = 1;
      }
    });
    this.dataSource.sortData = this.sortData();
  }
  sortData() {
    let sortFunction = (items, sort) => {
      if (!sort.active || sort.direction === "") {
        return items;
      }
      return items.sort((a, b) => {
        let comparatorResult = 0;
        const dateTimeRegex = /^(\w{3}\s\d{1,2},\s\d{2,4})\s(\d{1,2}:\d{2}\s[APap][Mm])$/;
        const dateRangeRegex = /^(\w{3} \d{1,2}, \d{2,4}) - (\w{3} \d{1,2}, \d{2,4})$/;
        const column = sort.active;
        if (a[column] === null || a[column] === void 0 || a[column] === "_ _" || a[column].length === 0) return 1;
        if (b[column] === null || b[column] === void 0 || b[column] === "_ _" || b[column].length === 0) return -1;
        if (typeof a[column] === "number" && typeof b[column] === "number") {
          if (this.reverseSortColumns[column]) {
            comparatorResult = b[column] - a[column];
          } else {
            comparatorResult = a[column] - b[column];
          }
          return comparatorResult * (sort.direction == "asc" ? 1 : -1);
        } else if (typeof a[column] === "number") {
          return -1;
        } else if (typeof b[column] === "number") {
          return 1;
        } else if (dateRangeRegex.test(a[column]) && dateRangeRegex.test(b[column])) {
          const date1 = new Date(a[column].split("-")[0].trim()).getTime();
          const date2 = new Date(b[column].split("-")[0].trim()).getTime();
          if (this.reverseSortColumns[column]) {
            comparatorResult = date2 - date1;
          } else {
            comparatorResult = date1 - date2;
          }
          return comparatorResult * (sort.direction == "asc" ? 1 : -1);
        } else if (dateTimeRegex.test(a[column]) && dateTimeRegex.test(b[column])) {
          const date1 = new Date(a[column]).getTime();
          const date2 = new Date(b[column]).getTime();
          if (this.reverseSortColumns[column]) {
            comparatorResult = date2 - date1;
          } else {
            comparatorResult = date1 - date2;
          }
          return comparatorResult * (sort.direction == "asc" ? 1 : -1);
        } else if (Array.isArray(a[column]) && Array.isArray(b[column])) {
          if (this.reverseSortColumns[column]) {
            comparatorResult = b[column][0].localeCompare(a[column][0]);
          } else {
            comparatorResult = a[column][0].localeCompare(b[column][0]);
          }
          return comparatorResult * (sort.direction == "asc" ? 1 : -1);
        } else {
          if (this.reverseSortColumns[column]) {
            comparatorResult = b[column].localeCompare(a[column]);
          } else {
            comparatorResult = a[column].localeCompare(b[column]);
          }
          return comparatorResult * (sort.direction == "asc" ? 1 : -1);
        }
      });
    };
    return sortFunction;
  }
  ngOnChanges(changes) {
    if (changes && changes["dataSource"] && !changes["dataSource"].firstChange) {
      if (changes["dataSource"]["currentValue"].data < changes["dataSource"]["previousValue"].data) {
        this.resetTableScroll();
      }
      const groupedCols = [];
      this.configOptions.allColumns.forEach((col) => {
        if (col.reverseSort) this.reverseSortColumns[col.id] = 1;
        const groupByCols = this.configOptions.groupByColumns;
        const index = groupByCols.indexOf(col.id);
        if (index > -1) {
          groupedCols.push(col);
        }
      });
      if (groupedCols.length) {
        groupedCols.forEach((col) => {
          if (col.isMultiValued) {
            this.dataSource.data = this.expandRowsForMultiValuedCols(col.id);
          }
        });
      }
      this.dataSource.sortingDataAccessor = (data, sortHeaderId) => {
        const configInfo = this.configOptions.allColumns.filter((item) => item.id === sortHeaderId);
        if (data[sortHeaderId] === null || data[sortHeaderId] === void 0) {
          if (configInfo.type === "string") {
            return "";
          } else if (configInfo.type === "number") {
            return 0;
          }
        }
        if (configInfo.type === "string") {
          return data[sortHeaderId].toLowerCase();
        } else {
          return data[sortHeaderId];
        }
      };
      this.dataSource.sortData = this.sortData();
      this.dataSource.sort = this.sort;
      this.resetSelection();
      this.repaintTable();
    }
    if (changes && changes["configOptions"] && !changes["configOptions"].firstChange) {
      this.resetConfigOptions();
    }
    if (changes && changes["configOptions"] && changes["configOptions"].firstChange) {
      this.configOptions.allColumns.forEach((col) => {
        col.originalOrder = col.order;
      });
    }
  }
  handleEvent(event) {
    switch (event.eventType) {
      case Constants.EXECUTE_UNDO:
        this.triggerUndoExecution(event);
        break;
      case Constants.EXECUTE_REDO:
        this.triggerRedoExecution(event);
        break;
      case Constants.ADD_GROUP:
        this.addGroup(event.data);
        break;
      case Constants.REMOVE_GROUP:
        this.removeGroup(event.data);
        break;
      case Constants.ADD_COLUMN:
        this.toggleColumnVisibility(event.data.isChecked, event.data.columnId);
        break;
      case Constants.REMOVE_COLUMN:
        this.toggleColumnVisibility(event.data.isChecked, event.data.columnId);
        break;
    }
  }
  triggerUndoExecution(event) {
    switch (event.eventName) {
      case Constants.ADD_GROUP:
        this.removeGroup(event.data, void 0, true);
        break;
      case Constants.REMOVE_GROUP:
        this.addGroup(event.data, void 0, true);
        break;
      case Constants.ADD_COLUMN:
        this.toggleColumnVisibility(false, event.data, true);
        break;
      case Constants.REMOVE_COLUMN:
        this.toggleColumnVisibility(true, event.data, true);
        break;
    }
  }
  triggerRedoExecution(event) {
    switch (event.eventName) {
      case Constants.ADD_GROUP:
        this.addGroup(event.data, void 0, true);
        break;
      case Constants.REMOVE_GROUP:
        this.removeGroup(event.data, void 0, true);
        break;
      case Constants.ADD_COLUMN:
        this.toggleColumnVisibility(true, event.data, true);
        break;
      case Constants.REMOVE_COLUMN:
        this.toggleColumnVisibility(false, event.data, true);
        break;
    }
  }
  isGrouped(columnId) {
    let isGrouped = false;
    let groupByCols = this.configOptions.groupByColumns;
    if (groupByCols.indexOf(columnId) > -1) {
      isGrouped = true;
    }
    return isGrouped;
  }
  isArray(object) {
    return Array.isArray(object);
  }
  expandRowsForMultiValuedCols(colId) {
    const dataSourceTemp = [...this.dataSource.data];
    const expandedRows = [];
    dataSourceTemp.forEach((row) => {
      const multiValues = row[colId];
      if (Array.isArray(multiValues)) {
        multiValues.forEach((val) => {
          const expandRowTemp = __spreadValues({}, row);
          expandRowTemp[colId] = val;
          expandedRows.push(expandRowTemp);
        });
      } else {
        expandedRows.push(row);
      }
    });
    return expandedRows;
  }
  mergeRowsForMultiValuedCols(colId) {
    const dataSourceTemp = [...this.dataSource.data];
    const mergedRows = [];
    dataSourceTemp.forEach((row) => {
      const index = mergedRows.findIndex((r) => r.id === row.id);
      if (index > -1) {
        const existingRow = mergedRows[index];
        let multiValuedCol = existingRow[colId];
        if (Array.isArray(multiValuedCol)) {
          multiValuedCol.push(row[colId]);
        } else {
          let tempVal = multiValuedCol;
          multiValuedCol = [tempVal];
          multiValuedCol.push(row[colId]);
        }
        existingRow[colId] = multiValuedCol;
        mergedRows[index] = existingRow;
      } else {
        mergedRows.push(row);
      }
    });
    return mergedRows;
  }
  addGroup(item, event, externalTrigger) {
    if (event) {
      event.stopPropagation();
    }
    if (item.isMultiValued) {
      this.dataSource.data = this.expandRowsForMultiValuedCols(item.id);
    }
    let groupedColIds = this.configOptions.groupByColumns;
    let groupIndex = groupedColIds.indexOf(item.id);
    if (this.configOptions.groupByColumns.length >= 3 || groupIndex > -1) {
      return;
    }
    let _groupedColumnIDs = [...this.configOptions.groupByColumns];
    _groupedColumnIDs.push(item.id);
    this.configOptions.groupByColumns = [..._groupedColumnIDs];
    this.reOrderColumns(item.id, "index");
    this.setColumnsToDisplay();
    this.stick(item.id);
    this.displayedColumns.forEach((column) => {
      if (column.id === item.id) {
        column.sticky = true;
      }
    });
    this.configOptions = __spreadValues({}, this.configOptions);
    this.onConfigOptionsChange.emit({
      eventType: Constants.REFRESH_CONFIG,
      data: this.configOptions
    });
    if (!externalTrigger) {
      this.onConfigOptionsChange.emit({
        eventType: Constants.WRITE_TO_UNDO_REDO,
        eventName: Constants.ADD_GROUP,
        data: item
      });
    }
  }
  removeGroup(item, event, externalTrigger) {
    if (event) {
      event.stopPropagation();
    }
    if (item.isMultiValued) {
      this.dataSource.data = this.mergeRowsForMultiValuedCols(item.id);
    }
    let _groupedColumnIDs = [...this.configOptions.groupByColumns];
    let index = _groupedColumnIDs.findIndex((x) => x === item.id);
    if (index > -1) {
      _groupedColumnIDs.splice(index, 1);
    }
    this.configOptions.groupByColumns = [..._groupedColumnIDs];
    this.reOrderColumns(item.id, "original");
    this.setColumnsToDisplay();
    this.unstick(item.id);
    this.displayedColumns.forEach((column) => {
      if (column.id == item.id) {
        column.sticky = false;
      }
    });
    this.configOptions = __spreadValues({}, this.configOptions);
    this.onConfigOptionsChange.emit({
      eventType: Constants.REFRESH_CONFIG,
      data: this.configOptions
    });
    if (!externalTrigger) {
      this.onConfigOptionsChange.emit({
        eventType: Constants.WRITE_TO_UNDO_REDO,
        eventName: Constants.REMOVE_GROUP,
        data: item
      });
    }
  }
  optionClicked(event, item) {
    event.stopPropagation();
    item.selected = !item.selected;
    if (item.selected) {
      this.toggleColumnVisibility(true, item.id);
    } else {
      this.toggleColumnVisibility(false, item.id);
    }
  }
  onTableScroll(event) {
    let element = event.target;
    let isBottomReached = Math.abs(element.scrollHeight) - Math.abs(element.scrollTop) - Math.abs(element.clientHeight) <= 1;
    let documentScrollLeft = element.scrollLeft;
    if (this.lastScrollLeft !== documentScrollLeft) {
      this.lastScrollLeft = documentScrollLeft;
      return;
    }
    if (isBottomReached) {
      this.fetchDataCallback.emit({
        data: "infiniteScroll"
      });
    }
    this.scrollTop = element.scrollTop;
  }
  onRowLevelActionClick(action, event, subMenu = "subMenu") {
    this.rowLevelActionHandler.emit({
      action: action.action,
      data: event,
      subMenu
    });
  }
  onRowLevelActionIconClick(action, event) {
    this.dataSource.data = this.dataSource.data.map((row) => row.id === event.id ? __spreadProps(__spreadValues({}, row), {
      [action.property]: !row[action.property]
    }) : row);
    this.rowLevelActionHandler.emit({
      action: action.action,
      data: event
    });
  }
  setColumnsToDisplay() {
    this.configOptions.allColumns.sort((a, b) => {
      return a.order - b.order;
    });
    let _displayedColumns = this.configOptions.allColumns.filter((column) => column["visible"]);
    this.displayedColumns = _displayedColumns;
    let _displayedColStrs = _displayedColumns.map((col) => col["id"]);
    if (this.configOptions.enableRowsSelection) {
      this.columnsToDisplay = ["selected", ..._displayedColStrs.slice()];
    } else {
      this.columnsToDisplay = [..._displayedColStrs.slice()];
    }
    if (this.configOptions.displayActionsColumn) {
      this.columnsToDisplay = [...this.columnsToDisplay, "actions"];
    }
    this.configOptions = __spreadValues({}, this.configOptions);
  }
  groupAndSort(data) {
    let _data = [];
    let groupByCols = this.configOptions.groupByColumns;
    if (groupByCols.length > 0) {
      let groupsL0 = this.groupBy(data, groupByCols[0]);
      groupsL0 = Object.values(groupsL0);
      if (groupByCols.length > 1) {
        groupsL0.forEach((rowL0) => {
          let _groupL1 = this.groupBy(rowL0, groupByCols[1]);
          _groupL1 = Object.values(_groupL1);
          if (groupByCols.length > 2) {
            _groupL1.forEach((rowL1) => {
              let _groupL2 = this.groupBy(rowL1, groupByCols[2]);
              _groupL2 = Object.values(_groupL2);
              let arr = [];
              _groupL2.forEach((element) => {
                arr = arr.concat(element);
              });
              _data = _data.concat(...arr);
            });
          } else {
            let arr = [];
            _groupL1.forEach((element) => {
              arr = arr.concat(element);
            });
            _data = _data.concat(...arr);
          }
        });
      } else {
        let arr = [];
        groupsL0.forEach((element) => {
          arr = arr.concat(element);
        });
        _data = _data.concat(...arr);
      }
      this.dataSource.data = _data;
    }
  }
  groupBy(arr, key) {
    let result = arr.reduce(function(r, a) {
      r[a[key]] = r[a[key]] || [];
      r[a[key]].push(a);
      return r;
    }, /* @__PURE__ */ Object.create(null));
    return result;
  }
  cacheSpan(key, groupLevel) {
    const DATA = [...this.dataSource.data];
    for (let i = 0; i < DATA.length; ) {
      let currentValue = DATA[i][key];
      let group0Key;
      let group1Key;
      let group2Key;
      let group0Val;
      let group1Val;
      let group2Val;
      if (groupLevel == 2) {
        group0Key = this.configOptions.groupByColumns[0];
        group1Key = this.configOptions.groupByColumns[1];
        group2Key = this.configOptions.groupByColumns[2];
        group0Val = DATA[i][this.configOptions.groupByColumns[0]];
        group1Val = DATA[i][this.configOptions.groupByColumns[1]];
        group2Val = DATA[i][this.configOptions.groupByColumns[2]];
      } else if (groupLevel == 1) {
        group0Key = this.configOptions.groupByColumns[0];
        group1Key = this.configOptions.groupByColumns[1];
        group0Val = DATA[i][this.configOptions.groupByColumns[0]];
        group1Val = DATA[i][this.configOptions.groupByColumns[1]];
      } else if (groupLevel == 0) {
        group0Key = this.configOptions.groupByColumns[0];
        group1Key = this.configOptions.groupByColumns[1];
        group0Val = DATA[i][this.configOptions.groupByColumns[0]];
      }
      let count = 1;
      for (let j = i + 1; j < DATA.length; j++) {
        let isSameGroup = true;
        if (groupLevel == 2) {
          if (group0Key && group0Val !== DATA[j][group0Key] || group1Key && group1Val !== DATA[j][group1Key]) {
            isSameGroup = false;
          }
        } else if (groupLevel == 1) {
          if (group0Key && group0Val !== DATA[j][group0Key]) {
            isSameGroup = false;
          }
        }
        if (!isSameGroup) {
          break;
        }
        if (currentValue !== DATA[j][key]) {
          break;
        }
        count++;
      }
      if (!this.spans[i]) {
        this.spans[i] = {};
      }
      this.spans[i][key] = count;
      i += count;
    }
  }
  getRowSpan(col, index) {
    let groupByCols = this.configOptions.groupByColumns;
    if (groupByCols.indexOf(col) > -1) {
      return this.spans[index] && this.spans[index][col];
    }
    return 1;
  }
  getRowSpanDisplay(col, index) {
    let displayStr = "";
    let groupByCols = this.configOptions.groupByColumns;
    if (groupByCols.indexOf(col) > -1) {
      displayStr = this.spans[index] && this.spans[index][col] ? "none" : "";
    }
    return displayStr;
  }
  getColumnByID(colId) {
    let column;
    let colIndex = this.configOptions.allColumns.findIndex((x) => x.id === colId);
    if (colIndex > -1) {
      column = this.configOptions.allColumns[colIndex];
    }
    return column;
  }
  openSnackBar(message) {
    this._snackBar.open(message, "", {
      horizontalPosition: this.horizontalPosition,
      verticalPosition: this.verticalPosition,
      duration: 5e3
      // 5 milliseconds
    });
  }
  toggleColumnVisibility(isVisible, colId, externalTrigger) {
    this.visibleColumns = this.configOptions.allColumns.filter((column) => column["visible"]);
    if (!isVisible && this.visibleColumns.length == 1) {
      this.openSnackBar("Please make sure to have aleast one column in the report!");
      return;
    }
    let groupedColIds = this.configOptions.groupByColumns;
    let groupIndex = groupedColIds.indexOf(colId);
    if (groupIndex > -1 && !isVisible) {
      let column = this.getColumnByID(colId);
      if (column) {
        this.removeGroup(column);
      }
    }
    this.configOptions.allColumns.forEach((col) => {
      if (col["id"] === colId) {
        col["visible"] = isVisible;
      }
    });
    this.reOrderColumns(colId, "end");
    this.setColumnsToDisplay();
    this.onConfigOptionsChange.emit({
      eventType: Constants.REFRESH_CONFIG,
      data: this.configOptions
    });
    if (!externalTrigger) {
      let _eventName = isVisible ? Constants.ADD_COLUMN : Constants.REMOVE_COLUMN;
      this.onConfigOptionsChange.emit({
        eventType: Constants.WRITE_TO_UNDO_REDO,
        eventName: _eventName,
        data: colId
      });
    }
  }
  hideColumn(columnId) {
    this.toggleColumnVisibility(false, columnId);
  }
  showColumn(event, column) {
    event.stopPropagation();
    this.toggleColumnVisibility(true, column.id);
  }
  drop(event) {
    let _columnsToDisplay = this.columnsToDisplay;
    if (this.configOptions.enableRowsSelection) {
      this.columnsToDisplay.splice(0, 1);
      _columnsToDisplay = this.columnsToDisplay;
      moveItemInArray(_columnsToDisplay, event.previousIndex, event.currentIndex);
      this.columnsToDisplay = ["selected", ..._columnsToDisplay];
    } else {
      moveItemInArray(_columnsToDisplay, event.previousIndex, event.currentIndex);
      this.columnsToDisplay = [..._columnsToDisplay];
    }
  }
  reOrderColumns(columnName, movePosition) {
    let prevIndex = this.configOptions.allColumns.findIndex((x) => x.id === columnName);
    let newIndex;
    if (movePosition === "left") {
      newIndex = prevIndex - 1;
    } else if (movePosition === "right") {
      newIndex = prevIndex + 1;
    } else if (movePosition === "index") {
      newIndex = this.configOptions.groupByColumns.length - 1;
    } else if (movePosition === "original") {
      const index = this.configOptions.allColumns.findIndex((col) => col.id === columnName);
      if (index > -1) {
        newIndex = this.configOptions.allColumns[index].originalOrder || this.configOptions.allColumns.length;
        newIndex = newIndex - 1;
      } else {
        newIndex = this.configOptions.allColumns.length;
      }
    } else {
      newIndex = this.configOptions.allColumns.length;
    }
    moveItemInArray(this.configOptions.allColumns, prevIndex, newIndex);
    this.configOptions.allColumns.forEach((column, index) => {
      column.order = index + 1;
    });
    this.repaintTable();
  }
  moveLeft(columnName) {
    let _columnsToDisplay = this.columnsToDisplay;
    if (this.configOptions.enableRowsSelection) {
      this.columnsToDisplay.splice(0, 1);
      _columnsToDisplay = this.columnsToDisplay;
      let prevIndex = _columnsToDisplay.indexOf(columnName);
      let currentIndex = prevIndex - 1;
      moveItemInArray(_columnsToDisplay, prevIndex, currentIndex);
      this.reOrderColumns(columnName, "left");
      this.columnsToDisplay = ["selected", ..._columnsToDisplay];
    } else {
      let prevIndex = _columnsToDisplay.indexOf(columnName);
      let currentIndex = prevIndex - 1;
      moveItemInArray(_columnsToDisplay, prevIndex, currentIndex);
      this.reOrderColumns(columnName, "left");
      this.columnsToDisplay = [..._columnsToDisplay];
    }
  }
  moveRight(columnName) {
    let _columnsToDisplay = this.columnsToDisplay;
    if (this.configOptions.enableRowsSelection) {
      this.columnsToDisplay.splice(0, 1);
      _columnsToDisplay = this.columnsToDisplay;
      let prevIndex = _columnsToDisplay.indexOf(columnName);
      let currentIndex = prevIndex + 1;
      moveItemInArray(_columnsToDisplay, prevIndex, currentIndex);
      this.reOrderColumns(columnName, "right");
      this.columnsToDisplay = ["selected", ..._columnsToDisplay];
    } else {
      let prevIndex = _columnsToDisplay.indexOf(columnName);
      let currentIndex = prevIndex + 1;
      moveItemInArray(_columnsToDisplay, prevIndex, currentIndex);
      this.reOrderColumns(columnName, "right");
      this.columnsToDisplay = [..._columnsToDisplay];
    }
  }
  isSticky(stickyColumns, id) {
    return stickyColumns.indexOf(id) !== -1;
  }
  isStickyEnd(stickyEndColumns, id) {
    return stickyEndColumns.indexOf(id) !== -1;
  }
  stick(columnName) {
    if (!this.stickyColumns.includes(columnName)) {
      this.stickyColumns.push(columnName);
    }
    this.configOptions.allColumns.forEach((column) => {
      if (column.id === columnName) {
        column.sticky = true;
      }
    });
  }
  stickToEnd(columnName) {
    this.stickyEndColumns.push(columnName);
  }
  unstick(columnName) {
    this.stickyColumns = this.stickyColumns.filter((col) => col !== columnName);
    this.configOptions.allColumns.forEach((column) => {
      if (columnName === column.id) {
        column.sticky = false;
      }
    });
  }
  unstickEnd(columnName) {
    const index = this.stickyEndColumns.indexOf(columnName);
    if (index > -1) {
      this.stickyEndColumns.splice(index, 1);
    }
  }
  /** Whether the number of selected elements matches the total number of rows. */
  isAllSelected() {
    const numSelected = this.selection.selected.length;
    const numRows = this.dataSource.data.length;
    return numSelected === numRows;
  }
  /** Selects all rows if they are not all selected; otherwise clear selection. */
  masterToggle() {
    if (this.isAllSelected()) {
      this.selection.clear();
      this.rowLevelActionHandler.emit({
        action: "toggleAllRows",
        data: false
      });
      return;
    }
    this.rowLevelActionHandler.emit({
      action: "toggleAllRows",
      data: true
    });
    this.selection.select(...this.dataSource.data);
  }
  /** The label for the checkbox on the passed row */
  checkboxLabel(row) {
    if (!row) {
      return `${this.isAllSelected() ? "deselect" : "select"} all`;
    }
    return `${this.selection.isSelected(row) ? "deselect" : "select"} row ${row.position + 1}`;
  }
  toggleRowSelect(row) {
    if (row) {
      this.selection.toggle(row);
      this.rowLevelActionHandler.emit({
        action: "toggleRowSelect",
        data: row
      });
    }
  }
  onCellClick(row, columnId, controlType, element = null) {
    if (controlType !== "menu") {
      if (!element) this.cellClickActionHandler.emit({
        row,
        columnId,
        scrollTop: this.scrollTop ? this.scrollTop : 0
      });
      else this.cellClickActionHandler.emit({
        row,
        columnId,
        element,
        scrollTop: this.scrollTop ? this.scrollTop : 0
      });
    }
  }
  onMenuButtonClick(row, columnId, option) {
    this.cellClickActionHandler.emit({
      row,
      columnId,
      option
    });
  }
  resetTableScroll() {
    if (!this.dataSource.data.length) {
      this.configOptions.tableHeight = "60px";
    }
  }
  repaintTable() {
    this.groupAndSort(this.dataSource.data);
    this.spans = [];
    this.configOptions.groupByColumns.forEach((col, index) => {
      this.cacheSpan(col, index);
    });
    this.changeDetectorRefs.detectChanges();
  }
  ngAfterViewInit() {
    this.dataSource.paginator = this.paginator;
    if (this.configOptions?.defaultSortColumn) {
      this.sort.active = this.configOptions.defaultSortColumn;
      this.sort.direction = this.configOptions?.defaultSortDirection ? this.configOptions.defaultSortDirection : "asc";
    }
    this.dataSource.sort = this.sort;
    this.resetTableScroll();
    this.repaintTable();
  }
  evaluateCondition(rowData, item = {
    condition: true
  }) {
    if (item.condition === true || item.condition === false) return item.condition;
    const {
      operation,
      operand,
      fieldName,
      dependentFieldName
    } = item.condition;
    const fieldValue = rowData[fieldName];
    const dependentFieldValue = dependentFieldName ? rowData[dependentFieldName] : true;
    if (dependentFieldValue === false) return;
    switch (operation) {
      case "=":
        return fieldValue === operand;
      case "!=":
        return fieldValue !== operand;
      case ">":
        return fieldValue > operand;
      case "<":
        return fieldValue < operand;
      case ">=":
        return fieldValue >= operand;
      case "<=":
        return fieldValue <= operand;
      case "contains":
        return fieldValue.toString().toLowerCase().includes(operand.toString().toLowerCase());
      case "notContains":
        return !fieldValue.toString().toLowerCase().includes(operand.toString().toLowerCase());
      case "startsWith":
        return fieldValue.toString().toLowerCase().startsWith(operand.toString().toLowerCase());
      case "endsWith":
        return fieldValue.toString().toLowerCase().endsWith(operand.toString().toLowerCase());
      case "in":
        return operand.includes(fieldValue);
      case "notIn":
        return !operand.includes(fieldValue);
      case "isNull":
        return fieldValue === null;
      case "isNotNull":
        return fieldValue !== null;
      case "isEmpty":
        return fieldValue === "";
      case "isNotEmpty":
        return fieldValue !== "";
      case "isTrue":
        return fieldValue === true;
      case "isFalse":
        return fieldValue === false;
      case "isTruthy":
        return !!fieldValue;
      case "isFalsy":
        return !fieldValue;
      case "isToday":
      case "isThisWeek":
      case "isThisMonth":
    }
  }
  getConditionalStyles(existingStyles, rowData, column) {
    let styles = __spreadValues({}, existingStyles);
    if (column.hasConditionalStyles) {
      const conditionalStyles = this.configOptions.conditionalStyles;
      let value = rowData[column.id];
      if (value) {
        value = value.toLowerCase();
      }
      const style2 = conditionalStyles[value];
      styles = __spreadValues(__spreadValues({}, styles), style2);
    }
    if (column?.hasMatToolTip) {
      const style2 = {
        "white-space": "nowrap",
        "display": "block",
        "overflow": "hidden",
        "text-overflow": "ellipsis",
        "max-width": "160px"
      };
      styles = __spreadValues(__spreadValues({}, styles), style2);
    }
    if (rowData[column.id + "_styles"] && typeof rowData[column.id + "_styles"] === "object") {
      styles = __spreadValues(__spreadValues({}, styles), rowData[column.id + "_styles"]);
    }
    return styles;
  }
  evaluateExpression(rowData, column) {
    let styles = {};
    let groupedColumns = this.configOptions.groupByColumns;
    let index = groupedColumns.indexOf(column.id);
    if (index > -1) {
      styles = __spreadProps(__spreadValues({}, styles), {
        background: this.configOptions.groupLevelColors[index] ? this.configOptions.groupLevelColors[index] : ""
      });
    }
    column.operations?.forEach((op) => {
      switch (op.operation) {
        case "gt":
          if (rowData[column.id] > op.value) {
            styles = __spreadValues(__spreadValues({}, styles), op.styles);
          }
          break;
        case "lt":
          if (rowData[column.id] < op.value) {
            styles = __spreadValues(__spreadValues({}, styles), op.styles);
          }
          break;
        case "equal":
          if (rowData[column.id] === op.value) {
            styles = __spreadValues(__spreadValues({}, styles), op.styles);
          }
          break;
      }
    });
    return styles;
  }
  getDisplayValues(value, separator = ",") {
    return value ? value.split(separator) : [];
  }
  getDisplayType(element, column, value) {
    const status = element[column.controlValue?.dependentFieldId];
    if (value?.dependentFieldValues?.length) {
      if (value?.dependentFieldValues.includes(status?.toLowerCase())) value.displayType = "dropdown";
      else value.displayType = "text";
    }
    return value.displayType;
  }
  onToggleChange(event) {
    this.onToggleChangeHandler.emit(event.checked);
  }
  scrollToTop() {
    const element = document.getElementById("matTableMain");
    if (element) {
      element.scrollTop = 0;
    }
  }
  ngOnDestroy() {
    this.subscription.unsubscribe();
    this.scrollSubscription.unsubscribe();
  }
  resetSelection() {
    this.selection = new SelectionModel(true, this.selectedRows);
  }
  // sortDataSource(idVal: string, startVal?: 'asc' | 'desc'): void {
  //   this.dataSource.sort?.sort(<MatSortable>({ id: idVal, start: startVal}));
  // }
  onValChange(element, val) {
    this.onSelectButtonToggle.emit({
      element,
      val
    });
  }
};
DynamictableComponent.ɵfac = function DynamictableComponent_Factory(ɵt) {
  return new (ɵt || DynamictableComponent)(ɵɵdirectiveInject(MatSnackBar), ɵɵdirectiveInject(ChangeDetectorRef), ɵɵdirectiveInject(DynamictableFilterService), ɵɵdirectiveInject(DomSanitizer), ɵɵdirectiveInject(DynamictableScrollerService));
};
DynamictableComponent.ɵcmp = ɵɵdefineComponent({
  type: DynamictableComponent,
  selectors: [["cwp-dynamictable"]],
  viewQuery: function DynamictableComponent_Query(rf, ctx) {
    if (rf & 1) {
      ɵɵviewQuery(MatPaginator, 5);
      ɵɵviewQuery(MatSort, 5);
    }
    if (rf & 2) {
      let _t;
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.paginator = _t.first);
      ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.sort = _t.first);
    }
  },
  inputs: {
    configOptions: "configOptions",
    dataSource: "dataSource"
  },
  outputs: {
    fetchDataCallback: "fetchDataCallback",
    rowLevelActionHandler: "rowLevelActionHandler",
    cellClickActionHandler: "cellClickActionHandler",
    onConfigOptionsChange: "onConfigOptionsChange",
    onToggleChangeHandler: "onToggleChangeHandler",
    onSelectButtonToggle: "onSelectButtonToggle"
  },
  features: [ɵɵNgOnChangesFeature],
  decls: 15,
  vars: 18,
  consts: [["menu", "matMenu"], ["tooltip", "matTooltip"], ["freeText", ""], ["group", "matButtonToggleGroup"], ["actionsMenu", "matMenu"], ["nestedMenu", "matMenu"], ["class", "leftPanel", 4, "ngIf"], [3, "ngClass"], ["id", "tableMain", 1, "tableMain", 3, "scroll"], ["id", "matTableMain", "mat-table", "", "matSort", "", "multiTemplateDataRows", "", "cdkDropList", "", "cdkDropListOrientation", "horizontal", 1, "mat-elevation-z0", "dynamictable", 3, "cdkDropListDropped", "scroll", "dataSource", "ngStyle"], ["matColumnDef", "selected", 4, "ngIf"], [3, "matColumnDef", "sticky", "stickyEnd", 4, "ngFor", "ngForOf"], ["matColumnDef", "actions", 3, "stickyEnd", 4, "ngIf"], ["matColumnDef", "expandedDetail"], ["mat-cell", "", 4, "matCellDef"], ["mat-header-row", "", "class", "headerRow", 4, "matHeaderRowDef", "matHeaderRowDefSticky"], ["mat-row", "", 3, "example-expanded-row", "ngClass", "click", 4, "matRowDef", "matRowDefColumns"], ["mat-row", "", "class", "example-detail-row", 4, "matRowDef", "matRowDefColumns", "matRowDefWhen"], ["class", "noResultsContainer", 4, "ngIf"], ["aria-label", "Select Page", 3, "pageSizeOptions", 4, "ngIf"], [1, "leftPanel"], [3, "eventsHandler", "configOptions"], ["matColumnDef", "selected"], ["mat-header-cell", "", "class", "w-50 rowselect-checkbox", 4, "matHeaderCellDef"], ["mat-cell", "", "class", "w-50", 4, "matCellDef"], ["mat-header-cell", "", 1, "w-50", "rowselect-checkbox"], [3, "change", "checked", "indeterminate", "aria-label"], ["mat-cell", "", 1, "w-50"], [3, "click", "change", "disabled", "checked", "aria-label"], [3, "matColumnDef", "sticky", "stickyEnd"], ["mat-header-cell", "", "cdkDrag", "", "class", "tableHeaderCell table-column", "mat-sort-header", "", 3, "cdkDragDisabled", "disableClear", "disabled", 4, "matHeaderCellDef"], ["mat-cell", "", "class", "table-column", 3, "ngStyle", "display", "id", "click", 4, "matCellDef"], ["mat-header-cell", "", "cdkDrag", "", "mat-sort-header", "", 1, "tableHeaderCell", "table-column", 3, "cdkDragDisabled", "disableClear", "disabled"], [1, "headerCell"], ["id", "dynamictableHeadCellName", 1, "headerCellLabel"], [4, "ngIf"], [1, "headerCellActions", 3, "click"], ["id", "dynamictableMoreOption", "type", "button", "mat-icon-button", "", "aria-label", "icon-button with a menu", "aria-label", "More Options", 3, "matMenuTriggerFor", "click", 4, "ngIf"], ["xPosition", "before"], ["id", "dynamictableHideCol", "type", "button", "mat-menu-item", "", 3, "click", 4, "ngIf"], ["id", "dynamictableMoveLeft", "type", "button", "mat-menu-item", "", 3, "click", 4, "ngIf"], ["id", "dynamictableMoveRight", "type", "button", "mat-menu-item", "", 3, "click", 4, "ngIf"], ["id", "dynamictableStick", "type", "button", "mat-menu-item", "", 3, "click", 4, "ngIf"], ["id", "dynamictableColStickable", "type", "button", "mat-menu-item", "", 3, "click", 4, "ngIf"], ["id", "dynamictableAddGroup", "type", "button", "mat-menu-item", "", 3, "disabled", "click", 4, "ngIf"], ["id", "dynamictableRemoveGroup", "type", "button", "mat-menu-item", "", 3, "click", 4, "ngIf"], ["id", "dynamictableSortAsc", 4, "ngIf"], ["id", "dynamictableSortDesc", 4, "ngIf"], ["id", "dynamictableSortAsc"], ["id", "dynamictableSortDesc"], ["id", "dynamictableMoreOption", "type", "button", "mat-icon-button", "", "aria-label", "icon-button with a menu", "aria-label", "More Options", 3, "click", "matMenuTriggerFor"], ["id", "dynamictableHideCol", "type", "button", "mat-menu-item", "", 3, "click"], ["id", "dynamictableMoveLeft", "type", "button", "mat-menu-item", "", 3, "click"], ["id", "dynamictableMoveRight", "type", "button", "mat-menu-item", "", 3, "click"], ["id", "dynamictableStick", "type", "button", "mat-menu-item", "", 3, "click"], ["id", "dynamictableColStickable", "type", "button", "mat-menu-item", "", 3, "click"], ["id", "dynamictableAddGroup", "type", "button", "mat-menu-item", "", 3, "click", "disabled"], ["id", "dynamictableRemoveGroup", "type", "button", "mat-menu-item", "", 3, "click"], ["mat-cell", "", 1, "table-column", 3, "click", "ngStyle", "id"], ["class", "displayFlex", 3, "ngClass", 4, "ngIf"], [1, "displayFlex", 3, "ngClass"], ["id", "dynamictableImg", "alt", "Pre Image", 3, "src", "ngStyle", 4, "ngIf"], [3, "ngClass", 4, "ngIf"], ["class", "button-span", 4, "ngIf"], ["class", "mat-button-span", 4, "ngIf"], ["class", "width-100", 3, "id", 4, "ngIf"], ["alt", "Post Image", 3, "src", "ngStyle", 4, "ngIf"], ["id", "dynamictableImg", "alt", "Pre Image", 3, "src", "ngStyle"], ["id", "dynamictableColType", "matTooltipPosition", "above", 3, "ngStyle", "matTooltip", "matTooltipDisabled", "click", 4, "ngIf"], [3, "ngStyle", 4, "ngIf"], ["id", "dynamictableSubtitle", 3, "ngStyle", 4, "ngIf"], ["id", "dynamictableSubtitleElement", 4, "ngIf"], ["id", "dynamictableColType", "matTooltipPosition", "above", 3, "click", "ngStyle", "matTooltip", "matTooltipDisabled"], ["id", "dynamictableRightElement", 3, "innerHTML", 4, "ngIf"], ["id", "dynamictableRightElement", 3, "innerHTML"], [3, "ngStyle"], ["id", "dynamictableItem", 3, "click", 4, "ngFor", "ngForOf"], ["id", "dynamictableItem", 3, "click"], ["id", "dynamictableSubtitle", 3, "ngStyle"], ["id", "dynamictableSubtitleElement"], [3, "innerHTML"], [1, "slide-toggle"], [3, "change", "checked"], [1, "button-span"], ["id", "dynamictableColValue", "type", "button", "mat-stroked-button", "", "class", "table-buttons", 4, "ngIf", "ngIfElse"], ["id", "dynamictableColValue", "type", "button", "mat-stroked-button", "", 1, "table-buttons"], ["id", "dynamictableColId"], [1, "mat-button-span"], ["id", "dynamictableColId", 4, "ngIf"], [4, "ngFor", "ngForOf"], [3, "change"], [3, "value"], ["mat-stroked-button", "", "class", "table-buttons", 3, "matMenuTriggerFor", 4, "ngIf", "ngIfElse"], ["matMenuContent", ""], ["mat-stroked-button", "", 1, "table-buttons", 3, "matMenuTriggerFor"], ["mat-menu-item", "", "class", "mat-menu-button", 3, "click", 4, "ngFor", "ngForOf"], ["mat-menu-item", "", 1, "mat-menu-button", 3, "click"], [1, "space-between", 3, "ngStyle"], [1, "width-100", 3, "id"], ["class", "dropdown", 4, "ngIf"], ["id", "dynamictableText", 4, "ngIf"], [1, "dropdown"], ["id", "dynamictableDropDown", "class", "dropdown-value", 4, "ngIf"], ["id", "dynamictableSelect", "class", "select-text", 4, "ngIf"], [1, "arrow"], ["id", "dynamictableDropDown", 1, "dropdown-value"], ["id", "dynamictableSelect", 1, "select-text"], ["id", "dynamictableText"], ["alt", "Post Image", 3, "src", "ngStyle"], ["matColumnDef", "actions", 3, "stickyEnd"], ["id", "dynamictableAction", "mat-header-cell", "", "class", "w-50 actions-column tableHeaderCell table-column", 4, "matHeaderCellDef"], ["id", "dynamictableAction", "mat-header-cell", "", 1, "w-50", "actions-column", "tableHeaderCell", "table-column"], ["mat-cell", ""], [1, "action-icons-display-flex"], ["id", "dynamictableActionMenu", "type", "button", "mat-icon-button", "", "aria-label", "More Options", 1, "more-actions", 3, "matMenuTriggerFor", "disabled"], ["id", "dynamictableMoreIcon"], ["id", "dynamictableRowLevelAction", "type", "button", "mat-icon-button", "", "aria-label", "Row Level Action", 1, "more-actions", 3, "click"], ["id", "dynamictableIconToggleOn", "class", "action-icons", 3, "ngStyle", "click", 4, "ngIf"], ["id", "dynamictableToggleOff", "class", "action-icons", 3, "ngStyle", "click", 4, "ngIf"], ["id", "dynamictableIconToggleOn", 1, "action-icons", 3, "click", "ngStyle"], ["id", "dynamictableToggleOff", 1, "action-icons", 3, "click", "ngStyle"], ["id", "dynamictableActionClick", "type", "button", "mat-menu-item", "", 3, "click", 4, "ngIf"], ["id", "dynamictableActionClick", "type", "button", "mat-menu-item", "", 3, "click"], ["id", "dynamictableActionIcon", "class", "action-icons", 3, "ngClass", 4, "ngIf"], ["id", "dynamictableActionTitle", 3, "ngClass"], ["id", "dynamictableActionIcon", 1, "action-icons", 3, "ngClass"], ["id", "dynamictableActionClick", "type", "button", "mat-menu-item", "", 3, "matMenuTriggerFor", 4, "ngIf"], ["mat-menu-item", "", 3, "click", 4, "ngFor", "ngForOf"], ["id", "dynamictableActionClick", "type", "button", "mat-menu-item", "", 3, "matMenuTriggerFor"], ["id", "dynamictableActionTitle"], ["mat-menu-item", "", 3, "click"], [1, "example-element-detail"], [1, "example-element-diagram"], ["id", "dynamictableElementName", 1, "example-element-position"], ["id", "dynamictableElementProgress", 1, "example-element-symbol"], ["id", "dynamictableElementExample", 1, "example-element-name"], ["id", "dynamictableElementId", 1, "example-element-weight"], ["id", "dynamictableElementDesc", 1, "example-element-description"], [1, "example-element-description-attribution"], ["mat-header-row", "", 1, "headerRow"], ["mat-row", "", 3, "click", "ngClass"], ["mat-row", "", 1, "example-detail-row"], [1, "noResultsContainer"], ["id", "dynamictableNoDataFound", 1, "noSearchResultsText"], ["aria-label", "Select Page", 3, "pageSizeOptions"]],
  template: function DynamictableComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "div");
      ɵɵtemplate(1, DynamictableComponent_div_1_Template, 2, 1, "div", 6);
      ɵɵelementStart(2, "div", 7)(3, "div", 8);
      ɵɵlistener("scroll", function DynamictableComponent_Template_div_scroll_3_listener($event) {
        return ctx.onTableScroll($event);
      });
      ɵɵelementStart(4, "table", 9);
      ɵɵlistener("cdkDropListDropped", function DynamictableComponent_Template_table_cdkDropListDropped_4_listener($event) {
        return ctx.drop($event);
      })("scroll", function DynamictableComponent_Template_table_scroll_4_listener($event) {
        return ctx.onTableScroll($event);
      });
      ɵɵtemplate(5, DynamictableComponent_ng_container_5_Template, 3, 0, "ng-container", 10)(6, DynamictableComponent_ng_container_6_Template, 3, 3, "ng-container", 11)(7, DynamictableComponent_ng_container_7_Template, 3, 1, "ng-container", 12);
      ɵɵelementContainerStart(8, 13);
      ɵɵtemplate(9, DynamictableComponent_td_9_Template, 15, 7, "td", 14);
      ɵɵelementContainerEnd();
      ɵɵtemplate(10, DynamictableComponent_tr_10_Template, 1, 0, "tr", 15)(11, DynamictableComponent_tr_11_Template, 1, 5, "tr", 16)(12, DynamictableComponent_tr_12_Template, 1, 0, "tr", 17);
      ɵɵelementEnd();
      ɵɵtemplate(13, DynamictableComponent_div_13_Template, 3, 1, "div", 18);
      ɵɵelementEnd();
      ɵɵtemplate(14, DynamictableComponent_mat_paginator_14_Template, 1, 2, "mat-paginator", 19);
      ɵɵelementEnd()();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.configOptions.displayFilterPanel);
      ɵɵadvance();
      ɵɵproperty("ngClass", ctx.configOptions.displayFilterPanel ? "tableMainContent" : "tableFullWidth");
      ɵɵadvance(2);
      ɵɵproperty("dataSource", ctx.dataSource)("ngStyle", ɵɵpureFunction2(14, _c011, ctx.configOptions.tableWidth, ctx.configOptions.tableHeight));
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.configOptions.enableRowsSelection);
      ɵɵadvance();
      ɵɵproperty("ngForOf", ctx.displayedColumns);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.configOptions.displayActionsColumn);
      ɵɵadvance(3);
      ɵɵproperty("matHeaderRowDef", ctx.columnsToDisplay)("matHeaderRowDefSticky", true);
      ɵɵadvance();
      ɵɵproperty("matRowDefColumns", ctx.columnsToDisplay);
      ɵɵadvance();
      ɵɵproperty("matRowDefColumns", ɵɵpureFunction0(17, _c17))("matRowDefWhen", ctx.customWhen);
      ɵɵadvance();
      ɵɵproperty("ngIf", !ctx.dataSource.data.length);
      ɵɵadvance();
      ɵɵproperty("ngIf", ctx.configOptions.enablePagination);
    }
  },
  dependencies: [TableFilterPanelComponent, MatTable, MatCheckbox, MatSortHeader, MatButton, MatIcon, MatMenu, MatMenuItem, MatSlideToggle, MatButtonToggle, MatHeaderRow, MatRow, MatPaginator, NgIf, NgClass, MatSort, CdkDropList, NgStyle, MatColumnDef, MatHeaderCellDef, MatHeaderCell, MatCellDef, MatCell, NgForOf, CdkDrag, MatMenuTrigger, MatTooltip, MatButtonToggleGroup, MatMenuContent, MatHeaderRowDef, MatRowDef, DynamicTypePipe],
  styles: ['table[_ngcontent-%COMP%]{width:100%}.dynamictable[_ngcontent-%COMP%]{box-shadow:none!important}.button-span[_ngcontent-%COMP%], .mat-button-span[_ngcontent-%COMP%]{width:100%}.mat-button-span[_ngcontent-%COMP%]     .mat-button-toggle{margin-right:5px;border:1px solid #ccc;align-items:center;width:35px;height:35px}.mat-button-span[_ngcontent-%COMP%]     .mat-button-toggle-group-appearance-standard{border-radius:1px;border:none}.mat-button-span[_ngcontent-%COMP%]     .mat-button-toggle-label-content{line-height:34px;padding:0!important}.mat-button-span[_ngcontent-%COMP%]   .approve-btn[_ngcontent-%COMP%]{background-color:#fff!important;color:#34c759!important;border-radius:4px}.mat-button-span[_ngcontent-%COMP%]   .approve-btn[_ngcontent-%COMP%]:hover{background-color:#34c759!important;color:#fff!important}.mat-button-span[_ngcontent-%COMP%]   .reject-btn[_ngcontent-%COMP%]{background-color:#fff!important;color:#f6685e!important;border-radius:4px}.mat-button-span[_ngcontent-%COMP%]   .reject-btn[_ngcontent-%COMP%]:hover{background-color:#f6685e!important;color:#fff!important}.noResultsContainer[_ngcontent-%COMP%]{width:100%;height:50vh;display:flex;align-items:center;justify-content:center;background:#fff}.noResultsContainer[_ngcontent-%COMP%]   .noSearchResultsText[_ngcontent-%COMP%]{font-weight:400;color:#000;opacity:.5;font-size:150%}.mat-form-field[_ngcontent-%COMP%]{font-size:14px;width:100%}tr.example-detail-row[_ngcontent-%COMP%]{height:0!important;background:#f2f2f2}tr.example-detail-row[_ngcontent-%COMP%]:hover{background:none!important;cursor:auto!important}tr.example-element-row[_ngcontent-%COMP%]:not(.example-expanded-row):hover{background:whitesmoke}tr.example-element-row[_ngcontent-%COMP%]:not(.example-expanded-row):active{background:#efefef}.example-element-row[_ngcontent-%COMP%]   td[_ngcontent-%COMP%]{border-bottom-width:0}.example-element-detail[_ngcontent-%COMP%]{overflow:hidden;display:flex;background:#f2f2f2}.example-element-diagram[_ngcontent-%COMP%]{min-width:80px;border:2px solid black;padding:8px;font-weight:lighter;margin:8px 0;height:104px}.example-element-symbol[_ngcontent-%COMP%]{font-weight:700;font-size:40px;line-height:normal}.example-element-description[_ngcontent-%COMP%]{padding:16px}.example-element-description-attribution[_ngcontent-%COMP%]{opacity:.5}.headerRow[_ngcontent-%COMP%]{background:rgb(239,242,255)!important}.headerCell[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:space-between}.headerCellLabel[_ngcontent-%COMP%]{padding-left:5px;text-align:left;justify-content:space-between;align-items:center;align-content:center}button.mat-menu-item[_ngcontent-%COMP%]{width:100%;line-height:25px!important;height:35px!important;font-size:small}th.mat-header-cell[_ngcontent-%COMP%]{padding-left:10px;font-weight:500;color:#000;font-size:14px;font-family:Roboto;border-top:.5px solid #d8d8d8}th.mat-header-cell[_ngcontent-%COMP%]:last-child{border-right:.5px solid #d8d8d8}td.mat-cell[_ngcontent-%COMP%]{padding-left:16px;padding-right:16px!important}tr.mat-row[_ngcontent-%COMP%]{border:0px!important;cursor:pointer}tr.mat-row[_ngcontent-%COMP%]:hover{background:#f2f2f2}tr.mat-footer-row[_ngcontent-%COMP%]{border:1px solid #f2f2f2!important}.mat-paginator[_ngcontent-%COMP%]{display:block;height:50px!important;background:#f2f2f2}.tableFilterRow[_ngcontent-%COMP%]{align-items:center;justify-content:space-between}.searchbar[_ngcontent-%COMP%]{width:45%}  .mat-form-field-wrapper{padding-bottom:0!important}.root[_ngcontent-%COMP%]{background:#f2f2f2}.rowselect-checkbox[_ngcontent-%COMP%]{padding-left:24px;padding-right:24px;width:2%;background:#eff2ff}.action-icons-display-flex[_ngcontent-%COMP%]{justify-content:flex-end;display:flex}.actions-column[_ngcontent-%COMP%]{min-width:20px!important;width:20px!important;text-align:right;padding-right:10px!important;padding-left:10px!important}.tableMainContent[_ngcontent-%COMP%]{background:#fff;border-left:.6px solid #b0b0b0}.tableMain[_ngcontent-%COMP%]{background:#fff;overflow:auto!important}.tableMain[_ngcontent-%COMP%]     .mat-sort-header-container{display:block!important}.tableMain[_ngcontent-%COMP%]     .mat-sort-header-content{display:block!important}.tableFullWidth[_ngcontent-%COMP%]{border-left:none!important}.leftPanel[_ngcontent-%COMP%]{padding:10px;width:20%;height:100%}.menu-content[_ngcontent-%COMP%]{height:inherit;width:inherit;background:lightgoldenrodyellow;padding:10px;margin:10px}.columnConfigListItem[_ngcontent-%COMP%]{font-size:10pt;height:25px!important}[_nghost-%COMP%]     .mat-sort-header-arrow{display:none!important}.table-column[_ngcontent-%COMP%]{min-width:140px}.mat-menu-button[_ngcontent-%COMP%]{width:150px}.action-icons[_ngcontent-%COMP%]{margin-top:2px;margin-right:5px!important;font-size:20px}.mat-table[_ngcontent-%COMP%]{display:block;width:100%;overflow:auto;max-height:95vh}.displayFlex[_ngcontent-%COMP%]{display:flex;align-items:center}.red-text[_ngcontent-%COMP%]{color:#f6685e}.more-actions[_ngcontent-%COMP%]{width:30px;height:30px;line-height:30px}.table-buttons[_ngcontent-%COMP%]{background-color:#fff;border:1px solid #3d5afe;color:#3d5afe;width:100%}.slide-toggle[_ngcontent-%COMP%]     .mat-slide-toggle-bar{width:36px;height:20px!important;border-radius:25px!important}.slide-toggle[_ngcontent-%COMP%]     .mat-slide-toggle.mat-checked .mat-slide-toggle-bar{background-color:#34c759!important}.slide-toggle[_ngcontent-%COMP%]     .mat-slide-toggle-thumb-container{top:2px!important;left:3px!important}.slide-toggle[_ngcontent-%COMP%]     .mat-slide-toggle-thumb{height:15px!important;width:15px!important}.slide-toggle[_ngcontent-%COMP%]     .mat-slide-toggle.mat-checked .mat-slide-toggle-thumb{background-color:#fff!important}.space-between[_ngcontent-%COMP%]{display:flex;justify-content:space-between}.highlight[_ngcontent-%COMP%]{background:whitesmoke}.date-picker[_ngcontent-%COMP%]{display:flex;justify-content:space-between}.date-picker[_ngcontent-%COMP%]     .mat-form-field-appearance-outline .mat-form-field-outline{color:transparent!important}.date-picker[_ngcontent-%COMP%]     .mat-form-field-appearance-outline .mat-form-field-flex{padding:0!important}.date-picker[_ngcontent-%COMP%]     .mat-form-field-infix{width:100%!important}.date-picker[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:30px;line-height:63px;color:#0000008a}.width-100[_ngcontent-%COMP%]{width:100%}.dropdown[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:center}.dropdown[_ngcontent-%COMP%]   .select-text[_ngcontent-%COMP%]{color:#9e9e9e}.dropdown[_ngcontent-%COMP%]   .arrow[_ngcontent-%COMP%]{float:right}.dropdown[_ngcontent-%COMP%]   mat-icon[_ngcontent-%COMP%]{font-size:30px;line-height:35px;color:#0000008a}  .mat-menu-submenu-icon{display:none!important}.disabled[_ngcontent-%COMP%]{background-color:#e0e0e0}.not-disabled[_ngcontent-%COMP%]{background-color:#fff}.table-column[_ngcontent-%COMP%]   .mat-tooltip-parent[_ngcontent-%COMP%]{display:flex;align-items:center}.table-column[_ngcontent-%COMP%]     .mat-tooltip-panel-above .mat-tooltip{overflow:visible;margin-bottom:8px}.table-column[_ngcontent-%COMP%]     .mat-tooltip-panel-above .mat-tooltip:before{content:"";display:block;position:absolute;top:100%;border-style:solid;border-color:rgba(97,97,97,.9) transparent transparent transparent;border-width:6px;left:calc(50% - 6px)}'],
  data: {
    animation: [trigger("detailExpand", [state("collapsed", style({
      height: "0px",
      minHeight: "0"
    })), state("expanded", style({
      height: "*"
    })), transition("expanded <=> collapsed", animate("225ms cubic-bezier(0.4, 0.0, 0.2, 1)"))])]
  }
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DynamictableComponent, [{
    type: Component,
    args: [{
      selector: "cwp-dynamictable",
      animations: [trigger("detailExpand", [state("collapsed", style({
        height: "0px",
        minHeight: "0"
      })), state("expanded", style({
        height: "*"
      })), transition("expanded <=> collapsed", animate("225ms cubic-bezier(0.4, 0.0, 0.2, 1)"))])],
      template: `<div>
  <div class="leftPanel" *ngIf="configOptions.displayFilterPanel">
    <cwp-table-filter-panel
      [configOptions]="configOptions"
      (eventsHandler)="handleEvent($event)"
    ></cwp-table-filter-panel>
  </div>
  <div
    [ngClass]="
      configOptions.displayFilterPanel ? 'tableMainContent' : 'tableFullWidth'
    "
  >
    <div class="tableMain" id="tableMain" (scroll)="onTableScroll($event)">
      <table
        id="matTableMain"
        mat-table
        class="mat-elevation-z0 dynamictable"
        [dataSource]="dataSource"
        matSort
        multiTemplateDataRows
        cdkDropList
        [ngStyle]="{
          width: configOptions.tableWidth,
          'max-height': configOptions.tableHeight
        }"
        cdkDropListOrientation="horizontal"
        (cdkDropListDropped)="drop($event)"
        (scroll)="onTableScroll($event)"
      >
        <!-- Checkbox Column -->
        <ng-container
          matColumnDef="selected"
          *ngIf="configOptions.enableRowsSelection"
        >
          <th mat-header-cell *matHeaderCellDef class="w-50 rowselect-checkbox">
            <mat-checkbox
              (change)="$event ? masterToggle() : null"
              [checked]="selection.hasValue() && isAllSelected()"
              [indeterminate]="selection.hasValue() && !isAllSelected()"
              [aria-label]="checkboxLabel()"
            >
            </mat-checkbox>
          </th>
          <td mat-cell *matCellDef="let row" class="w-50">
            <mat-checkbox
              [disabled]="
                configOptions.enableRowsSelection &&
                !evaluateCondition(row, configOptions.enableRowLevelActions)
              "
              (click)="$event.stopPropagation()"
              (change)="$event ? toggleRowSelect(row) : null"
              [checked]="
                configOptions.enableRowsSelection &&
                evaluateCondition(row, configOptions.enableRowLevelActions) &&
                selection.isSelected(row)
              "
              [aria-label]="checkboxLabel(row)"
            >
            </mat-checkbox>
          </td>
        </ng-container>
        <!-- Other Dynamic Columns -->
        <ng-container
          [matColumnDef]="column.id"
          [sticky]="isSticky(stickyColumns, column.id)"
          [stickyEnd]="isStickyEnd(stickyEndColumns, column.id)"
          *ngFor="let column of displayedColumns"
        >
          <th
            mat-header-cell
            cdkDrag
            [cdkDragDisabled]="!column.movable"
            *matHeaderCellDef
            class="tableHeaderCell table-column"
            [disableClear]="true"
            mat-sort-header
            [disabled]="!column.sortable"
          >
            <!-- <th mat-header-cell cdkDrag [cdkDragDisabled]="column.disabled" *matHeaderCellDef class="tableHeaderCell"> -->
            <div class="headerCell">
              <div id="dynamictableHeadCellName" class="headerCellLabel">
                {{ column.displayName }}
                <span *ngIf="column.sortable === true">
                  <span
                    id="dynamictableSortAsc"
                    *ngIf="
                      sort &&
                      sort.active === column.id &&
                      sort.direction == 'asc'
                    "
                  >
                    &#8593;
                  </span>
                  <span
                    id="dynamictableSortDesc"
                    *ngIf="
                      sort &&
                      sort.active === column.id &&
                      sort.direction == 'desc'
                    "
                  >
                    &#8595;
                  </span>
                  <span *ngIf="sort && sort.active !== column.id">&#8645;</span>
                </span>
              </div>
              <div class="headerCellActions" (click)="$event.stopPropagation()">
                <button
                  id="dynamictableMoreOption"
                  type="button"
                  mat-icon-button
                  [matMenuTriggerFor]="menu"
                  *ngIf="column.showMenuOptions"
                  aria-label="icon-button with a menu"
                  (click)="$event.stopPropagation()"
                  aria-label="More Options"
                >
                  <mat-icon>more_horiz</mat-icon>
                </button>
                <mat-menu #menu="matMenu" xPosition="before">
                  <button
                    id="dynamictableHideCol"
                    type="button"
                    mat-menu-item
                    (click)="hideColumn(column.id)"
                    *ngIf="column.hideable"
                  >
                    Hide Column
                  </button>
                  <button
                    id="dynamictableMoveLeft"
                    type="button"
                    mat-menu-item
                    *ngIf="column.movable"
                    (click)="moveLeft(column.id)"
                  >
                    Move Left
                  </button>
                  <button
                    id="dynamictableMoveRight"
                    type="button"
                    mat-menu-item
                    *ngIf="column.movable"
                    (click)="moveRight(column.id)"
                  >
                    Move Right
                  </button>
                  <button
                    id="dynamictableStick"
                    type="button"
                    mat-menu-item
                    (click)="stick(column.id)"
                    *ngIf="
                      !isSticky(stickyColumns, column.id) && column.stickable
                    "
                  >
                    Stick
                  </button>
                  <!-- <button
                    mat-menu-item
                    (click)="stickToEnd(column.id)"
                    *ngIf="!isStickyEnd(stickyColumns, column.id)"
                  >
                    Stick to End
                  </button> -->
                  <button
                    id="dynamictableColStickable"
                    type="button"
                    mat-menu-item
                    (click)="unstick(column.id)"
                    *ngIf="
                      (isSticky(stickyColumns, column.id) ||
                        isStickyEnd(stickyEndColumns, column.id)) &&
                      column.stickable
                    "
                  >
                    Un-stick
                  </button>
                  <button
                    id="dynamictableAddGroup"
                    type="button"
                    mat-menu-item
                    *ngIf="
                      column.visible &&
                      column.groupable &&
                      !isGrouped(column.id)
                    "
                    [disabled]="this.configOptions.groupByColumns.length >= 3"
                    (click)="addGroup(column, $event)"
                  >
                    Group Rows by this Column
                  </button>
                  <button
                    id="dynamictableRemoveGroup"
                    type="button"
                    mat-menu-item
                    *ngIf="
                      column.visible && column.groupable && isGrouped(column.id)
                    "
                    (click)="removeGroup(column, $event)"
                  >
                    Un-group this Column
                  </button>
                </mat-menu>
              </div>
            </div>
          </th>
          <!-- <td _ngcontent-pqd-c296="" role="cell" mat-cell="" class="mat-cell cdk-cell cdk-column-name mat-column-name ng-tns-c296-0 ng-star-inserted">
            </td>
         -->
          <td
            mat-cell
            *matCellDef="let element; let i = dataIndex"
            [ngStyle]="evaluateExpression(element, column)"
            [attr.rowspan]="getRowSpan(column.id, i)"
            [style.display]="getRowSpan(column.id, i) ? '' : 'none'"
            class="table-column"
            (click)="onCellClick(element, column.id, column.controlType)"
            id="{{ column.id }}"
          >
            <div
              class="displayFlex"
              *ngIf="column && element"
              [ngClass]="{
                disabled:
                  element[column.controlValue?.dependentFieldId] === true &&
                  column.controlValue.disableBackground === true,
                'not-disabled':
                  element[column.controlValue?.dependentFieldId] === false &&
                  column.controlValue.disableBackground === true
              }"
            >
              <!-- <span
                *ngIf="
                  column.hasPreTextImage &&
                  element.preTextImageConfig &&
                  element.preTextImageConfig.logoAvialable === false
                "
                [ngStyle]="element.preTextImageConfig.style"
              >
                <avatar [text]="element.name"></avatar>
              </span> -->

              <img
                id="dynamictableImg"
                [src]="element.preTextImage.image"
                [ngStyle]="element.preTextImage.style"
                *ngIf="
                  column.hasPreTextImage &&
                  element.preTextImage &&
                  element.preTextImage.image &&
                  element.preTextImage.condition &&
                  evaluateCondition(element, element.preTextImage)
                "
                alt="Pre Image"
              />
              <span
                *ngIf="column.controlType === 'string'"
                [ngClass]="column?.hasMatToolTip ? 'mat-tooltip-parent' : ''"
              >
                <span
                  id="dynamictableColType"
                  *ngIf="!isArray(element[column.id])"
                  [ngStyle]="
                    getConditionalStyles(column.titleStyle, element, column)
                  "
                  (click)="onCellClick(element, column.id, column.controlType)"
                  #tooltip="matTooltip"
                  matTooltip="{{ element[column.id] }}"
                  matTooltipPosition="above"
                  [matTooltipDisabled]="!column.hasMatToolTip"
                >
                  {{ element[column.id] | dynamicTypePipe : column.type }}
                  <span
                    *ngIf="column.hasRightElement"
                    id="dynamictableRightElement"
                    [innerHTML]="element.rightElement"
                  >
                  </span>
                </span>
                <span
                  *ngIf="isArray(element[column.id])"
                  [ngStyle]="column.titleStyle"
                >
                  <span
                    id="dynamictableItem"
                    *ngFor="let item of element[column.id]; last as isLast"
                    (click)="onCellClick(element, column.id, item)"
                  >
                    {{ item }}<span *ngIf="!isLast">, </span></span
                  > </span
                ><br />
                <span
                  id="dynamictableSubtitle"
                  *ngIf="column.hasSubtitle"
                  [ngStyle]="
                    element[column.subtitleColumn] !== ''
                      ? column.subtitleStyle
                      : ''
                  "
                >
                  {{
                    element[column.subtitleColumn]
                      | dynamicTypePipe : column.type
                  }}
                </span>
                <span
                  *ngIf="column.hasBelowElement"
                  id="dynamictableSubtitleElement"
                >
                  <br />
                  <span [innerHTML]="element.belowElement"></span>
                </span>
              </span>

              <span *ngIf="column.controlType === 'slide-toggle'">
                <span class="slide-toggle">
                  <mat-slide-toggle
                    [checked]="element[column.id]"
                    (change)="onToggleChange($event)"
                  ></mat-slide-toggle>
                </span>
              </span>

              <span *ngIf="column.controlType === 'html'">
                <span [innerHTML]="element[column.id]"></span>
              </span>

              <span *ngIf="column.controlType === 'button'" class="button-span">
                <button
                  id="dynamictableColValue"
                  type="button"
                  mat-stroked-button
                  class="table-buttons"
                  *ngIf="!element[column.id]; else freeText"
                >
                  {{ column.controlValue }}
                </button>
                <ng-template #freeText>
                  <span id="dynamictableColId">
                    {{ element[column.id] }}
                  </span>
                </ng-template>
              </span>

              <span
                *ngIf="column.controlType === 'button-toggle'"
                class="mat-button-span"
              >
                <span
                  *ngIf="column?.controlValue.length && !element[column.id]"
                >
                  <ng-container *ngFor="let button of column?.controlValue">
                    <mat-button-toggle-group
                      #group="matButtonToggleGroup"
                      (change)="onValChange(element, group.value)"
                    >
                      <mat-button-toggle
                        [value]="button.value"
                        class="{{ button.class }}"
                      >
                        <mat-icon *ngIf="button.isIcon">
                          {{ button.iconName }}
                        </mat-icon>
                      </mat-button-toggle>
                    </mat-button-toggle-group>
                  </ng-container>
                </span>
                <span id="dynamictableColId" *ngIf="element[column.id]">
                  {{ element[column.id] }}
                </span>
              </span>

              <span *ngIf="column.controlType === 'menu'" class="button-span">
                <button
                  mat-stroked-button
                  class="table-buttons"
                  [matMenuTriggerFor]="menu"
                  *ngIf="!element[column.id]; else freeText"
                >
                  {{ column.controlValue['buttonName'] }}
                </button>
                <mat-menu #menu="matMenu">
                  <ng-template matMenuContent>
                    <button
                      mat-menu-item
                      (click)="onMenuButtonClick(element, column.id, btn)"
                      *ngFor="let btn of column.controlValue['menuButtonNames']"
                      class="mat-menu-button"
                    >
                      {{ btn }}
                    </button>
                  </ng-template>
                </mat-menu>
                <ng-template #freeText>
                  <span>
                    {{ element[column.id] }}
                  </span>
                </ng-template>
              </span>

              <span *ngIf="column.controlType === 'space-between'">
                <span class="space-between" [ngStyle]="column.titleStyle">
                  <div
                    *ngFor="
                      let value of getDisplayValues(
                        element[column.id],
                        column.controlValue
                      )
                    "
                  >
                    {{ value }}
                  </div>
                </span>
              </span>

              <span
                *ngIf="column.controlType === 'dropdown'"
                [id]="element.id"
                class="width-100"
              >
                <span
                  class="dropdown"
                  *ngIf="
                    getDisplayType(element, column, column.controlValue) ===
                    'dropdown'
                  "
                >
                  <span
                    id="dynamictableDropDown"
                    *ngIf="element[column.id] !== undefined"
                    class="dropdown-value"
                  >
                    {{ element[column.id] }}
                  </span>
                  <span
                    id="dynamictableSelect"
                    *ngIf="element[column.id] === undefined"
                    class="select-text"
                  >
                    Select
                  </span>
                  <span class="arrow">
                    <mat-icon>arrow_drop_down</mat-icon>
                  </span>
                </span>
                <span
                  id="dynamictableText"
                  *ngIf="
                    getDisplayType(element, column, column.controlValue) ===
                    'text'
                  "
                >
                  {{ element[column.id] }}
                </span>
              </span>

              <!-- <span
                *ngIf="
                  column.hasPostTextImage &&
                  element.postTextImageConfig &&
                  element.postTextImageConfig.logoAvialable === false
                "
                [ngStyle]="element.postTextImageConfig.style"
              >
                <avatar [text]="element.name"></avatar>
              </span> -->

              <img
                [src]="element.postTextImage.image"
                [ngStyle]="element.postTextImage.style"
                *ngIf="
                  column.hasPostTextImage &&
                  element.postTextImage &&
                  element.postTextImage.image &&
                  element.postTextImage.condition &&
                  evaluateCondition(element, element.postTextImage)
                "
                alt="Post Image"
              />
            </div>
          </td>
        </ng-container>
        <ng-container
          matColumnDef="actions"
          [stickyEnd]="true"
          *ngIf="configOptions.displayActionsColumn"
        >
          <th
            id="dynamictableAction"
            mat-header-cell
            *matHeaderCellDef
            class="w-50 actions-column tableHeaderCell table-column"
          >
            Actions
          </th>
          <td mat-cell *matCellDef="let row">
            <div class="action-icons-display-flex">
              <ng-container
                *ngIf="configOptions.rowLevelActions.iconAction; let iconAction"
              >
                <button
                  id="dynamictableRowLevelAction"
                  type="button"
                  mat-icon-button
                  class="more-actions"
                  (click)="onRowLevelActionIconClick(iconAction, row)"
                  aria-label="Row Level Action"
                >
                  <mat-icon
                    id="dynamictableIconToggleOn"
                    *ngIf="row[iconAction.property]"
                    [ngStyle]="iconAction.styleToggleOn"
                    (click)="onRowLevelActionIconClick(iconAction, row)"
                    class="action-icons"
                    >{{ iconAction.iconToggleOn }}
                  </mat-icon>
                  <mat-icon
                    id="dynamictableToggleOff"
                    *ngIf="!row[iconAction.property]"
                    [ngStyle]="iconAction.styleToggleOff"
                    (click)="onRowLevelActionIconClick(iconAction, row)"
                    class="action-icons"
                    >{{ iconAction.iconToggleOff }}</mat-icon
                  >
                </button>
              </ng-container>
              <button
                id="dynamictableActionMenu"
                type="button"
                mat-icon-button
                [matMenuTriggerFor]="actionsMenu"
                class="more-actions"
                [disabled]="
                  !evaluateCondition(row, configOptions.enableRowLevelActions)
                "
                aria-label="More Options"
              >
                <mat-icon id="dynamictableMoreIcon">more_horiz</mat-icon>
              </button>
              <mat-menu #actionsMenu="matMenu">
                <ng-container
                  *ngFor="
                    let action of configOptions.rowLevelActions.menuActions
                  "
                >
                  <ng-container *ngIf="action.type !== 'menu'">
                    <button
                      id="dynamictableActionClick"
                      type="button"
                      mat-menu-item
                      *ngIf="
                        !action.condition ||
                        (action.condition && evaluateCondition(row, action))
                      "
                      (click)="onRowLevelActionClick(action, row)"
                    >
                      <mat-icon
                        id="dynamictableActionIcon"
                        class="action-icons"
                        [ngClass]="{
                          'red-text':
                            action.title === 'Delete' ||
                            action.title === 'Deactivate' ||
                            action.title === 'Archive'
                        }"
                        *ngIf="action.icon"
                        >{{ action.icon }}</mat-icon
                      >
                      <span
                        id="dynamictableActionTitle"
                        [ngClass]="{
                          'red-text':
                            action.title === 'Delete' ||
                            action.title === 'Deactivate' ||
                            action.title === 'Archive'
                        }"
                        >{{ action.title }}</span
                      >
                    </button>
                  </ng-container>
                  <ng-container *ngIf="action.type === 'menu'">
                    <button
                      id="dynamictableActionClick"
                      type="button"
                      mat-menu-item
                      [matMenuTriggerFor]="nestedMenu"
                      *ngIf="
                        !action.condition ||
                        (action.condition && evaluateCondition(row, action))
                      "
                    >
                      <span id="dynamictableActionTitle">{{
                        action.title
                      }}</span>
                    </button>
                    <mat-menu #nestedMenu="matMenu">
                      <button
                        mat-menu-item
                        *ngFor="let subMenu of action.menuValues"
                        (click)="onRowLevelActionClick(action, row, subMenu)"
                      >
                        {{ subMenu }}
                      </button>
                    </mat-menu>
                  </ng-container>
                </ng-container>
              </mat-menu>
            </div>
          </td>
        </ng-container>
        <!-- Expanded Content Column - The detail row is made up of this one column that spans across all columns -->
        <ng-container matColumnDef="expandedDetail">
          <td
            mat-cell
            *matCellDef="let element"
            [attr.colspan]="columnsToDisplay.length"
          >
            <div
              class="example-element-detail"
              [@detailExpand]="
                element == expandedElement ? 'expanded' : 'collapsed'
              "
            >
              <div class="example-element-diagram">
                <div
                  id="dynamictableElementName"
                  class="example-element-position"
                >
                  {{ element.name }}
                </div>
                <div
                  id="dynamictableElementProgress"
                  class="example-element-symbol"
                >
                  {{ element.progress }}
                </div>
                <div
                  id="dynamictableElementExample"
                  class="example-element-name"
                >
                  {{ element.fruit }}
                </div>
                <div id="dynamictableElementId" class="example-element-weight">
                  {{ element.id }}
                </div>
              </div>
              <div
                id="dynamictableElementDesc"
                class="example-element-description"
              >
                {{ element.name }}
                <span class="example-element-description-attribution">
                  -- Wikipedia
                </span>
              </div>
            </div>
          </td>
        </ng-container>
        <tr
          mat-header-row
          *matHeaderRowDef="columnsToDisplay; sticky: true"
          class="headerRow"
        ></tr>
        <tr
          mat-row
          *matRowDef="let row; columns: columnsToDisplay"
          [class.example-expanded-row]="expandedElement === row"
          (click)="
            expandedElement = expandedElement === row ? null : row;
            highlight(row)
          "
          [ngClass]="{ highlight: selectedRowIndex == row?.id }"
        ></tr>
        <tr
          mat-row
          *matRowDef="let row; columns: ['expandedDetail']; when: customWhen"
          class="example-detail-row"
        ></tr>
      </table>
      <div *ngIf="!dataSource.data.length" class="noResultsContainer">
        <span id="dynamictableNoDataFound" class="noSearchResultsText">
          {{
            configOptions?.noDataText
              ? configOptions?.noDataText
              : 'No Data Found'
          }}
        </span>
      </div>
    </div>
    <mat-paginator
      *ngIf="configOptions.enablePagination"
      [pageSizeOptions]="[10, 25, 50, 75, 100]"
      aria-label="Select Page"
    ></mat-paginator>
  </div>
</div>
`,
      styles: ['table{width:100%}.dynamictable{box-shadow:none!important}.button-span,.mat-button-span{width:100%}.mat-button-span ::ng-deep .mat-button-toggle{margin-right:5px;border:1px solid #ccc;align-items:center;width:35px;height:35px}.mat-button-span ::ng-deep .mat-button-toggle-group-appearance-standard{border-radius:1px;border:none}.mat-button-span ::ng-deep .mat-button-toggle-label-content{line-height:34px;padding:0!important}.mat-button-span .approve-btn{background-color:#fff!important;color:#34c759!important;border-radius:4px}.mat-button-span .approve-btn:hover{background-color:#34c759!important;color:#fff!important}.mat-button-span .reject-btn{background-color:#fff!important;color:#f6685e!important;border-radius:4px}.mat-button-span .reject-btn:hover{background-color:#f6685e!important;color:#fff!important}.noResultsContainer{width:100%;height:50vh;display:flex;align-items:center;justify-content:center;background:#fff}.noResultsContainer .noSearchResultsText{font-weight:400;color:#000;opacity:.5;font-size:150%}.mat-form-field{font-size:14px;width:100%}tr.example-detail-row{height:0!important;background:#f2f2f2}tr.example-detail-row:hover{background:none!important;cursor:auto!important}tr.example-element-row:not(.example-expanded-row):hover{background:whitesmoke}tr.example-element-row:not(.example-expanded-row):active{background:#efefef}.example-element-row td{border-bottom-width:0}.example-element-detail{overflow:hidden;display:flex;background:#f2f2f2}.example-element-diagram{min-width:80px;border:2px solid black;padding:8px;font-weight:lighter;margin:8px 0;height:104px}.example-element-symbol{font-weight:700;font-size:40px;line-height:normal}.example-element-description{padding:16px}.example-element-description-attribution{opacity:.5}.headerRow{background:rgb(239,242,255)!important}.headerCell{display:flex;align-items:center;justify-content:space-between}.headerCellLabel{padding-left:5px;text-align:left;justify-content:space-between;align-items:center;align-content:center}button.mat-menu-item{width:100%;line-height:25px!important;height:35px!important;font-size:small}th.mat-header-cell{padding-left:10px;font-weight:500;color:#000;font-size:14px;font-family:Roboto;border-top:.5px solid #d8d8d8}th.mat-header-cell:last-child{border-right:.5px solid #d8d8d8}td.mat-cell{padding-left:16px;padding-right:16px!important}tr.mat-row{border:0px!important;cursor:pointer}tr.mat-row:hover{background:#f2f2f2}tr.mat-footer-row{border:1px solid #f2f2f2!important}.mat-paginator{display:block;height:50px!important;background:#f2f2f2}.tableFilterRow{align-items:center;justify-content:space-between}.searchbar{width:45%}::ng-deep .mat-form-field-wrapper{padding-bottom:0!important}.root{background:#f2f2f2}.rowselect-checkbox{padding-left:24px;padding-right:24px;width:2%;background:#eff2ff}.action-icons-display-flex{justify-content:flex-end;display:flex}.actions-column{min-width:20px!important;width:20px!important;text-align:right;padding-right:10px!important;padding-left:10px!important}.tableMainContent{background:#fff;border-left:.6px solid #b0b0b0}.tableMain{background:#fff;overflow:auto!important}.tableMain ::ng-deep .mat-sort-header-container{display:block!important}.tableMain ::ng-deep .mat-sort-header-content{display:block!important}.tableFullWidth{border-left:none!important}.leftPanel{padding:10px;width:20%;height:100%}.menu-content{height:inherit;width:inherit;background:lightgoldenrodyellow;padding:10px;margin:10px}.columnConfigListItem{font-size:10pt;height:25px!important}:host ::ng-deep .mat-sort-header-arrow{display:none!important}.table-column{min-width:140px}.mat-menu-button{width:150px}.action-icons{margin-top:2px;margin-right:5px!important;font-size:20px}.mat-table{display:block;width:100%;overflow:auto;max-height:95vh}.displayFlex{display:flex;align-items:center}.red-text{color:#f6685e}.more-actions{width:30px;height:30px;line-height:30px}.table-buttons{background-color:#fff;border:1px solid #3d5afe;color:#3d5afe;width:100%}.slide-toggle ::ng-deep .mat-slide-toggle-bar{width:36px;height:20px!important;border-radius:25px!important}.slide-toggle ::ng-deep .mat-slide-toggle.mat-checked .mat-slide-toggle-bar{background-color:#34c759!important}.slide-toggle ::ng-deep .mat-slide-toggle-thumb-container{top:2px!important;left:3px!important}.slide-toggle ::ng-deep .mat-slide-toggle-thumb{height:15px!important;width:15px!important}.slide-toggle ::ng-deep .mat-slide-toggle.mat-checked .mat-slide-toggle-thumb{background-color:#fff!important}.space-between{display:flex;justify-content:space-between}.highlight{background:whitesmoke}.date-picker{display:flex;justify-content:space-between}.date-picker ::ng-deep .mat-form-field-appearance-outline .mat-form-field-outline{color:transparent!important}.date-picker ::ng-deep .mat-form-field-appearance-outline .mat-form-field-flex{padding:0!important}.date-picker ::ng-deep .mat-form-field-infix{width:100%!important}.date-picker mat-icon{font-size:30px;line-height:63px;color:#0000008a}.width-100{width:100%}.dropdown{display:flex;justify-content:space-between;align-items:center}.dropdown .select-text{color:#9e9e9e}.dropdown .arrow{float:right}.dropdown mat-icon{font-size:30px;line-height:35px;color:#0000008a}::ng-deep .mat-menu-submenu-icon{display:none!important}.disabled{background-color:#e0e0e0}.not-disabled{background-color:#fff}.table-column .mat-tooltip-parent{display:flex;align-items:center}.table-column ::ng-deep .mat-tooltip-panel-above .mat-tooltip{overflow:visible;margin-bottom:8px}.table-column ::ng-deep .mat-tooltip-panel-above .mat-tooltip:before{content:"";display:block;position:absolute;top:100%;border-style:solid;border-color:rgba(97,97,97,.9) transparent transparent transparent;border-width:6px;left:calc(50% - 6px)}\n']
    }]
  }], function() {
    return [{
      type: MatSnackBar
    }, {
      type: ChangeDetectorRef
    }, {
      type: DynamictableFilterService
    }, {
      type: DomSanitizer
    }, {
      type: DynamictableScrollerService
    }];
  }, {
    paginator: [{
      type: ViewChild,
      args: [MatPaginator]
    }],
    sort: [{
      type: ViewChild,
      args: [MatSort]
    }],
    configOptions: [{
      type: Input
    }],
    dataSource: [{
      type: Input
    }],
    fetchDataCallback: [{
      type: Output
    }],
    rowLevelActionHandler: [{
      type: Output
    }],
    cellClickActionHandler: [{
      type: Output
    }],
    onConfigOptionsChange: [{
      type: Output
    }],
    onToggleChangeHandler: [{
      type: Output
    }],
    onSelectButtonToggle: [{
      type: Output
    }]
  });
})();
var SharedMaterialModule = class {
};
SharedMaterialModule.ɵfac = function SharedMaterialModule_Factory(ɵt) {
  return new (ɵt || SharedMaterialModule)();
};
SharedMaterialModule.ɵmod = ɵɵdefineNgModule({
  type: SharedMaterialModule,
  exports: [A11yModule, CdkAccordionModule, ClipboardModule, CdkStepperModule, CdkTableModule, CdkTreeModule, DragDropModule, MatAutocompleteModule, MatBadgeModule, MatBottomSheetModule, MatButtonModule, MatButtonToggleModule, MatCardModule, MatCheckboxModule, MatChipsModule, MatStepperModule, MatDatepickerModule, MatDialogModule, MatDividerModule, MatExpansionModule, MatGridListModule, MatIconModule, MatInputModule, MatListModule, MatMenuModule, MatNativeDateModule, MatPaginatorModule, MatProgressBarModule, MatProgressSpinnerModule, MatRadioModule, MatRippleModule, MatSelectModule, MatSidenavModule, MatSliderModule, MatSlideToggleModule, MatSnackBarModule, MatSortModule, MatTableModule, MatTabsModule, MatToolbarModule, MatTooltipModule, MatTreeModule, OverlayModule, PortalModule, ScrollingModule]
});
SharedMaterialModule.ɵinj = ɵɵdefineInjector({
  imports: [A11yModule, CdkAccordionModule, ClipboardModule, CdkStepperModule, CdkTableModule, CdkTreeModule, DragDropModule, MatAutocompleteModule, MatBadgeModule, MatBottomSheetModule, MatButtonModule, MatButtonToggleModule, MatCardModule, MatCheckboxModule, MatChipsModule, MatStepperModule, MatDatepickerModule, MatDialogModule, MatDividerModule, MatExpansionModule, MatGridListModule, MatIconModule, MatInputModule, MatListModule, MatMenuModule, MatNativeDateModule, MatPaginatorModule, MatProgressBarModule, MatProgressSpinnerModule, MatRadioModule, MatRippleModule, MatSelectModule, MatSidenavModule, MatSliderModule, MatSlideToggleModule, MatSnackBarModule, MatSortModule, MatTableModule, MatTabsModule, MatToolbarModule, MatTooltipModule, MatTreeModule, OverlayModule, PortalModule, ScrollingModule]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SharedMaterialModule, [{
    type: NgModule,
    args: [{
      exports: [A11yModule, CdkAccordionModule, ClipboardModule, CdkStepperModule, CdkTableModule, CdkTreeModule, DragDropModule, MatAutocompleteModule, MatBadgeModule, MatBottomSheetModule, MatButtonModule, MatButtonToggleModule, MatCardModule, MatCheckboxModule, MatChipsModule, MatStepperModule, MatDatepickerModule, MatDialogModule, MatDividerModule, MatExpansionModule, MatGridListModule, MatIconModule, MatInputModule, MatListModule, MatMenuModule, MatNativeDateModule, MatPaginatorModule, MatProgressBarModule, MatProgressSpinnerModule, MatRadioModule, MatRippleModule, MatSelectModule, MatSidenavModule, MatSliderModule, MatSlideToggleModule, MatSnackBarModule, MatSortModule, MatTableModule, MatTabsModule, MatToolbarModule, MatTooltipModule, MatTreeModule, OverlayModule, PortalModule, ScrollingModule]
    }]
  }], null, null);
})();
var AvatarComponent = class {
  ngOnInit() {
  }
  getText() {
    if (!this.text) {
      return;
    }
    let matches = this.text.charAt(0);
    return matches.toUpperCase();
  }
};
AvatarComponent.ɵfac = function AvatarComponent_Factory(ɵt) {
  return new (ɵt || AvatarComponent)();
};
AvatarComponent.ɵcmp = ɵɵdefineComponent({
  type: AvatarComponent,
  selectors: [["avatar"]],
  inputs: {
    text: "text"
  },
  decls: 2,
  vars: 1,
  consts: [[1, "avatar"]],
  template: function AvatarComponent_Template(rf, ctx) {
    if (rf & 1) {
      ɵɵelementStart(0, "span", 0);
      ɵɵtext(1);
      ɵɵelementEnd();
    }
    if (rf & 2) {
      ɵɵadvance();
      ɵɵtextInterpolate(ctx.getText());
    }
  },
  styles: [".avatar[_ngcontent-%COMP%]{width:40px;height:40px;background:#cacaca;border-radius:5px;display:inline-grid;text-align:center;align-items:center;color:#88888a;font-size:150%;font-weight:500}"]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AvatarComponent, [{
    type: Component,
    args: [{
      selector: "avatar",
      template: ` <span class="avatar">{{ getText() }}</span> `,
      styles: [`
      .avatar {
        width: 40px;
        height: 40px;
        background: #cacaca;
        border-radius: 5px;
        display: inline-grid;
        text-align: center;
        align-items: center;
        color: #88888a;
        font-size: 150%;
        font-weight: 500;
      }
    `]
    }]
  }], null, {
    text: [{
      type: Input
    }]
  });
})();
var DynamictableModule = class {
};
DynamictableModule.ɵfac = function DynamictableModule_Factory(ɵt) {
  return new (ɵt || DynamictableModule)();
};
DynamictableModule.ɵmod = ɵɵdefineNgModule({
  type: DynamictableModule,
  declarations: [DynamictableComponent, TableFilterPanelComponent, DynamicTypePipe, AvatarComponent, TimeAgoPipe],
  imports: [CommonModule, FormsModule, SharedMaterialModule],
  exports: [DynamictableComponent, TableFilterPanelComponent]
});
DynamictableModule.ɵinj = ɵɵdefineInjector({
  providers: [DynamictableFilterService, TimeAgoPipe],
  imports: [[CommonModule, FormsModule, SharedMaterialModule]]
});
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DynamictableModule, [{
    type: NgModule,
    args: [{
      declarations: [DynamictableComponent, TableFilterPanelComponent, DynamicTypePipe, AvatarComponent, TimeAgoPipe],
      imports: [CommonModule, FormsModule, SharedMaterialModule],
      exports: [DynamictableComponent, TableFilterPanelComponent],
      providers: [DynamictableFilterService, TimeAgoPipe]
    }]
  }], null, null);
})();
export {
  DynamictableComponent,
  DynamictableFilterService,
  DynamictableModule,
  DynamictableScrollerService,
  TableFilterPanelComponent
};
/*! Bundled license information:

@angular/cdk/fesm2020/layout.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/material/fesm2020/tooltip.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/material/fesm2020/tooltip.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/material/fesm2020/paginator.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/material/fesm2020/paginator.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/material/fesm2020/sort.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/material/fesm2020/snack-bar.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/material/fesm2020/slide-toggle.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/cdk/fesm2020/accordion.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/cdk/fesm2020/clipboard.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/cdk/fesm2020/stepper.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/cdk/fesm2020/stepper.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/cdk/fesm2020/tree.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/cdk/fesm2020/tree.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/cdk/fesm2020/tree.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/cdk/fesm2020/tree.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/material/fesm2020/bottom-sheet.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/material/fesm2020/chips.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/material/fesm2020/stepper.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/material/fesm2020/expansion.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/material/fesm2020/grid-list.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/material/fesm2020/grid-list.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/material/fesm2020/slider.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/material/fesm2020/tabs.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/material/fesm2020/tree.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/material/fesm2020/tree.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/material/fesm2020/tree.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)
*/
//# sourceMappingURL=@innovapptive__com_dynamictable.js.map
